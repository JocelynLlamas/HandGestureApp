var oK=Object.create;var Fg=Object.defineProperty,sK=Object.defineProperties,iK=Object.getOwnPropertyDescriptor,aK=Object.getOwnPropertyDescriptors,lK=Object.getOwnPropertyNames,Og=Object.getOwnPropertySymbols,uK=Object.getPrototypeOf,A0=Object.prototype.hasOwnProperty,E1=Object.prototype.propertyIsEnumerable;var N1=(t,n,e)=>n in t?Fg(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,Se=(t,n)=>{for(var e in n||={})A0.call(n,e)&&N1(t,e,n[e]);if(Og)for(var e of Og(n))E1.call(n,e)&&N1(t,e,n[e]);return t},an=(t,n)=>sK(t,aK(n));var D1=(t,n)=>{var e={};for(var r in t)A0.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(t!=null&&Og)for(var r of Og(t))n.indexOf(r)<0&&E1.call(t,r)&&(e[r]=t[r]);return e};var ao=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),ft=(t,n)=>{for(var e in n)Fg(t,e,{get:n[e],enumerable:!0})},cK=(t,n,e,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let o of lK(n))!A0.call(t,o)&&o!==e&&Fg(t,o,{get:()=>n[o],enumerable:!(r=iK(n,o))||r.enumerable});return t};var Sh=(t,n,e)=>(e=t!=null?oK(uK(t)):{},cK(n||!t||!t.__esModule?Fg(e,"default",{value:t,enumerable:!0}):e,t));var z=(t,n,e)=>new Promise((r,o)=>{var s=l=>{try{a(e.next(l))}catch(u){o(u)}},i=l=>{try{a(e.throw(l))}catch(u){o(u)}},a=l=>l.done?r(l.value):Promise.resolve(l.value).then(s,i);a((e=e.apply(t,n)).next())});var XO=ao((fSe,KO)=>{"use strict";KO.exports=Wt;var xo=null;try{xo=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Wt(t,n,e){this.low=t|0,this.high=n|0,this.unsigned=!!e}Wt.prototype.__isLong__;Object.defineProperty(Wt.prototype,"__isLong__",{value:!0});function Fr(t){return(t&&t.__isLong__)===!0}Wt.isLong=Fr;var BO={},zO={};function ec(t,n){var e,r,o;return n?(t>>>=0,(o=0<=t&&t<256)&&(r=zO[t],r)?r:(e=jt(t,(t|0)<0?-1:0,!0),o&&(zO[t]=e),e)):(t|=0,(o=-128<=t&&t<128)&&(r=BO[t],r)?r:(e=jt(t,t<0?-1:0,!1),o&&(BO[t]=e),e))}Wt.fromInt=ec;function bo(t,n){if(isNaN(t))return n?Ju:vo;if(n){if(t<0)return Ju;if(t>=WO)return qO}else{if(t<=-UO)return Or;if(t+1>=UO)return HO}return t<0?bo(-t,n).neg():jt(t%Xf|0,t/Xf|0,n)}Wt.fromNumber=bo;function jt(t,n,e){return new Wt(t,n,e)}Wt.fromBits=jt;var Ax=Math.pow;function GT(t,n,e){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return vo;if(typeof n=="number"?(e=n,n=!1):n=!!n,e=e||10,e<2||36<e)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return GT(t.substring(1),n,e).neg();for(var o=bo(Ax(e,8)),s=vo,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),l=parseInt(t.substring(i,i+a),e);if(a<8){var u=bo(Ax(e,a));s=s.mul(u).add(bo(l))}else s=s.mul(o),s=s.add(bo(l))}return s.unsigned=n,s}Wt.fromString=GT;function Ho(t,n){return typeof t=="number"?bo(t,n):typeof t=="string"?GT(t,n):jt(t.low,t.high,typeof n=="boolean"?n:t.unsigned)}Wt.fromValue=Ho;var VO=65536,V7=1<<24,Xf=VO*VO,WO=Xf*Xf,UO=WO/2,GO=ec(V7),vo=ec(0);Wt.ZERO=vo;var Ju=ec(0,!0);Wt.UZERO=Ju;var Kf=ec(1);Wt.ONE=Kf;var jO=ec(1,!0);Wt.UONE=jO;var UT=ec(-1);Wt.NEG_ONE=UT;var HO=jt(-1,2147483647,!1);Wt.MAX_VALUE=HO;var qO=jt(-1,-1,!0);Wt.MAX_UNSIGNED_VALUE=qO;var Or=jt(0,-2147483648,!1);Wt.MIN_VALUE=Or;var pe=Wt.prototype;pe.toInt=function(){return this.unsigned?this.low>>>0:this.low};pe.toNumber=function(){return this.unsigned?(this.high>>>0)*Xf+(this.low>>>0):this.high*Xf+(this.low>>>0)};pe.toString=function(n){if(n=n||10,n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Or)){var e=bo(n),r=this.div(e),o=r.mul(e).sub(this);return r.toString(n)+o.toInt().toString(n)}else return"-"+this.neg().toString(n);for(var s=bo(Ax(n,6),this.unsigned),i=this,a="";;){var l=i.div(s),u=i.sub(l.mul(s)).toInt()>>>0,c=u.toString(n);if(i=l,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};pe.getHighBits=function(){return this.high};pe.getHighBitsUnsigned=function(){return this.high>>>0};pe.getLowBits=function(){return this.low};pe.getLowBitsUnsigned=function(){return this.low>>>0};pe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Or)?64:this.neg().getNumBitsAbs();for(var n=this.high!=0?this.high:this.low,e=31;e>0&&!(n&1<<e);e--);return this.high!=0?e+33:e+1};pe.isZero=function(){return this.high===0&&this.low===0};pe.eqz=pe.isZero;pe.isNegative=function(){return!this.unsigned&&this.high<0};pe.isPositive=function(){return this.unsigned||this.high>=0};pe.isOdd=function(){return(this.low&1)===1};pe.isEven=function(){return(this.low&1)===0};pe.equals=function(n){return Fr(n)||(n=Ho(n)),this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1?!1:this.high===n.high&&this.low===n.low};pe.eq=pe.equals;pe.notEquals=function(n){return!this.eq(n)};pe.neq=pe.notEquals;pe.ne=pe.notEquals;pe.lessThan=function(n){return this.comp(n)<0};pe.lt=pe.lessThan;pe.lessThanOrEqual=function(n){return this.comp(n)<=0};pe.lte=pe.lessThanOrEqual;pe.le=pe.lessThanOrEqual;pe.greaterThan=function(n){return this.comp(n)>0};pe.gt=pe.greaterThan;pe.greaterThanOrEqual=function(n){return this.comp(n)>=0};pe.gte=pe.greaterThanOrEqual;pe.ge=pe.greaterThanOrEqual;pe.compare=function(n){if(Fr(n)||(n=Ho(n)),this.eq(n))return 0;var e=this.isNegative(),r=n.isNegative();return e&&!r?-1:!e&&r?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1};pe.comp=pe.compare;pe.negate=function(){return!this.unsigned&&this.eq(Or)?Or:this.not().add(Kf)};pe.neg=pe.negate;pe.add=function(n){Fr(n)||(n=Ho(n));var e=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=n.high>>>16,a=n.high&65535,l=n.low>>>16,u=n.low&65535,c=0,p=0,f=0,d=0;return d+=s+u,f+=d>>>16,d&=65535,f+=o+l,p+=f>>>16,f&=65535,p+=r+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,jt(f<<16|d,c<<16|p,this.unsigned)};pe.subtract=function(n){return Fr(n)||(n=Ho(n)),this.add(n.neg())};pe.sub=pe.subtract;pe.multiply=function(n){if(this.isZero())return vo;if(Fr(n)||(n=Ho(n)),xo){var e=xo.mul(this.low,this.high,n.low,n.high);return jt(e,xo.get_high(),this.unsigned)}if(n.isZero())return vo;if(this.eq(Or))return n.isOdd()?Or:vo;if(n.eq(Or))return this.isOdd()?Or:vo;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(GO)&&n.lt(GO))return bo(this.toNumber()*n.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=n.high>>>16,l=n.high&65535,u=n.low>>>16,c=n.low&65535,p=0,f=0,d=0,h=0;return h+=i*c,d+=h>>>16,h&=65535,d+=s*c,f+=d>>>16,d&=65535,d+=i*u,f+=d>>>16,d&=65535,f+=o*c,p+=f>>>16,f&=65535,f+=s*u,p+=f>>>16,f&=65535,f+=i*l,p+=f>>>16,f&=65535,p+=r*c+o*u+s*l+i*a,p&=65535,jt(d<<16|h,p<<16|f,this.unsigned)};pe.mul=pe.multiply;pe.divide=function(n){if(Fr(n)||(n=Ho(n)),n.isZero())throw Error("division by zero");if(xo){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1)return this;var e=(this.unsigned?xo.div_u:xo.div_s)(this.low,this.high,n.low,n.high);return jt(e,xo.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ju:vo;var r,o,s;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return Ju;if(n.gt(this.shru(1)))return jO;s=Ju}else{if(this.eq(Or)){if(n.eq(Kf)||n.eq(UT))return Or;if(n.eq(Or))return Kf;var i=this.shr(1);return r=i.div(n).shl(1),r.eq(vo)?n.isNegative()?Kf:UT:(o=this.sub(n.mul(r)),s=r.add(o.div(n)),s)}else if(n.eq(Or))return this.unsigned?Ju:vo;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();s=vo}for(o=this;o.gte(n);){r=Math.max(1,Math.floor(o.toNumber()/n.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:Ax(2,a-48),u=bo(r),c=u.mul(n);c.isNegative()||c.gt(o);)r-=l,u=bo(r,this.unsigned),c=u.mul(n);u.isZero()&&(u=Kf),s=s.add(u),o=o.sub(c)}return s};pe.div=pe.divide;pe.modulo=function(n){if(Fr(n)||(n=Ho(n)),xo){var e=(this.unsigned?xo.rem_u:xo.rem_s)(this.low,this.high,n.low,n.high);return jt(e,xo.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};pe.mod=pe.modulo;pe.rem=pe.modulo;pe.not=function(){return jt(~this.low,~this.high,this.unsigned)};pe.and=function(n){return Fr(n)||(n=Ho(n)),jt(this.low&n.low,this.high&n.high,this.unsigned)};pe.or=function(n){return Fr(n)||(n=Ho(n)),jt(this.low|n.low,this.high|n.high,this.unsigned)};pe.xor=function(n){return Fr(n)||(n=Ho(n)),jt(this.low^n.low,this.high^n.high,this.unsigned)};pe.shiftLeft=function(n){return Fr(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?jt(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):jt(0,this.low<<n-32,this.unsigned)};pe.shl=pe.shiftLeft;pe.shiftRight=function(n){return Fr(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?jt(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):jt(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};pe.shr=pe.shiftRight;pe.shiftRightUnsigned=function(n){if(Fr(n)&&(n=n.toInt()),n&=63,n===0)return this;var e=this.high;if(n<32){var r=this.low;return jt(r>>>n|e<<32-n,e>>>n,this.unsigned)}else return n===32?jt(e,0,this.unsigned):jt(e>>>n-32,0,this.unsigned)};pe.shru=pe.shiftRightUnsigned;pe.shr_u=pe.shiftRightUnsigned;pe.toSigned=function(){return this.unsigned?jt(this.low,this.high,!1):this};pe.toUnsigned=function(){return this.unsigned?this:jt(this.low,this.high,!0)};pe.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()};pe.toBytesLE=function(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};pe.toBytesBE=function(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Wt.fromBytes=function(n,e,r){return r?Wt.fromBytesLE(n,e):Wt.fromBytesBE(n,e)};Wt.fromBytesLE=function(n,e){return new Wt(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,e)};Wt.fromBytesBE=function(n,e){return new Wt(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],e)}});var LF=ao((rd,PF)=>{"use strict";var EQ=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},uc=EQ();PF.exports=rd=uc.fetch;uc.fetch&&(rd.default=uc.fetch.bind(uc));rd.Headers=uc.Headers;rd.Request=uc.Request;rd.Response=uc.Response});var BF=ao(()=>{"use strict"});var hM=ao((dM,gN)=>{"use strict";(function(t,n,e){function r(a){var l=this,u=i();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(a),l.s0<0&&(l.s0+=1),l.s1-=u(a),l.s1<0&&(l.s1+=1),l.s2-=u(a),l.s2<0&&(l.s2+=1),u=null}function o(a,l){return l.c=a.c,l.s0=a.s0,l.s1=a.s1,l.s2=a.s2,l}function s(a,l){var u=new r(a),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,u),p.state=function(){return o(u,{})}),p}function i(){var a=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){a+=u.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(dM,typeof gN=="object"&&gN,typeof define=="function"&&define)});var gM=ao((mM,yN)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(mM,typeof yN=="object"&&yN,typeof define=="function"&&define)});var xM=ao((yM,xN)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,u==l.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(yM,typeof xN=="object"&&xN,typeof define=="function"&&define)});var vM=ao((bM,bN)=>{"use strict";(function(t,n,e){function r(i){var a=this;a.next=function(){var u=a.x,c=a.i,p,f,d;return p=u[c],p^=p>>>7,f=p^p<<24,p=u[c+1&7],f^=p^p>>>10,p=u[c+3&7],f^=p^p>>>3,p=u[c+4&7],f^=p^p<<7,p=u[c+7&7],p=p^p<<13,f^=p^p<<9,u[c]=f,a.i=c+1&7,f};function l(u,c){var p,f,d=[];if(c===(c|0))f=d[0]=c;else for(c=""+c,p=0;p<c.length;++p)d[p&7]=d[p&7]<<15^c.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8?f=d[7]=-1:f=d[p],u.x=d,u.i=0,p=256;p>0;--p)u.next()}l(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(u.x&&o(u,l),c.state=function(){return o(l,{})}),c}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(bM,typeof bN=="object"&&bN,typeof define=="function"&&define)});var CM=ao((wM,vN)=>{"use strict";(function(t,n,e){function r(i){var a=this;a.next=function(){var u=a.w,c=a.X,p=a.i,f,d;return a.w=u=u+1640531527|0,d=c[p+34&127],f=c[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,d=c[p]=d^f,a.i=p,d+(u^u>>>16)|0};function l(u,c){var p,f,d,h,g,m=[],y=128;for(c===(c|0)?(f=c,c=null):(c=c+"\0",f=0,y=Math.max(y,c.length)),d=0,h=-32;h<y;++h)c&&(f^=c.charCodeAt((h+32)%c.length)),h===0&&(g=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,h>=0&&(g=g+1640531527|0,p=m[h&127]^=f+g,d=p==0?d+1:0);for(d>=128&&(m[(c&&c.length||0)&127]=-1),d=127,h=4*128;h>0;--h)f=m[d+34&127],p=m[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,m[d]=f^p;u.w=g,u.X=m,u.i=d}l(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(u.X&&o(u,l),c.state=function(){return o(l,{})}),c}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(wM,typeof vN=="object"&&vN,typeof define=="function"&&define)});var SM=ao((IM,wN)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.next=function(){var c=a.b,p=a.c,f=a.d,d=a.a;return c=c<<25^c>>>7^p,p=p-f|0,f=f<<24^f>>>8^d,d=d-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-f|0,a.d=f<<16^p>>>16^d,a.a=d-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):l+=i;for(var u=0;u<l.length+20;u++)a.b^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(IM,typeof wN=="object"&&wN,typeof define=="function"&&define)});var TM=ao(()=>{"use strict"});var EM=ao((NM,Rb)=>{"use strict";(function(t,n,e){var r=256,o=6,s=52,i="random",a=e.pow(r,o),l=e.pow(2,s),u=l*2,c=r-1,p;function f(v,w,T){var k=[];w=w==!0?{entropy:!0}:w||{};var A=m(g(w.entropy?[v,x(n)]:v??y(),3),k),O=new d(k),M=function(){for(var L=O.g(o),V=a,U=0;L<l;)L=(L+U)*r,V*=r,U=O.g(1);for(;L>=u;)L/=2,V/=2,U>>>=1;return(L+U)/V};return M.int32=function(){return O.g(4)|0},M.quick=function(){return O.g(4)/4294967296},M.double=M,m(x(O.S),n),(w.pass||T||function(L,V,U,G){return G&&(G.S&&h(G,O),L.state=function(){return h(O,{})}),U?(e[i]=L,V):L})(M,A,"global"in w?w.global:this==e,w.state)}function d(v){var w,T=v.length,k=this,A=0,O=k.i=k.j=0,M=k.S=[];for(T||(v=[T++]);A<r;)M[A]=A++;for(A=0;A<r;A++)M[A]=M[O=c&O+v[A%T]+(w=M[A])],M[O]=w;(k.g=function(L){for(var V,U=0,G=k.i,j=k.j,H=k.S;L--;)V=H[G=c&G+1],U=U*r+H[c&(H[G]=H[j=c&j+V])+(H[j]=V)];return k.i=G,k.j=j,U})(r)}function h(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function g(v,w){var T=[],k=typeof v,A;if(w&&k=="object")for(A in v)try{T.push(g(v[A],w-1))}catch{}return T.length?T:k=="string"?v:v+"\0"}function m(v,w){for(var T=v+"",k,A=0;A<T.length;)w[c&A]=c&(k^=w[c&A]*19)+T.charCodeAt(A++);return x(w)}function y(){try{var v;return p&&(v=p.randomBytes)?v=v(r):(v=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(v)),x(v)}catch{var w=t.navigator,T=w&&w.plugins;return[+new Date,t,T,t.screen,x(n)]}}function x(v){return String.fromCharCode.apply(0,v)}if(m(e.random(),n),typeof Rb=="object"&&Rb.exports){Rb.exports=f;try{p=TM()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):e["seed"+i]=f})(typeof self<"u"?self:NM,[],Math)});var Pm=ao((QLe,DM)=>{"use strict";var fte=hM(),dte=gM(),hte=xM(),mte=vM(),gte=CM(),yte=SM(),gc=EM();gc.alea=fte;gc.xor128=dte;gc.xorwow=hte;gc.xorshift7=mte;gc.xor4096=gte;gc.tychei=yte;DM.exports=gc});var _0=null;var R0=1,k1=Symbol("SIGNAL");function Et(t){let n=_0;return _0=t,n}function A1(){return _0}var O0={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function pK(t){if(!(L0(t)&&!t.dirty)&&!(!t.dirty&&t.lastCleanEpoch===R0)){if(!t.producerMustRecompute(t)&&!M0(t)){t.dirty=!1,t.lastCleanEpoch=R0;return}t.producerRecomputeValue(t),t.dirty=!1,t.lastCleanEpoch=R0}}function F0(t){return t&&(t.nextProducerIndex=0),Et(t)}function R1(t,n){if(Et(n),!(!t||t.producerNode===void 0||t.producerIndexOfThis===void 0||t.producerLastReadVersion===void 0)){if(L0(t))for(let e=t.nextProducerIndex;e<t.producerNode.length;e++)P0(t.producerNode[e],t.producerIndexOfThis[e]);for(;t.producerNode.length>t.nextProducerIndex;)t.producerNode.pop(),t.producerLastReadVersion.pop(),t.producerIndexOfThis.pop()}}function M0(t){B0(t);for(let n=0;n<t.producerNode.length;n++){let e=t.producerNode[n],r=t.producerLastReadVersion[n];if(r!==e.version||(pK(e),r!==e.version))return!0}return!1}function $0(t){if(B0(t),L0(t))for(let n=0;n<t.producerNode.length;n++)P0(t.producerNode[n],t.producerIndexOfThis[n]);t.producerNode.length=t.producerLastReadVersion.length=t.producerIndexOfThis.length=0,t.liveConsumerNode&&(t.liveConsumerNode.length=t.liveConsumerIndexOfThis.length=0)}function P0(t,n){if(fK(t),t.liveConsumerNode.length===1&&dK(t))for(let r=0;r<t.producerNode.length;r++)P0(t.producerNode[r],t.producerIndexOfThis[r]);let e=t.liveConsumerNode.length-1;if(t.liveConsumerNode[n]=t.liveConsumerNode[e],t.liveConsumerIndexOfThis[n]=t.liveConsumerIndexOfThis[e],t.liveConsumerNode.length--,t.liveConsumerIndexOfThis.length--,n<t.liveConsumerNode.length){let r=t.liveConsumerIndexOfThis[n],o=t.liveConsumerNode[n];B0(o),o.producerIndexOfThis[r]=n}}function L0(t){return t.consumerIsAlwaysLive||(t?.liveConsumerNode?.length??0)>0}function B0(t){t.producerNode??=[],t.producerIndexOfThis??=[],t.producerLastReadVersion??=[]}function fK(t){t.liveConsumerNode??=[],t.liveConsumerIndexOfThis??=[]}function dK(t){return t.producerNode!==void 0}function hK(){throw new Error}var mK=hK;function _1(t){mK=t}function He(t){return typeof t=="function"}function Kc(t){let e=t(r=>{Error.call(r),r.stack=new Error().stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}var Mg=Kc(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:
${e.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=e});function Th(t,n){if(t){let e=t.indexOf(n);0<=e&&t.splice(e,1)}}var gn=class t{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;let{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(let s of e)s.remove(this);else e.remove(this);let{initialTeardown:r}=this;if(He(r))try{r()}catch(s){n=s instanceof Mg?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{O1(s)}catch(i){n=n??[],i instanceof Mg?n=[...n,...i.errors]:n.push(i)}}if(n)throw new Mg(n)}}add(n){var e;if(n&&n!==this)if(this.closed)O1(n);else{if(n instanceof t){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=(e=this._finalizers)!==null&&e!==void 0?e:[]).push(n)}}_hasParent(n){let{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){let{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){let{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&Th(e,n)}remove(n){let{_finalizers:e}=this;e&&Th(e,n),n instanceof t&&n._removeParent(this)}};gn.EMPTY=(()=>{let t=new gn;return t.closed=!0,t})();var z0=gn.EMPTY;function $g(t){return t instanceof gn||t&&"closed"in t&&He(t.remove)&&He(t.add)&&He(t.unsubscribe)}function O1(t){He(t)?t():t.unsubscribe()}var Bo={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var Xc={setTimeout(t,n,...e){let{delegate:r}=Xc;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){let{delegate:n}=Xc;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function Pg(t){Xc.setTimeout(()=>{let{onUnhandledError:n}=Bo;if(n)n(t);else throw t})}function Nh(){}var F1=V0("C",void 0,void 0);function M1(t){return V0("E",void 0,t)}function $1(t){return V0("N",t,void 0)}function V0(t,n,e){return{kind:t,value:n,error:e}}var hu=null;function Yc(t){if(Bo.useDeprecatedSynchronousErrorHandling){let n=!hu;if(n&&(hu={errorThrown:!1,error:null}),t(),n){let{errorThrown:e,error:r}=hu;if(hu=null,e)throw r}}else t()}function P1(t){Bo.useDeprecatedSynchronousErrorHandling&&hu&&(hu.errorThrown=!0,hu.error=t)}var mu=class extends gn{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,$g(n)&&n.add(this)):this.destination=xK}static create(n,e,r){return new Zc(n,e,r)}next(n){this.isStopped?G0($1(n),this):this._next(n)}error(n){this.isStopped?G0(M1(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?G0(F1,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},gK=Function.prototype.bind;function U0(t,n){return gK.call(t,n)}var W0=class{constructor(n){this.partialObserver=n}next(n){let{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){Lg(r)}}error(n){let{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){Lg(r)}else Lg(n)}complete(){let{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){Lg(e)}}},Zc=class extends mu{constructor(n,e,r){super();let o;if(He(n)||!n)o={next:n??void 0,error:e??void 0,complete:r??void 0};else{let s;this&&Bo.useDeprecatedNextContext?(s=Object.create(n),s.unsubscribe=()=>this.unsubscribe(),o={next:n.next&&U0(n.next,s),error:n.error&&U0(n.error,s),complete:n.complete&&U0(n.complete,s)}):o=n}this.destination=new W0(o)}};function Lg(t){Bo.useDeprecatedSynchronousErrorHandling?P1(t):Pg(t)}function yK(t){throw t}function G0(t,n){let{onStoppedNotification:e}=Bo;e&&Xc.setTimeout(()=>e(t,n))}var xK={closed:!0,next:Nh,error:yK,complete:Nh};var Qc=typeof Symbol=="function"&&Symbol.observable||"@@observable";function qr(t){return t}function j0(...t){return H0(t)}function H0(t){return t.length===0?qr:t.length===1?t[0]:function(e){return t.reduce((r,o)=>o(r),e)}}var Dt=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){let r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,o){let s=vK(e)?e:new Zc(e,r,o);return Yc(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return r=L1(r),new r((o,s)=>{let i=new Zc({next:a=>{try{e(a)}catch(l){s(l),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(e){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(e)}[Qc](){return this}pipe(...e){return H0(e)(this)}toPromise(e){return e=L1(e),new e((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return t.create=n=>new t(n),t})();function L1(t){var n;return(n=t??Bo.Promise)!==null&&n!==void 0?n:Promise}function bK(t){return t&&He(t.next)&&He(t.error)&&He(t.complete)}function vK(t){return t&&t instanceof mu||bK(t)&&$g(t)}function q0(t){return He(t?.lift)}function at(t){return n=>{if(q0(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function lt(t,n,e,r,o){return new K0(t,n,e,r,o)}var K0=class extends mu{constructor(n,e,r,o,s,i){super(n),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=o?function(a){try{o(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:e}=this;super.unsubscribe(),!e&&((n=this.onFinalize)===null||n===void 0||n.call(this))}}};function Jc(){return at((t,n)=>{let e=null;t._refCount++;let r=lt(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount){e=null;return}let o=t._connection,s=e;e=null,o&&(!s||o===s)&&o.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}var ep=class extends Dt{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,q0(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){let n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;let{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new gn;let e=this.getSubject();n.add(this.source.subscribe(lt(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=gn.EMPTY)}return n}refCount(){return Jc()(this)}};var B1=Kc(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var gr=(()=>{class t extends Dt{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){let r=new Bg(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new B1}next(e){Yc(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(e)}})}error(e){Yc(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;let{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Yc(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return((e=this.observers)===null||e===void 0?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){let{hasError:r,isStopped:o,observers:s}=this;return r||o?z0:(this.currentObservers=null,s.push(e),new gn(()=>{this.currentObservers=null,Th(s,e)}))}_checkFinalizedStatuses(e){let{hasError:r,thrownError:o,isStopped:s}=this;r?e.error(o):s&&e.complete()}asObservable(){let e=new Dt;return e.source=this,e}}return t.create=(n,e)=>new Bg(n,e),t})(),Bg=class extends gr{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.next)===null||r===void 0||r.call(e,n)}error(n){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.error)===null||r===void 0||r.call(e,n)}complete(){var n,e;(e=(n=this.destination)===null||n===void 0?void 0:n.complete)===null||e===void 0||e.call(n)}_subscribe(n){var e,r;return(r=(e=this.source)===null||e===void 0?void 0:e.subscribe(n))!==null&&r!==void 0?r:z0}};var qn=class extends gr{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){let e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){let{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}};var Kr=new Dt(t=>t.complete());function z1(t){return t&&He(t.schedule)}function V1(t){return t[t.length-1]}function U1(t){return He(V1(t))?t.pop():void 0}function Ta(t){return z1(V1(t))?t.pop():void 0}function W1(t,n,e,r){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{u(r.next(c))}catch(p){i(p)}}function l(c){try{u(r.throw(c))}catch(p){i(p)}}function u(c){c.done?s(c.value):o(c.value).then(a,l)}u((r=r.apply(t,n||[])).next())})}function G1(t){var n=typeof Symbol=="function"&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&typeof t.length=="number")return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function gu(t){return this instanceof gu?(this.v=t,this):new gu(t)}function j1(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=e.apply(t,n||[]),o,s=[];return o=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype),a("next"),a("throw"),a("return",i),o[Symbol.asyncIterator]=function(){return this},o;function i(d){return function(h){return Promise.resolve(h).then(d,p)}}function a(d,h){r[d]&&(o[d]=function(g){return new Promise(function(m,y){s.push([d,g,m,y])>1||l(d,g)})},h&&(o[d]=h(o[d])))}function l(d,h){try{u(r[d](h))}catch(g){f(s[0][3],g)}}function u(d){d.value instanceof gu?Promise.resolve(d.value.v).then(c,p):f(s[0][2],d)}function c(d){l("next",d)}function p(d){l("throw",d)}function f(d,h){d(h),s.shift(),s.length&&l(s[0][0],s[0][1])}}function H1(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n=t[Symbol.asyncIterator],e;return n?n.call(t):(t=typeof G1=="function"?G1(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(s){e[s]=t[s]&&function(i){return new Promise(function(a,l){i=t[s](i),o(a,l,i.done,i.value)})}}function o(s,i,a,l){Promise.resolve(l).then(function(u){s({value:u,done:a})},i)}}var zg=t=>t&&typeof t.length=="number"&&typeof t!="function";function Vg(t){return He(t?.then)}function Ug(t){return He(t[Qc])}function Gg(t){return Symbol.asyncIterator&&He(t?.[Symbol.asyncIterator])}function Wg(t){return new TypeError(`You provided ${t!==null&&typeof t=="object"?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}function wK(){return typeof Symbol!="function"||!Symbol.iterator?"@@iterator":Symbol.iterator}var jg=wK();function Hg(t){return He(t?.[jg])}function qg(t){return j1(this,arguments,function*(){let e=t.getReader();try{for(;;){let{value:r,done:o}=yield gu(e.read());if(o)return yield gu(void 0);yield yield gu(r)}}finally{e.releaseLock()}})}function Kg(t){return He(t?.getReader)}function Ln(t){if(t instanceof Dt)return t;if(t!=null){if(Ug(t))return CK(t);if(zg(t))return IK(t);if(Vg(t))return SK(t);if(Gg(t))return q1(t);if(Hg(t))return TK(t);if(Kg(t))return NK(t)}throw Wg(t)}function CK(t){return new Dt(n=>{let e=t[Qc]();if(He(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}function IK(t){return new Dt(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}function SK(t){return new Dt(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,Pg)})}function TK(t){return new Dt(n=>{for(let e of t)if(n.next(e),n.closed)return;n.complete()})}function q1(t){return new Dt(n=>{EK(t,n).catch(e=>n.error(e))})}function NK(t){return q1(qg(t))}function EK(t,n){var e,r,o,s;return W1(this,void 0,void 0,function*(){try{for(e=H1(t);r=yield e.next(),!r.done;){let i=r.value;if(n.next(i),n.closed)return}}catch(i){o={error:i}}finally{try{r&&!r.done&&(s=e.return)&&(yield s.call(e))}finally{if(o)throw o.error}}n.complete()})}function Dr(t,n,e,r=0,o=!1){let s=n.schedule(function(){e(),o?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(s),!o)return s}function Xg(t,n=0){return at((e,r)=>{e.subscribe(lt(r,o=>Dr(r,t,()=>r.next(o),n),()=>Dr(r,t,()=>r.complete(),n),o=>Dr(r,t,()=>r.error(o),n)))})}function Yg(t,n=0){return at((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function K1(t,n){return Ln(t).pipe(Yg(n),Xg(n))}function X1(t,n){return Ln(t).pipe(Yg(n),Xg(n))}function Y1(t,n){return new Dt(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}function Z1(t,n){return new Dt(e=>{let r;return Dr(e,n,()=>{r=t[jg](),Dr(e,n,()=>{let o,s;try{({value:o,done:s}=r.next())}catch(i){e.error(i);return}s?e.complete():e.next(o)},0,!0)}),()=>He(r?.return)&&r.return()})}function Zg(t,n){if(!t)throw new Error("Iterable cannot be null");return new Dt(e=>{Dr(e,n,()=>{let r=t[Symbol.asyncIterator]();Dr(e,n,()=>{r.next().then(o=>{o.done?e.complete():e.next(o.value)})},0,!0)})})}function Q1(t,n){return Zg(qg(t),n)}function J1(t,n){if(t!=null){if(Ug(t))return K1(t,n);if(zg(t))return Y1(t,n);if(Vg(t))return X1(t,n);if(Gg(t))return Zg(t,n);if(Hg(t))return Z1(t,n);if(Kg(t))return Q1(t,n)}throw Wg(t)}function yn(t,n){return n?J1(t,n):Ln(t)}function Ve(...t){let n=Ta(t);return yn(t,n)}function tp(t,n){let e=He(t)?t:()=>t,r=o=>o.error(e());return new Dt(n?o=>n.schedule(r,0,o):r)}function X0(t){return!!t&&(t instanceof Dt||He(t.lift)&&He(t.subscribe))}var Xs=Kc(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"});function nt(t,n){return at((e,r)=>{let o=0;e.subscribe(lt(r,s=>{r.next(t.call(n,s,o++))}))})}var{isArray:DK}=Array;function kK(t,n){return DK(n)?t(...n):t(n)}function ek(t){return nt(n=>kK(t,n))}var{isArray:AK}=Array,{getPrototypeOf:RK,prototype:_K,keys:OK}=Object;function tk(t){if(t.length===1){let n=t[0];if(AK(n))return{args:n,keys:null};if(FK(n)){let e=OK(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}function FK(t){return t&&typeof t=="object"&&RK(t)===_K}function nk(t,n){return t.reduce((e,r,o)=>(e[r]=n[o],e),{})}function Qg(...t){let n=Ta(t),e=U1(t),{args:r,keys:o}=tk(t);if(r.length===0)return yn([],n);let s=new Dt(MK(r,n,o?i=>nk(o,i):qr));return e?s.pipe(ek(e)):s}function MK(t,n,e=qr){return r=>{rk(n,()=>{let{length:o}=t,s=new Array(o),i=o,a=o;for(let l=0;l<o;l++)rk(n,()=>{let u=yn(t[l],n),c=!1;u.subscribe(lt(r,p=>{s[l]=p,c||(c=!0,a--),a||r.next(e(s.slice()))},()=>{--i||r.complete()}))},r)},r)}}function rk(t,n,e){t?Dr(e,t,n):n()}function ok(t,n,e,r,o,s,i,a){let l=[],u=0,c=0,p=!1,f=()=>{p&&!l.length&&!u&&n.complete()},d=g=>u<r?h(g):l.push(g),h=g=>{s&&n.next(g),u++;let m=!1;Ln(e(g,c++)).subscribe(lt(n,y=>{o?.(y),s?d(y):n.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<r;){let y=l.shift();i?Dr(n,i,()=>h(y)):h(y)}f()}catch(y){n.error(y)}}))};return t.subscribe(lt(n,d,()=>{p=!0,f()})),()=>{a?.()}}function Dn(t,n,e=1/0){return He(n)?Dn((r,o)=>nt((s,i)=>n(r,s,o,i))(Ln(t(r,o))),e):(typeof n=="number"&&(e=n),at((r,o)=>ok(r,o,t,e)))}function Y0(t=1/0){return Dn(qr,t)}function sk(){return Y0(1)}function np(...t){return sk()(yn(t,Ta(t)))}function Jg(t){return new Dt(n=>{Ln(t()).subscribe(n)})}function lo(t,n){return at((e,r)=>{let o=0;e.subscribe(lt(r,s=>t.call(n,s,o++)&&r.next(s)))})}function Na(t){return at((n,e)=>{let r=null,o=!1,s;r=n.subscribe(lt(e,void 0,void 0,i=>{s=Ln(t(i,Na(t)(n))),r?(r.unsubscribe(),r=null,s.subscribe(e)):o=!0})),o&&(r.unsubscribe(),r=null,s.subscribe(e))})}function ik(t,n,e,r,o){return(s,i)=>{let a=e,l=n,u=0;s.subscribe(lt(i,c=>{let p=u++;l=a?t(l,c,p):(a=!0,c),r&&i.next(l)},o&&(()=>{a&&i.next(l),i.complete()})))}}function yu(t,n){return He(n)?Dn(t,n,1):Dn(t,1)}function Ea(t){return at((n,e)=>{let r=!1;n.subscribe(lt(e,o=>{r=!0,e.next(o)},()=>{r||e.next(t),e.complete()}))})}function Ys(t){return t<=0?()=>Kr:at((n,e)=>{let r=0;n.subscribe(lt(e,o=>{++r<=t&&(e.next(o),t<=r&&e.complete())}))})}function Z0(t){return nt(()=>t)}function ey(t=$K){return at((n,e)=>{let r=!1;n.subscribe(lt(e,o=>{r=!0,e.next(o)},()=>r?e.complete():e.error(t())))})}function $K(){return new Xs}function rp(t){return at((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}function zo(t,n){let e=arguments.length>=2;return r=>r.pipe(t?lo((o,s)=>t(o,s,r)):qr,Ys(1),e?Ea(n):ey(()=>new Xs))}function op(t){return t<=0?()=>Kr:at((n,e)=>{let r=[];n.subscribe(lt(e,o=>{r.push(o),t<r.length&&r.shift()},()=>{for(let o of r)e.next(o);e.complete()},void 0,()=>{r=null}))})}function Q0(t,n){let e=arguments.length>=2;return r=>r.pipe(t?lo((o,s)=>t(o,s,r)):qr,op(1),e?Ea(n):ey(()=>new Xs))}function J0(t,n){return at(ik(t,n,arguments.length>=2,!0))}function eI(...t){let n=Ta(t);return at((e,r)=>{(n?np(t,e,n):np(t,e)).subscribe(r)})}function uo(t,n){return at((e,r)=>{let o=null,s=0,i=!1,a=()=>i&&!o&&r.complete();e.subscribe(lt(r,l=>{o?.unsubscribe();let u=0,c=s++;Ln(t(l,c)).subscribe(o=lt(r,p=>r.next(n?n(l,p,c,u++):p),()=>{o=null,a()}))},()=>{i=!0,a()}))})}function tI(t){return at((n,e)=>{Ln(t).subscribe(lt(e,()=>e.complete(),Nh)),!e.closed&&n.subscribe(e)})}function kn(t,n,e){let r=He(t)||n||e?{next:t,error:n,complete:e}:t;return r?at((o,s)=>{var i;(i=r.subscribe)===null||i===void 0||i.call(r);let a=!0;o.subscribe(lt(s,l=>{var u;(u=r.next)===null||u===void 0||u.call(r,l),s.next(l)},()=>{var l;a=!1,(l=r.complete)===null||l===void 0||l.call(r),s.complete()},l=>{var u;a=!1,(u=r.error)===null||u===void 0||u.call(r,l),s.error(l)},()=>{var l,u;a&&((l=r.unsubscribe)===null||l===void 0||l.call(r)),(u=r.finalize)===null||u===void 0||u.call(r)}))}):qr}var Oe=class extends Error{constructor(n,e){super(Ry(n,e)),this.code=n}};function Ry(t,n){return`${`NG0${Math.abs(t)}`}${n?": "+n:""}`}function eS(t){return{toString:t}.toString()}function Ft(t){for(let n in t)if(t[n]===Ft)return n;throw Error("Could not find renamed property on target object.")}function Xr(t){if(typeof t=="string")return t;if(Array.isArray(t))return"["+t.map(Xr).join(", ")+"]";if(t==null)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;let n=t.toString();if(n==null)return""+n;let e=n.indexOf(`
`);return e===-1?n:n.substring(0,e)}function ak(t,n){return t==null||t===""?n===null?"":n:n==null||n===""?t:t+" "+n}var PK=Ft({__forward_ref__:Ft});function Uk(t){return t.__forward_ref__=Uk,t.toString=function(){return Xr(this())},t}function po(t){return Gk(t)?t():t}function Gk(t){return typeof t=="function"&&t.hasOwnProperty(PK)&&t.__forward_ref__===Uk}function Ge(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function _y(t){return lk(t,jk)||lk(t,Hk)}function Wk(t){return _y(t)!==null}function lk(t,n){return t.hasOwnProperty(n)?t[n]:null}function LK(t){let n=t&&(t[jk]||t[Hk]);return n||null}function uk(t){return t&&(t.hasOwnProperty(ck)||t.hasOwnProperty(BK))?t[ck]:null}var jk=Ft({\u0275prov:Ft}),ck=Ft({\u0275inj:Ft}),Hk=Ft({ngInjectableDef:Ft}),BK=Ft({ngInjectorDef:Ft}),Be=class{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,typeof e=="number"?this.__NG_ELEMENT_ID__=e:e!==void 0&&(this.\u0275prov=Ge({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function qk(t){return t&&!!t.\u0275providers}var zK=Ft({\u0275cmp:Ft}),VK=Ft({\u0275dir:Ft}),UK=Ft({\u0275pipe:Ft}),GK=Ft({\u0275mod:Ft}),py=Ft({\u0275fac:Ft}),kh=Ft({__NG_ELEMENT_ID__:Ft}),pk=Ft({__NG_ENV_ID__:Ft});function WK(t){return typeof t=="string"?t:t==null?"":String(t)}function jK(t){return typeof t=="function"?t.name||t.toString():typeof t=="object"&&t!=null&&typeof t.type=="function"?t.type.name||t.type.toString():WK(t)}function HK(t,n){let e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new Oe(-200,t)}function tS(t,n){throw new Oe(-201,!1)}var Qe=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}(Qe||{}),fI;function Kk(){return fI}function co(t){let n=fI;return fI=t,n}function Xk(t,n,e){let r=_y(t);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(e&Qe.Optional)return null;if(n!==void 0)return n;tS(t,"Injector")}var qK={},Ah=qK,KK="__NG_DI_FLAG__",fy="ngTempTokenPath",XK="ngTokenPath",YK=/\n/gm,ZK="\u0275",fk="__source",lp;function QK(){return lp}function Da(t){let n=lp;return lp=t,n}function JK(t,n=Qe.Default){if(lp===void 0)throw new Oe(-203,!1);return lp===null?Xk(t,void 0,n):lp.get(t,n&Qe.Optional?null:void 0,n)}function st(t,n=Qe.Default){return(Kk()||JK)(po(t),n)}function ue(t,n=Qe.Default){return st(t,Oy(n))}function Oy(t){return typeof t>"u"||typeof t=="number"?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function dI(t){let n=[];for(let e=0;e<t.length;e++){let r=po(t[e]);if(Array.isArray(r)){if(r.length===0)throw new Oe(900,!1);let o,s=Qe.Default;for(let i=0;i<r.length;i++){let a=r[i],l=e6(a);typeof l=="number"?l===-1?o=a.token:s|=l:o=a}n.push(st(o,s))}else n.push(st(r))}return n}function e6(t){return t[KK]}function t6(t,n,e,r){let o=t[fy];throw n[fk]&&o.unshift(n[fk]),t.message=n6(`
`+t.message,o,e,r),t[XK]=o,t[fy]=null,t}function n6(t,n,e,r=null){t=t&&t.charAt(0)===`
`&&t.charAt(1)==ZK?t.slice(2):t;let o=Xr(n);if(Array.isArray(n))o=n.map(Xr).join(" -> ");else if(typeof n=="object"){let s=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];s.push(i+":"+(typeof a=="string"?JSON.stringify(a):Xr(a)))}o=`{${s.join(", ")}}`}return`${e}${r?"("+r+")":""}[${o}]: ${t.replace(YK,`
  `)}`}function cp(t,n){let e=t.hasOwnProperty(py);return e?t[py]:null}function r6(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let o=t[r],s=n[r];if(e&&(o=e(o),s=e(s)),s!==o)return!1}return!0}function o6(t){return t.flat(Number.POSITIVE_INFINITY)}function nS(t,n){t.forEach(e=>Array.isArray(e)?nS(e,n):n(e))}function Yk(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function dy(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}var Rh={},bu=[],vu=new Be(""),Zk=new Be("",-1),Qk=new Be(""),hy=class{get(n,e=Ah){if(e===Ah){let r=new Error(`NullInjectorError: No provider for ${Xr(n)}!`);throw r.name="NullInjectorError",r}return e}},Jk=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}(Jk||{}),hs=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}(hs||{}),Ra=function(t){return t[t.None=0]="None",t[t.SignalBased=1]="SignalBased",t[t.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",t}(Ra||{});function s6(t,n,e){let r=t.length;for(;;){let o=t.indexOf(n,e);if(o===-1)return o;if(o===0||t.charCodeAt(o-1)<=32){let s=n.length;if(o+s===r||t.charCodeAt(o+s)<=32)return o}e=o+1}}function hI(t,n,e){let r=0;for(;r<e.length;){let o=e[r];if(typeof o=="number"){if(o!==0)break;r++;let s=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,s)}else{let s=o,i=e[++r];a6(s)?t.setProperty(n,s,i):t.setAttribute(n,s,i),r++}}return r}function i6(t){return t===3||t===4||t===6}function a6(t){return t.charCodeAt(0)===64}function rS(t,n){if(!(n===null||n.length===0))if(t===null||t.length===0)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){let o=n[r];typeof o=="number"?e=o:e===0||(e===-1||e===2?dk(t,e,o,null,n[++r]):dk(t,e,o,null,null))}}return t}function dk(t,n,e,r,o){let s=0,i=t.length;if(n===-1)i=-1;else for(;s<t.length;){let a=t[s++];if(typeof a=="number"){if(a===n){i=-1;break}else if(a>n){i=s-1;break}}}for(;s<t.length;){let a=t[s];if(typeof a=="number")break;if(a===e){if(r===null){o!==null&&(t[s+1]=o);return}else if(r===t[s+1]){t[s+2]=o;return}}s++,r!==null&&s++,o!==null&&s++}i!==-1&&(t.splice(i,0,n),s=i+1),t.splice(s++,0,e),r!==null&&t.splice(s++,0,r),o!==null&&t.splice(s++,0,o)}var eA="ng-template";function l6(t,n,e,r){let o=0;if(r){for(;o<n.length&&typeof n[o]=="string";o+=2)if(n[o]==="class"&&s6(n[o+1].toLowerCase(),e,0)!==-1)return!0}else if(oS(t))return!1;if(o=n.indexOf(1,o),o>-1){let s;for(;++o<n.length&&typeof(s=n[o])=="string";)if(s.toLowerCase()===e)return!0}return!1}function oS(t){return t.type===4&&t.value!==eA}function u6(t,n,e){let r=t.type===4&&!e?eA:t.value;return n===r}function c6(t,n,e){let r=4,o=t.attrs,s=o!==null?d6(o):0,i=!1;for(let a=0;a<n.length;a++){let l=n[a];if(typeof l=="number"){if(!i&&!Vo(r)&&!Vo(l))return!1;if(i&&Vo(l))continue;i=!1,r=l|r&1;continue}if(!i)if(r&4){if(r=2|r&1,l!==""&&!u6(t,l,e)||l===""&&n.length===1){if(Vo(r))return!1;i=!0}}else if(r&8){if(o===null||!l6(t,o,l,e)){if(Vo(r))return!1;i=!0}}else{let u=n[++a],c=p6(l,o,oS(t),e);if(c===-1){if(Vo(r))return!1;i=!0;continue}if(u!==""){let p;if(c>s?p="":p=o[c+1].toLowerCase(),r&2&&u!==p){if(Vo(r))return!1;i=!0}}}}return Vo(r)||i}function Vo(t){return(t&1)===0}function p6(t,n,e,r){if(n===null)return-1;let o=0;if(r||!e){let s=!1;for(;o<n.length;){let i=n[o];if(i===t)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=n[++o];for(;typeof a=="string";)a=n[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return h6(n,t)}function f6(t,n,e=!1){for(let r=0;r<n.length;r++)if(c6(t,n[r],e))return!0;return!1}function d6(t){for(let n=0;n<t.length;n++){let e=t[n];if(i6(e))return n}return t.length}function h6(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){let r=t[e];if(typeof r=="number")return-1;if(r===n)return e;e++}return-1}function hk(t,n){return t?":not("+n.trim()+")":n}function m6(t){let n=t[0],e=1,r=2,o="",s=!1;for(;e<t.length;){let i=t[e];if(typeof i=="string")if(r&2){let a=t[++e];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!Vo(i)&&(n+=hk(s,o),o=""),r=i,s=s||!Vo(r);e++}return o!==""&&(n+=hk(s,o)),n}function g6(t){return t.map(m6).join(",")}function y6(t){let n=[],e=[],r=1,o=2;for(;r<t.length;){let s=t[r];if(typeof s=="string")o===2?s!==""&&n.push(s,t[++r]):o===8&&e.push(s);else{if(!Vo(o))break;o=s}r++}return{attrs:n,classes:e}}function xp(t){return eS(()=>{let n=sA(t),e=an(Se({},n),{decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===Jk.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,signals:t.signals??!1,data:t.data||{},encapsulation:t.encapsulation||hs.Emulated,styles:t.styles||bu,_:null,schemas:t.schemas||null,tView:null,id:""});iA(e);let r=t.dependencies;return e.directiveDefs=gk(r,!1),e.pipeDefs=gk(r,!0),e.id=v6(e),e})}function x6(t){return wu(t)||tA(t)}function b6(t){return t!==null}function mk(t,n){if(t==null)return Rh;let e={};for(let r in t)if(t.hasOwnProperty(r)){let o=t[r],s,i,a=Ra.None;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s):(s=o,i=o),n?(e[s]=a!==Ra.None?[r,a]:r,n[s]=i):e[s]=r}return e}function sS(t){return eS(()=>{let n=sA(t);return iA(n),n})}function wu(t){return t[zK]||null}function tA(t){return t[VK]||null}function nA(t){return t[UK]||null}function rA(t){let n=wu(t)||tA(t)||nA(t);return n!==null?n.standalone:!1}function oA(t,n){let e=t[GK]||null;if(!e&&n===!0)throw new Error(`Type ${Xr(t)} does not have '\u0275mod' property.`);return e}function sA(t){let n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,inputTransforms:null,inputConfig:t.inputs||Rh,exportAs:t.exportAs||null,standalone:t.standalone===!0,signals:t.signals===!0,selectors:t.selectors||bu,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:mk(t.inputs,n),outputs:mk(t.outputs),debugInfo:null}}function iA(t){t.features?.forEach(n=>n(t))}function gk(t,n){if(!t)return null;let e=n?nA:x6;return()=>(typeof t=="function"?t():t).map(r=>e(r)).filter(b6)}function v6(t){let n=0,e=[t.selectors,t.ngContentSelectors,t.hostVars,t.hostAttrs,t.consts,t.vars,t.decls,t.encapsulation,t.standalone,t.signals,t.exportAs,JSON.stringify(t.inputs),JSON.stringify(t.outputs),Object.getOwnPropertyNames(t.type.prototype),!!t.contentQueries,!!t.viewQuery].join("|");for(let o of e)n=Math.imul(31,n)+o.charCodeAt(0)<<0;return n+=2147483648,"c"+n}function Nu(t){return{\u0275providers:t}}function w6(...t){return{\u0275providers:aA(!0,t),\u0275fromNgModule:!0}}function aA(t,...n){let e=[],r=new Set,o,s=i=>{e.push(i)};return nS(n,i=>{let a=i;mI(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&lA(o,s),e}function lA(t,n){for(let e=0;e<t.length;e++){let{ngModule:r,providers:o}=t[e];iS(o,s=>{n(s,r)})}}function mI(t,n,e,r){if(t=po(t),!t)return!1;let o=null,s=uk(t),i=!s&&wu(t);if(!s&&!i){let l=t.ngModule;if(s=uk(l),s)o=l;else return!1}else{if(i&&!i.standalone)return!1;o=t}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let l=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let u of l)mI(u,n,e,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let u;try{nS(s.imports,c=>{mI(c,n,e,r)&&(u||=[],u.push(c))})}finally{}u!==void 0&&lA(u,n)}if(!a){let u=cp(o)||(()=>new o);n({provide:o,useFactory:u,deps:bu},o),n({provide:Qk,useValue:o,multi:!0},o),n({provide:vu,useValue:()=>st(o),multi:!0},o)}let l=s.providers;if(l!=null&&!a){let u=t;iS(l,c=>{n(c,u)})}}else return!1;return o!==t&&t.providers!==void 0}function iS(t,n){for(let e of t)qk(e)&&(e=e.\u0275providers),Array.isArray(e)?iS(e,n):n(e)}var C6=Ft({provide:String,useValue:Ft});function uA(t){return t!==null&&typeof t=="object"&&C6 in t}function I6(t){return!!(t&&t.useExisting)}function S6(t){return!!(t&&t.useFactory)}function gI(t){return typeof t=="function"}var Fy=new Be(""),sy={},T6={},nI;function aS(){return nI===void 0&&(nI=new hy),nI}var ho=class{},_h=class extends ho{get destroyed(){return this._destroyed}constructor(n,e,r,o){super(),this.parent=e,this.source=r,this.scopes=o,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,xI(n,i=>this.processProvider(i)),this.records.set(Zk,sp(void 0,this)),o.has("environment")&&this.records.set(ho,sp(void 0,this));let s=this.records.get(Fy);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(Qk,bu,Qe.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;let n=Et(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let e=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of e)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),Et(n)}}onDestroy(n){return this.assertNotDestroyed(),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){this.assertNotDestroyed();let e=Da(this),r=co(void 0),o;try{return n()}finally{Da(e),co(r)}}get(n,e=Ah,r=Qe.Default){if(this.assertNotDestroyed(),n.hasOwnProperty(pk))return n[pk](this);r=Oy(r);let o,s=Da(this),i=co(void 0);try{if(!(r&Qe.SkipSelf)){let l=this.records.get(n);if(l===void 0){let u=R6(n)&&_y(n);u&&this.injectableDefInScope(u)?l=sp(yI(n),sy):l=null,this.records.set(n,l)}if(l!=null)return this.hydrate(n,l)}let a=r&Qe.Self?aS():this.parent;return e=r&Qe.Optional&&e===Ah?null:e,a.get(n,e)}catch(a){if(a.name==="NullInjectorError"){if((a[fy]=a[fy]||[]).unshift(Xr(n)),s)throw a;return t6(a,n,"R3InjectorError",this.source)}else throw a}finally{co(i),Da(s)}}resolveInjectorInitializers(){let n=Et(null),e=Da(this),r=co(void 0),o;try{let s=this.get(vu,bu,Qe.Self);for(let i of s)i()}finally{Da(e),co(r),Et(n)}}toString(){let n=[],e=this.records;for(let r of e.keys())n.push(Xr(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Oe(205,!1)}processProvider(n){n=po(n);let e=gI(n)?n:po(n&&n.provide),r=E6(n);if(!gI(n)&&n.multi===!0){let o=this.records.get(e);o||(o=sp(void 0,sy,!0),o.factory=()=>dI(o.multi),this.records.set(e,o)),e=n,o.multi.push(n)}this.records.set(e,r)}hydrate(n,e){let r=Et(null);try{return e.value===sy&&(e.value=T6,e.value=e.factory()),typeof e.value=="object"&&e.value&&A6(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}finally{Et(r)}}injectableDefInScope(n){if(!n.providedIn)return!1;let e=po(n.providedIn);return typeof e=="string"?e==="any"||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(n){let e=this._onDestroyHooks.indexOf(n);e!==-1&&this._onDestroyHooks.splice(e,1)}};function yI(t){let n=_y(t),e=n!==null?n.factory:cp(t);if(e!==null)return e;if(t instanceof Be)throw new Oe(204,!1);if(t instanceof Function)return N6(t);throw new Oe(204,!1)}function N6(t){if(t.length>0)throw new Oe(204,!1);let e=LK(t);return e!==null?()=>e.factory(t):()=>new t}function E6(t){if(uA(t))return sp(void 0,t.useValue);{let n=D6(t);return sp(n,sy)}}function D6(t,n,e){let r;if(gI(t)){let o=po(t);return cp(o)||yI(o)}else if(uA(t))r=()=>po(t.useValue);else if(S6(t))r=()=>t.useFactory(...dI(t.deps||[]));else if(I6(t))r=()=>st(po(t.useExisting));else{let o=po(t&&(t.useClass||t.provide));if(k6(t))r=()=>new o(...dI(t.deps));else return cp(o)||yI(o)}return r}function sp(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function k6(t){return!!t.deps}function A6(t){return t!==null&&typeof t=="object"&&typeof t.ngOnDestroy=="function"}function R6(t){return typeof t=="function"||typeof t=="object"&&t instanceof Be}function xI(t,n){for(let e of t)Array.isArray(e)?xI(e,n):e&&qk(e)?xI(e.\u0275providers,n):n(e)}function gs(t,n){t instanceof _h&&t.assertNotDestroyed();let e,r=Da(t),o=co(void 0);try{return n()}finally{Da(r),co(o)}}function _6(){return Kk()!==void 0||QK()!=null}function O6(t){return typeof t=="function"}var Yr=0,Xe=1,Ue=2,Kn=3,Uo=4,Go=5,ms=6,bI=7,_a=8,pp=9,Zs=10,rr=11,Oh=12,yk=13,Bh=14,mo=15,Cu=16,ip=17,Qs=18,My=19,cA=20,Aa=21,rI=22,fo=23,go=25,pA=1,Fh=6,Js=7,my=8,fp=9,kr=10,gy=function(t){return t[t.None=0]="None",t[t.HasTransplantedViews=2]="HasTransplantedViews",t}(gy||{});function ds(t){return Array.isArray(t)&&typeof t[pA]=="object"}function ys(t){return Array.isArray(t)&&t[pA]===!0}function fA(t){return(t.flags&4)!==0}function $y(t){return t.componentOffset>-1}function F6(t){return(t.flags&1)===1}function zh(t){return!!t.template}function yy(t){return(t[Ue]&512)!==0}var vI=class{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}};function dA(t,n,e,r){n!==null?n.applyValueToInputSignal(n,r):t[e]=r}function Py(){return hA}function hA(t){return t.type.prototype.ngOnChanges&&(t.setInput=$6),M6}Py.ngInherit=!0;function M6(){let t=gA(this),n=t?.current;if(n){let e=t.previous;if(e===Rh)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function $6(t,n,e,r,o){let s=this.declaredInputs[r],i=gA(t)||P6(t,{previous:Rh,current:null}),a=i.current||(i.current={}),l=i.previous,u=l[s];a[s]=new vI(u&&u.currentValue,e,l===Rh),dA(t,n,o,e)}var mA="__ngSimpleChanges__";function gA(t){return t[mA]||null}function P6(t,n){return t[mA]=n}var xk=null;var ka=function(t,n,e){xk?.(t,n,e)},L6="svg",B6="math";function ei(t){for(;Array.isArray(t);)t=t[Yr];return t}function xs(t,n){return ei(n[t.index])}function z6(t,n){return t.data[n]}function Vh(t,n){let e=n[t];return ds(e)?e:e[Yr]}function V6(t){return(t[Ue]&4)===4}function lS(t){return(t[Ue]&128)===128}function U6(t){return ys(t[Kn])}function bk(t,n){return n==null?null:t[n]}function yA(t){t[ip]=0}function xA(t){t[Ue]&1024||(t[Ue]|=1024,lS(t)&&By(t))}function Ly(t){return!!(t[Ue]&9216||t[fo]?.dirty)}function wI(t){t[Zs].changeDetectionScheduler?.notify(8),t[Ue]&64&&(t[Ue]|=1024),Ly(t)&&By(t)}function By(t){t[Zs].changeDetectionScheduler?.notify(0);let n=Iu(t);for(;n!==null&&!(n[Ue]&8192||(n[Ue]|=8192,!lS(n)));)n=Iu(n)}function bA(t,n){if((t[Ue]&256)===256)throw new Oe(911,!1);t[Aa]===null&&(t[Aa]=[]),t[Aa].push(n)}function G6(t,n){if(t[Aa]===null)return;let e=t[Aa].indexOf(n);e!==-1&&t[Aa].splice(e,1)}function Iu(t){let n=t[Kn];return ys(n)?n[Kn]:n}var Ct={lFrame:DA(null),bindingsEnabled:!0,skipHydrationRootTNode:null};var vA=!1;function W6(){return Ct.lFrame.elementDepthCount}function j6(){Ct.lFrame.elementDepthCount++}function H6(){Ct.lFrame.elementDepthCount--}function wA(){return Ct.bindingsEnabled}function Uh(){return Ct.skipHydrationRootTNode!==null}function q6(t){return Ct.skipHydrationRootTNode===t}function K6(t){Ct.skipHydrationRootTNode=t}function X6(){Ct.skipHydrationRootTNode=null}function Ar(){return Ct.lFrame.lView}function zy(){return Ct.lFrame.tView}function bs(){let t=CA();for(;t!==null&&t.type===64;)t=t.parent;return t}function CA(){return Ct.lFrame.currentTNode}function Y6(){let t=Ct.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}function uS(t,n){let e=Ct.lFrame;e.currentTNode=t,e.isParent=n}function IA(){return Ct.lFrame.isParent}function Z6(){Ct.lFrame.isParent=!1}function SA(){return vA}function vk(t){vA=t}function Q6(t){return Ct.lFrame.bindingIndex=t}function J6(){return Ct.lFrame.inI18n}function e8(t,n){let e=Ct.lFrame;e.bindingIndex=e.bindingRootIndex=t,CI(n)}function t8(){return Ct.lFrame.currentDirectiveIndex}function CI(t){Ct.lFrame.currentDirectiveIndex=t}function TA(){return Ct.lFrame.currentQueryIndex}function cS(t){Ct.lFrame.currentQueryIndex=t}function n8(t){let n=t[Xe];return n.type===2?n.declTNode:n.type===1?t[Go]:null}function NA(t,n,e){if(e&Qe.SkipSelf){let o=n,s=t;for(;o=o.parent,o===null&&!(e&Qe.Host);)if(o=n8(s),o===null||(s=s[Bh],o.type&10))break;if(o===null)return!1;n=o,t=s}let r=Ct.lFrame=EA();return r.currentTNode=n,r.lView=t,!0}function pS(t){let n=EA(),e=t[Xe];Ct.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function EA(){let t=Ct.lFrame,n=t===null?null:t.child;return n===null?DA(t):n}function DA(t){let n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return t!==null&&(t.child=n),n}function kA(){let t=Ct.lFrame;return Ct.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}var AA=kA;function fS(){let t=kA();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function r8(){return Ct.lFrame.selectedIndex}function Su(t){Ct.lFrame.selectedIndex=t}function RA(){return Ct.lFrame.currentNamespace}var _A=!0;function o8(){return _A}function Fa(t){_A=t}function s8(t,n,e){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=n.type.prototype;if(r){let i=hA(n);(e.preOrderHooks??=[]).push(t,i),(e.preOrderCheckHooks??=[]).push(t,i)}o&&(e.preOrderHooks??=[]).push(0-t,o),s&&((e.preOrderHooks??=[]).push(t,s),(e.preOrderCheckHooks??=[]).push(t,s))}function OA(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){let s=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=s;i&&(t.contentHooks??=[]).push(-e,i),a&&((t.contentHooks??=[]).push(e,a),(t.contentCheckHooks??=[]).push(e,a)),l&&(t.viewHooks??=[]).push(-e,l),u&&((t.viewHooks??=[]).push(e,u),(t.viewCheckHooks??=[]).push(e,u)),c!=null&&(t.destroyHooks??=[]).push(e,c)}}function iy(t,n,e){FA(t,n,3,e)}function ay(t,n,e,r){(t[Ue]&3)===e&&FA(t,n,e,r)}function oI(t,n){let e=t[Ue];(e&3)===n&&(e&=16383,e+=1,t[Ue]=e)}function FA(t,n,e,r){let o=r!==void 0?t[ip]&65535:0,s=r??-1,i=n.length-1,a=0;for(let l=o;l<i;l++)if(typeof n[l+1]=="number"){if(a=n[l],r!=null&&a>=r)break}else n[l]<0&&(t[ip]+=65536),(a<s||s==-1)&&(i8(t,e,n,l),t[ip]=(t[ip]&4294901760)+l+2),l++}function wk(t,n){ka(4,t,n);let e=Et(null);try{n.call(t)}finally{Et(e),ka(5,t,n)}}function i8(t,n,e,r){let o=e[r]<0,s=e[r+1],i=o?-e[r]:e[r],a=t[i];o?t[Ue]>>14<t[ip]>>16&&(t[Ue]&3)===n&&(t[Ue]+=16384,wk(a,s)):wk(a,s)}var up=-1,Mh=class{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}};function a8(t){return t instanceof Mh}function l8(t){return(t.flags&8)!==0}function u8(t){return(t.flags&16)!==0}var sI={},II=class{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=Oy(r);let o=this.injector.get(n,sI,r);return o!==sI||e===sI?o:this.parentInjector.get(n,e,r)}};function MA(t){return t!==up}function xy(t){return t&32767}function c8(t){return t>>16}function by(t,n){let e=c8(t),r=n;for(;e>0;)r=r[Bh],e--;return r}var SI=!0;function Ck(t){let n=SI;return SI=t,n}var p8=256,$A=p8-1,PA=5,f8=0,fs={};function d8(t,n,e){let r;typeof e=="string"?r=e.charCodeAt(0)||0:e.hasOwnProperty(kh)&&(r=e[kh]),r==null&&(r=e[kh]=f8++);let o=r&$A,s=1<<o;n.data[t+(o>>PA)]|=s}function LA(t,n){let e=BA(t,n);if(e!==-1)return e;let r=n[Xe];r.firstCreatePass&&(t.injectorIndex=n.length,iI(r.data,t),iI(n,null),iI(r.blueprint,null));let o=dS(t,n),s=t.injectorIndex;if(MA(o)){let i=xy(o),a=by(o,n),l=a[Xe].data;for(let u=0;u<8;u++)n[s+u]=a[i+u]|l[i+u]}return n[s+8]=o,s}function iI(t,n){t.push(0,0,0,0,0,0,0,0,n)}function BA(t,n){return t.injectorIndex===-1||t.parent&&t.parent.injectorIndex===t.injectorIndex||n[t.injectorIndex+8]===null?-1:t.injectorIndex}function dS(t,n){if(t.parent&&t.parent.injectorIndex!==-1)return t.parent.injectorIndex;let e=0,r=null,o=n;for(;o!==null;){if(r=WA(o),r===null)return up;if(e++,o=o[Bh],r.injectorIndex!==-1)return r.injectorIndex|e<<16}return up}function h8(t,n,e){d8(t,n,e)}function zA(t,n,e){if(e&Qe.Optional||t!==void 0)return t;tS(n,"NodeInjector")}function VA(t,n,e,r){if(e&Qe.Optional&&r===void 0&&(r=null),!(e&(Qe.Self|Qe.Host))){let o=t[pp],s=co(void 0);try{return o?o.get(n,r,e&Qe.Optional):Xk(n,r,e&Qe.Optional)}finally{co(s)}}return zA(r,n,e)}function UA(t,n,e,r=Qe.Default,o){if(t!==null){if(n[Ue]&2048&&!(r&Qe.Self)){let i=x8(t,n,e,r,fs);if(i!==fs)return i}let s=GA(t,n,e,r,fs);if(s!==fs)return s}return VA(n,e,r,o)}function GA(t,n,e,r,o){let s=g8(e);if(typeof s=="function"){if(!NA(n,t,r))return r&Qe.Host?zA(o,e,r):VA(n,e,r,o);try{let i;if(i=s(r),i==null&&!(r&Qe.Optional))tS(e);else return i}finally{AA()}}else if(typeof s=="number"){let i=null,a=BA(t,n),l=up,u=r&Qe.Host?n[mo][Go]:null;for((a===-1||r&Qe.SkipSelf)&&(l=a===-1?dS(t,n):n[a+8],l===up||!Sk(r,!1)?a=-1:(i=n[Xe],a=xy(l),n=by(l,n)));a!==-1;){let c=n[Xe];if(Ik(s,a,c.data)){let p=m8(a,n,e,i,r,u);if(p!==fs)return p}l=n[a+8],l!==up&&Sk(r,n[Xe].data[a+8]===u)&&Ik(s,a,n)?(i=c,a=xy(l),n=by(l,n)):a=-1}}return o}function m8(t,n,e,r,o,s){let i=n[Xe],a=i.data[t+8],l=r==null?$y(a)&&SI:r!=i&&(a.type&3)!==0,u=o&Qe.Host&&s===a,c=ly(a,i,e,l,u);return c!==null?dp(n,i,c,a):fs}function ly(t,n,e,r,o){let s=t.providerIndexes,i=n.data,a=s&1048575,l=t.directiveStart,u=t.directiveEnd,c=s>>20,p=r?a:a+c,f=o?a+c:u;for(let d=p;d<f;d++){let h=i[d];if(d<l&&e===h||d>=l&&h.type===e)return d}if(o){let d=i[l];if(d&&zh(d)&&d.type===e)return l}return null}function dp(t,n,e,r){let o=t[e],s=n.data;if(a8(o)){let i=o;i.resolving&&HK(jK(s[e]));let a=Ck(i.canSeeViewProviders);i.resolving=!0;let l,u=i.injectImpl?co(i.injectImpl):null,c=NA(t,r,Qe.Default);try{o=t[e]=i.factory(void 0,s,t,r),n.firstCreatePass&&e>=r.directiveStart&&s8(e,s[e],n)}finally{u!==null&&co(u),Ck(a),i.resolving=!1,AA()}}return o}function g8(t){if(typeof t=="string")return t.charCodeAt(0)||0;let n=t.hasOwnProperty(kh)?t[kh]:void 0;return typeof n=="number"?n>=0?n&$A:y8:n}function Ik(t,n,e){let r=1<<t;return!!(e[n+(t>>PA)]&r)}function Sk(t,n){return!(t&Qe.Self)&&!(t&Qe.Host&&n)}var xu=class{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return UA(this._tNode,this._lView,n,Oy(r),e)}};function y8(){return new xu(bs(),Ar())}function hS(t){return eS(()=>{let n=t.prototype.constructor,e=n[py]||TI(n),r=Object.prototype,o=Object.getPrototypeOf(t.prototype).constructor;for(;o&&o!==r;){let s=o[py]||TI(o);if(s&&s!==e)return s;o=Object.getPrototypeOf(o)}return s=>new s})}function TI(t){return Gk(t)?()=>{let n=TI(po(t));return n&&n()}:cp(t)}function x8(t,n,e,r,o){let s=t,i=n;for(;s!==null&&i!==null&&i[Ue]&2048&&!(i[Ue]&512);){let a=GA(s,i,e,r|Qe.Self,fs);if(a!==fs)return a;let l=s.parent;if(!l){let u=i[cA];if(u){let c=u.get(e,fs,r);if(c!==fs)return c}l=WA(i),i=i[Bh]}s=l}return o}function WA(t){let n=t[Xe],e=n.type;return e===2?n.declTNode:e===1?t[Go]:null}function Tk(t,n=null,e=null,r){let o=jA(t,n,e,r);return o.resolveInjectorInitializers(),o}function jA(t,n=null,e=null,r,o=new Set){let s=[e||bu,w6(t)];return r=r||(typeof t=="object"?void 0:Xr(t)),new _h(s,n||aS(),r||null,o)}var ti=class t{static{this.THROW_IF_NOT_FOUND=Ah}static{this.NULL=new hy}static create(n,e){if(Array.isArray(n))return Tk({name:""},e,n,"");{let r=n.name??"";return Tk({name:r},n.parent,n.providers,r)}}static{this.\u0275prov=Ge({token:t,providedIn:"any",factory:()=>st(Zk)})}static{this.__NG_ELEMENT_ID__=-1}};var b8=new Be("");b8.__NG_ELEMENT_ID__=t=>{let n=bs();if(n===null)throw new Oe(204,!1);if(n.type&2)return n.value;if(t&Qe.Optional)return null;throw new Oe(204,!1)};var v8="ngOriginalError";function aI(t){return t[v8]}var HA=!0,qA=(()=>{class t{static{this.__NG_ELEMENT_ID__=w8}static{this.__NG_ENV_ID__=e=>e}}return t})(),NI=class extends qA{constructor(n){super(),this._lView=n}onDestroy(n){return bA(this._lView,n),()=>G6(this._lView,n)}};function w8(){return new NI(Ar())}var Eu=(()=>{class t{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new qn(!1)}get _hasPendingTasks(){return this.hasPendingTasks.value}add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);let e=this.taskId++;return this.pendingTasks.add(e),e}remove(e){this.pendingTasks.delete(e),this.pendingTasks.size===0&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}static{this.\u0275prov=Ge({token:t,providedIn:"root",factory:()=>new t})}}return t})();var EI=class extends gr{constructor(n=!1){super(),this.destroyRef=void 0,this.pendingTasks=void 0,this.__isAsync=n,_6()&&(this.destroyRef=ue(qA,{optional:!0})??void 0,this.pendingTasks=ue(Eu,{optional:!0})??void 0)}emit(n){let e=Et(null);try{super.next(n)}finally{Et(e)}}subscribe(n,e,r){let o=n,s=e||(()=>null),i=r;if(n&&typeof n=="object"){let l=n;o=l.next?.bind(l),s=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return n instanceof gn&&n.add(a),a}wrapInTimeout(n){return e=>{let r=this.pendingTasks?.add();setTimeout(()=>{n(e),r!==void 0&&this.pendingTasks?.remove(r)})}}},nr=EI;function vy(...t){}function KA(t){let n,e;function r(){t=vy;try{e!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(e),n!==void 0&&clearTimeout(n)}catch{}}return n=setTimeout(()=>{t(),r()}),typeof requestAnimationFrame=="function"&&(e=requestAnimationFrame(()=>{t(),r()})),()=>r()}function Nk(t){return queueMicrotask(()=>t()),()=>{t=vy}}var mS="isAngularZone",wy=mS+"_ID",C8=0,dn=class t{constructor(n){this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new nr(!1),this.onMicrotaskEmpty=new nr(!1),this.onStable=new nr(!1),this.onError=new nr(!1);let{enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:o=!1,scheduleInRootZone:s=HA}=n;if(typeof Zone>"u")throw new Oe(908,!1);Zone.assertZonePatched();let i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!o&&r,i.shouldCoalesceRunChangeDetection=o,i.callbackScheduled=!1,i.scheduleInRootZone=s,T8(i)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(mS)===!0}static assertInAngularZone(){if(!t.isInAngularZone())throw new Oe(909,!1)}static assertNotInAngularZone(){if(t.isInAngularZone())throw new Oe(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,n,I8,vy,vy);try{return s.runTask(i,e,r)}finally{s.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}},I8={};function gS(t){if(t._nesting==0&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function S8(t){if(t.isCheckStableRunning||t.callbackScheduled)return;t.callbackScheduled=!0;function n(){KA(()=>{t.callbackScheduled=!1,DI(t),t.isCheckStableRunning=!0,gS(t),t.isCheckStableRunning=!1})}t.scheduleInRootZone?Zone.root.run(()=>{n()}):t._outer.run(()=>{n()}),DI(t)}function T8(t){let n=()=>{S8(t)},e=C8++;t._inner=t._inner.fork({name:"angular",properties:{[mS]:!0,[wy]:e,[wy+e]:!0},onInvokeTask:(r,o,s,i,a,l)=>{if(N8(l))return r.invokeTask(s,i,a,l);try{return Ek(t),r.invokeTask(s,i,a,l)}finally{(t.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||t.shouldCoalesceRunChangeDetection)&&n(),Dk(t)}},onInvoke:(r,o,s,i,a,l,u)=>{try{return Ek(t),r.invoke(s,i,a,l,u)}finally{t.shouldCoalesceRunChangeDetection&&!t.callbackScheduled&&!E8(l)&&n(),Dk(t)}},onHasTask:(r,o,s,i)=>{r.hasTask(s,i),o===s&&(i.change=="microTask"?(t._hasPendingMicrotasks=i.microTask,DI(t),gS(t)):i.change=="macroTask"&&(t.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,o,s,i)=>(r.handleError(s,i),t.runOutsideAngular(()=>t.onError.emit(i)),!1)})}function DI(t){t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&t.callbackScheduled===!0?t.hasPendingMicrotasks=!0:t.hasPendingMicrotasks=!1}function Ek(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Dk(t){t._nesting--,gS(t)}var kI=class{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new nr,this.onMicrotaskEmpty=new nr,this.onStable=new nr,this.onError=new nr}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,o){return n.apply(e,r)}};function N8(t){return XA(t,"__ignore_ng_zone__")}function E8(t){return XA(t,"__scheduler_tick__")}function XA(t,n){return!Array.isArray(t)||t.length!==1?!1:t[0]?.data?.[n]===!0}var ni=class{constructor(){this._console=console}handleError(n){let e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&aI(n);for(;e&&aI(e);)e=aI(e);return e||null}},D8=new Be("",{providedIn:"root",factory:()=>{let t=ue(dn),n=ue(ni);return e=>t.runOutsideAngular(()=>n.handleError(e))}});function k8(){return bp(bs(),Ar())}function bp(t,n){return new Du(xs(t,n))}var Du=(()=>{class t{constructor(e){this.nativeElement=e}static{this.__NG_ELEMENT_ID__=k8}}return t})();function A8(t){return t instanceof Du?t.nativeElement:t}function R8(){return this._results[Symbol.iterator]()}var AI=class t{get changes(){return this._changes??=new nr}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._onDirty=void 0,this._results=[],this._changesDetected=!1,this._changes=void 0,this.length=0,this.first=void 0,this.last=void 0;let e=t.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=R8)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){this.dirty=!1;let r=o6(n);(this._changesDetected=!r6(this._results,r,e))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}onDirty(n){this._onDirty=n}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}},_8="ngSkipHydration",O8="ngskiphydration";function YA(t){let n=t.mergedAttrs;if(n===null)return!1;for(let e=0;e<n.length;e+=2){let r=n[e];if(typeof r=="number")return!1;if(typeof r=="string"&&r.toLowerCase()===O8)return!0}return!1}function ZA(t){return t.hasAttribute(_8)}function Cy(t){return(t.flags&128)===128}function F8(t){if(Cy(t))return!0;let n=t.parent;for(;n;){if(Cy(t)||YA(n))return!0;n=n.parent}return!1}var QA=new Map,M8=0;function $8(){return M8++}function P8(t){QA.set(t[My],t)}function RI(t){QA.delete(t[My])}var kk="__ngContext__";function hp(t,n){ds(n)?(t[kk]=n[My],P8(n)):t[kk]=n}function JA(t){return tR(t[Oh])}function eR(t){return tR(t[Uo])}function tR(t){for(;t!==null&&!ys(t);)t=t[Uo];return t}var _I;function nR(t){_I=t}function Vy(){if(_I!==void 0)return _I;if(typeof document<"u")return document;throw new Oe(210,!1)}var Uy=new Be("",{providedIn:"root",factory:()=>L8}),L8="ng",yS=new Be(""),vs=new Be("",{providedIn:"platform",factory:()=>"unknown"});var xS=new Be("",{providedIn:"root",factory:()=>Vy().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});function B8(){let t=new vp;return ue(vs)==="browser"&&(t.store=z8(Vy(),ue(Uy))),t}var vp=(()=>{class t{constructor(){this.store={},this.onSerializeCallbacks={}}static{this.\u0275prov=Ge({token:t,providedIn:"root",factory:B8})}get(e,r){return this.store[e]!==void 0?this.store[e]:r}set(e,r){this.store[e]=r}remove(e){delete this.store[e]}hasKey(e){return this.store.hasOwnProperty(e)}get isEmpty(){return Object.keys(this.store).length===0}onSerialize(e,r){this.onSerializeCallbacks[e]=r}toJson(){for(let e in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(e))try{this.store[e]=this.onSerializeCallbacks[e]()}catch(r){console.warn("Exception in onSerialize callback: ",r)}return JSON.stringify(this.store).replace(/</g,"\\u003C")}}return t})();function z8(t,n){let e=t.getElementById(n+"-state");if(e?.textContent)try{return JSON.parse(e.textContent)}catch(r){console.warn("Exception while restoring TransferState for app "+n,r)}return{}}var rR="h",oR="b",OI=function(t){return t.FirstChild="f",t.NextSibling="n",t}(OI||{}),V8="e",U8="t",bS="c",sR="x",Iy="r",G8="i",W8="n",iR="d";var j8="__nghData__",aR=j8,lI="ngh",H8="nghm",lR=()=>null;function q8(t,n,e=!1){let r=t.getAttribute(lI);if(r==null)return null;let[o,s]=r.split("|");if(r=e?s:o,!r)return null;let i=s?`|${s}`:"",a=e?o:i,l={};if(r!==""){let c=n.get(vp,null,{optional:!0});c!==null&&(l=c.get(aR,[])[Number(r)])}let u={data:l,firstChild:t.firstChild??null};return e&&(u.firstChild=t,Gy(u,0,t.nextSibling)),a?t.setAttribute(lI,a):t.removeAttribute(lI),u}function K8(){lR=q8}function vS(t,n,e=!1){return lR(t,n,e)}function X8(t){let n=t._lView;return n[Xe].type===2?null:(yy(n)&&(n=n[go]),n)}function Y8(t){return t.textContent?.replace(/\s/gm,"")}function Z8(t){let n=Vy(),e=n.createNodeIterator(t,NodeFilter.SHOW_COMMENT,{acceptNode(s){let i=Y8(s);return i==="ngetn"||i==="ngtns"?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_REJECT}}),r,o=[];for(;r=e.nextNode();)o.push(r);for(let s of o)s.textContent==="ngetn"?s.replaceWith(n.createTextNode("")):s.remove()}function Gy(t,n,e){t.segmentHeads??={},t.segmentHeads[n]=e}function FI(t,n){return t.segmentHeads?.[n]??null}function Q8(t,n){let e=t.data,r=e[V8]?.[n]??null;return r===null&&e[bS]?.[n]&&(r=wS(t,n)),r}function uR(t,n){return t.data[bS]?.[n]??null}function wS(t,n){let e=uR(t,n)??[],r=0;for(let o of e)r+=o[Iy]*(o[sR]??1);return r}function J8(t){if(typeof t.disconnectedNodes>"u"){let n=t.data[iR];t.disconnectedNodes=n?new Set(n):null}return t.disconnectedNodes}function Gh(t,n){if(typeof t.disconnectedNodes>"u"){let e=t.data[iR];t.disconnectedNodes=e?new Set(e):null}return!!J8(t)?.has(n)}var ty=new Be(""),cR=!1,pR=new Be("",{providedIn:"root",factory:()=>cR});var e5=/^>|^->|<!--|-->|--!>|<!-$/g,t5=/(<|>)/g,n5="\u200B$1\u200B";function r5(t){return t.replace(e5,n=>n.replace(t5,n5))}function o5(t){return t.ownerDocument.body}function fR(t){return t instanceof Function?t():t}function ny(t){return(t??ue(ti)).get(vs)==="browser"}var ku=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}(ku||{}),s5;function CS(t,n){return s5(t,n)}function ap(t,n,e,r,o){if(r!=null){let s,i=!1;ys(r)?s=r:ds(r)&&(i=!0,r=r[Yr]);let a=ei(r);t===0&&e!==null?o==null?xR(n,e,a):Sy(n,e,a,o||null,!0):t===1&&e!==null?Sy(n,e,a,o||null,!0):t===2?TS(n,a,i):t===3&&n.destroyNode(a),s!=null&&v5(n,t,s,e,o)}}function dR(t,n){return t.createText(n)}function hR(t,n){return t.createComment(r5(n))}function IS(t,n,e){return t.createElement(n,e)}function i5(t,n){mR(t,n),n[Yr]=null,n[Go]=null}function a5(t,n,e,r,o,s){r[Yr]=o,r[Go]=n,Wy(t,r,e,1,o,s)}function mR(t,n){n[Zs].changeDetectionScheduler?.notify(9),Wy(t,n,n[rr],2,null,null)}function l5(t){let n=t[Oh];if(!n)return uI(t[Xe],t);for(;n;){let e=null;if(ds(n))e=n[Oh];else{let r=n[kr];r&&(e=r)}if(!e){for(;n&&!n[Uo]&&n!==t;)ds(n)&&uI(n[Xe],n),n=n[Kn];n===null&&(n=t),ds(n)&&uI(n[Xe],n),e=n&&n[Uo]}n=e}}function u5(t,n,e,r){let o=kr+r,s=e.length;r>0&&(e[o-1][Uo]=n),r<s-kr?(n[Uo]=e[o],Yk(e,kr+r,n)):(e.push(n),n[Uo]=null),n[Kn]=e;let i=n[Cu];i!==null&&e!==i&&gR(i,n);let a=n[Qs];a!==null&&a.insertView(t),wI(n),n[Ue]|=128}function gR(t,n){let e=t[fp],r=n[Kn];if(ds(r))t[Ue]|=gy.HasTransplantedViews;else{let o=r[Kn][mo];n[mo]!==o&&(t[Ue]|=gy.HasTransplantedViews)}e===null?t[fp]=[n]:e.push(n)}function SS(t,n){let e=t[fp],r=e.indexOf(n);e.splice(r,1)}function MI(t,n){if(t.length<=kr)return;let e=kr+n,r=t[e];if(r){let o=r[Cu];o!==null&&o!==t&&SS(o,r),n>0&&(t[e-1][Uo]=r[Uo]);let s=dy(t,kr+n);i5(r[Xe],r);let i=s[Qs];i!==null&&i.detachView(s[Xe]),r[Kn]=null,r[Uo]=null,r[Ue]&=-129}return r}function yR(t,n){if(!(n[Ue]&256)){let e=n[rr];e.destroyNode&&Wy(t,n,e,3,null,null),l5(n)}}function uI(t,n){if(n[Ue]&256)return;let e=Et(null);try{n[Ue]&=-129,n[Ue]|=256,n[fo]&&$0(n[fo]),p5(t,n),c5(t,n),n[Xe].type===1&&n[rr].destroy();let r=n[Cu];if(r!==null&&ys(n[Kn])){r!==n[Kn]&&SS(r,n);let o=n[Qs];o!==null&&o.detachView(t)}RI(n)}finally{Et(e)}}function c5(t,n){let e=t.cleanup,r=n[bI];if(e!==null)for(let s=0;s<e.length-1;s+=2)if(typeof e[s]=="string"){let i=e[s+3];i>=0?r[i]():r[-i].unsubscribe(),s+=2}else{let i=r[e[s+1]];e[s].call(i)}r!==null&&(n[bI]=null);let o=n[Aa];if(o!==null){n[Aa]=null;for(let s=0;s<o.length;s++){let i=o[s];i()}}}function p5(t,n){let e;if(t!=null&&(e=t.destroyHooks)!=null)for(let r=0;r<e.length;r+=2){let o=n[e[r]];if(!(o instanceof Mh)){let s=e[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],l=s[i+1];ka(4,a,l);try{l.call(a)}finally{ka(5,a,l)}}else{ka(4,o,s);try{s.call(o)}finally{ka(5,o,s)}}}}}function f5(t,n,e){return d5(t,n.parent,e)}function d5(t,n,e){let r=n;for(;r!==null&&r.type&168;)n=r,r=n.parent;if(r===null)return e[Yr];{let{componentOffset:o}=r;if(o>-1){let{encapsulation:s}=t.data[r.directiveStart+o];if(s===hs.None||s===hs.Emulated)return null}return xs(r,e)}}function Sy(t,n,e,r,o){t.insertBefore(n,e,r,o)}function xR(t,n,e){t.appendChild(n,e)}function Ak(t,n,e,r,o){r!==null?Sy(t,n,e,r,o):xR(t,n,e)}function bR(t,n){return t.parentNode(n)}function h5(t,n){return t.nextSibling(n)}function m5(t,n,e){return y5(t,n,e)}function g5(t,n,e){return t.type&40?xs(t,e):null}var y5=g5,Rk;function x5(t,n,e,r){let o=f5(t,r,n),s=n[rr],i=r.parent||n[Go],a=m5(i,r,n);if(o!=null)if(Array.isArray(e))for(let l=0;l<e.length;l++)Ak(s,o,e[l],a,!1);else Ak(s,o,e,a,!1);Rk!==void 0&&Rk(s,r,n,e,o)}function Eh(t,n){if(n!==null){let e=n.type;if(e&3)return xs(n,t);if(e&4)return $I(-1,t[n.index]);if(e&8){let r=n.child;if(r!==null)return Eh(t,r);{let o=t[n.index];return ys(o)?$I(-1,o):ei(o)}}else{if(e&128)return Eh(t,n.next);if(e&32)return CS(n,t)()||ei(t[n.index]);{let r=vR(t,n);if(r!==null){if(Array.isArray(r))return r[0];let o=Iu(t[mo]);return Eh(o,r)}else return Eh(t,n.next)}}}return null}function vR(t,n){if(n!==null){let r=t[mo][Go],o=n.projection;return r.projection[o]}return null}function $I(t,n){let e=kr+t+1;if(e<n.length){let r=n[e],o=r[Xe].firstChild;if(o!==null)return Eh(r,o)}return n[Js]}function TS(t,n,e){t.removeChild(null,n,e)}function wR(t){t.textContent=""}function NS(t,n,e,r,o,s,i){for(;e!=null;){if(e.type===128){e=e.next;continue}let a=r[e.index],l=e.type;if(i&&n===0&&(a&&hp(ei(a),r),e.flags|=2),(e.flags&32)!==32)if(l&8)NS(t,n,e.child,r,o,s,!1),ap(n,t,o,a,s);else if(l&32){let u=CS(e,r),c;for(;c=u();)ap(n,t,o,c,s);ap(n,t,o,a,s)}else l&16?b5(t,n,r,e,o,s):ap(n,t,o,a,s);e=i?e.projectionNext:e.next}}function Wy(t,n,e,r,o,s){NS(e,r,t.firstChild,n,o,s,!1)}function b5(t,n,e,r,o,s){let i=e[mo],l=i[Go].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++){let c=l[u];ap(n,t,o,c,s)}else{let u=l,c=i[Kn];Cy(r)&&(u.flags|=128),NS(t,n,u,c,o,s,!0)}}function v5(t,n,e,r,o){let s=e[Js],i=ei(e);s!==i&&ap(n,t,r,s,o);for(let a=kr;a<e.length;a++){let l=e[a];Wy(l[Xe],l,t,n,r,s)}}function w5(t,n,e){t.setAttribute(n,"style",e)}function CR(t,n,e){e===""?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function IR(t,n,e){let{mergedAttrs:r,classes:o,styles:s}=e;r!==null&&hI(t,n,r),o!==null&&CR(t,n,o),s!==null&&w5(t,n,s)}var SR={};function C5(t,n,e,r){if(!r)if((n[Ue]&3)===3){let s=t.preOrderCheckHooks;s!==null&&iy(n,s,e)}else{let s=t.preOrderHooks;s!==null&&ay(n,s,0,e)}Su(e)}function ES(t,n=Qe.Default){let e=Ar();if(e===null)return st(t,n);let r=bs();return UA(r,e,po(t),n)}function TR(t,n,e,r,o,s){let i=Et(null);try{let a=null;o&Ra.SignalBased&&(a=n[r][k1]),a!==null&&a.transformFn!==void 0&&(s=a.transformFn(s)),o&Ra.HasDecoratorInputTransform&&(s=t.inputTransforms[r].call(n,s)),t.setInput!==null?t.setInput(n,a,s,e,r):dA(n,a,r,s)}finally{Et(i)}}function I5(t,n){let e=t.hostBindingOpCodes;if(e!==null)try{for(let r=0;r<e.length;r++){let o=e[r];if(o<0)Su(~o);else{let s=o,i=e[++r],a=e[++r];e8(i,s);let l=n[s];a(2,l)}}}finally{Su(-1)}}function jy(t,n,e,r,o,s,i,a,l,u,c){let p=n.blueprint.slice();return p[Yr]=o,p[Ue]=r|4|128|8|64,(u!==null||t&&t[Ue]&2048)&&(p[Ue]|=2048),yA(p),p[Kn]=p[Bh]=t,p[_a]=e,p[Zs]=i||t&&t[Zs],p[rr]=a||t&&t[rr],p[pp]=l||t&&t[pp]||null,p[Go]=s,p[My]=$8(),p[ms]=c,p[cA]=u,p[mo]=n.type==2?t[mo]:p,p}function NR(t,n,e,r,o){let s=t.data[n];if(s===null)s=S5(t,n,e,r,o),J6()&&(s.flags|=32);else if(s.type&64){s.type=e,s.value=r,s.attrs=o;let i=Y6();s.injectorIndex=i===null?-1:i.injectorIndex}return uS(s,!0),s}function S5(t,n,e,r,o){let s=CA(),i=IA(),a=i?s:s&&s.parent,l=t.data[n]=O5(t,a,e,n,r,o);return t.firstChild===null&&(t.firstChild=l),s!==null&&(i?s.child==null&&l.parent!==null&&(s.child=l):s.next===null&&(s.next=l,l.prev=s)),l}function ER(t,n,e,r){if(e===0)return-1;let o=n.length;for(let s=0;s<e;s++)n.push(r),t.blueprint.push(r),t.data.push(null);return o}function DR(t,n,e,r,o){let s=r8(),i=r&2;try{Su(-1),i&&n.length>go&&C5(t,n,go,!1),ka(i?2:0,o),e(r,o)}finally{Su(s),ka(i?3:1,o)}}function kR(t,n,e){if(fA(n)){let r=Et(null);try{let o=n.directiveStart,s=n.directiveEnd;for(let i=o;i<s;i++){let a=t.data[i];if(a.contentQueries){let l=e[i];a.contentQueries(1,l,i)}}}finally{Et(r)}}}function T5(t,n,e){wA()&&(L5(t,n,e,xs(e,n)),(e.flags&64)===64&&FR(t,n,e))}function N5(t,n,e=xs){let r=n.localNames;if(r!==null){let o=n.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?e(n,t):t[i];t[o++]=a}}}function AR(t){let n=t.tView;return n===null||n.incompleteFirstPass?t.tView=RR(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts,t.id):n}function RR(t,n,e,r,o,s,i,a,l,u,c){let p=go+r,f=p+o,d=E5(p,f),h=typeof u=="function"?u():u;return d[Xe]={type:t,blueprint:d,template:e,queries:null,viewQuery:a,declTNode:n,data:d.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:f,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:l,consts:h,incompleteFirstPass:!1,ssrId:c}}function E5(t,n){let e=[];for(let r=0;r<n;r++)e.push(r<t?null:SR);return e}function D5(t,n,e,r){let s=r.get(pR,cR)||e===hs.ShadowDom,i=t.selectRootElement(n,s);return k5(i),i}function k5(t){_R(t)}var _R=()=>null;function A5(t){ZA(t)?wR(t):Z8(t)}function R5(){_R=A5}function _5(t,n,e,r){let o=X5(n);o.push(e),t.firstCreatePass&&Y5(t).push(r,o.length-1)}function O5(t,n,e,r,o,s){let i=n?n.injectorIndex:-1,a=0;return Uh()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function _k(t,n,e,r,o){for(let s in n){if(!n.hasOwnProperty(s))continue;let i=n[s];if(i===void 0)continue;r??={};let a,l=Ra.None;Array.isArray(i)?(a=i[0],l=i[1]):a=i;let u=s;if(o!==null){if(!o.hasOwnProperty(s))continue;u=o[s]}t===0?Ok(r,e,u,a,l):Ok(r,e,u,a)}return r}function Ok(t,n,e,r,o){let s;t.hasOwnProperty(e)?(s=t[e]).push(n,r):s=t[e]=[n,r],o!==void 0&&s.push(o)}function F5(t,n,e){let r=n.directiveStart,o=n.directiveEnd,s=t.data,i=n.attrs,a=[],l=null,u=null;for(let c=r;c<o;c++){let p=s[c],f=e?e.get(p):null,d=f?f.inputs:null,h=f?f.outputs:null;l=_k(0,p.inputs,c,l,d),u=_k(1,p.outputs,c,u,h);let g=l!==null&&i!==null&&!oS(n)?q5(l,c,i):null;a.push(g)}l!==null&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}function M5(t,n,e,r){if(wA()){let o=r===null?null:{"":-1},s=z5(t,e),i,a;s===null?i=a=null:[i,a]=s,i!==null&&OR(t,n,e,i,o,a),o&&V5(e,r,o)}e.mergedAttrs=rS(e.mergedAttrs,e.attrs)}function OR(t,n,e,r,o,s){for(let u=0;u<r.length;u++)h8(LA(e,n),t,r[u].type);G5(e,t.data.length,r.length);for(let u=0;u<r.length;u++){let c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=ER(t,n,r.length,null);for(let u=0;u<r.length;u++){let c=r[u];e.mergedAttrs=rS(e.mergedAttrs,c.hostAttrs),W5(t,e,n,l,c),U5(l,c,o),c.contentQueries!==null&&(e.flags|=4),(c.hostBindings!==null||c.hostAttrs!==null||c.hostVars!==0)&&(e.flags|=64);let p=c.type.prototype;!i&&(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&&((t.preOrderHooks??=[]).push(e.index),i=!0),!a&&(p.ngOnChanges||p.ngDoCheck)&&((t.preOrderCheckHooks??=[]).push(e.index),a=!0),l++}F5(t,e,s)}function $5(t,n,e,r,o){let s=o.hostBindings;if(s){let i=t.hostBindingOpCodes;i===null&&(i=t.hostBindingOpCodes=[]);let a=~n.index;P5(i)!=a&&i.push(a),i.push(e,r,s)}}function P5(t){let n=t.length;for(;n>0;){let e=t[--n];if(typeof e=="number"&&e<0)return e}return 0}function L5(t,n,e,r){let o=e.directiveStart,s=e.directiveEnd;$y(e)&&j5(n,e,t.data[o+e.componentOffset]),t.firstCreatePass||LA(e,n),hp(r,n);let i=e.initialInputs;for(let a=o;a<s;a++){let l=t.data[a],u=dp(n,t,a,e);if(hp(u,n),i!==null&&H5(n,a-o,u,l,e,i),zh(l)){let c=Vh(e.index,n);c[_a]=dp(n,t,a,e)}}}function FR(t,n,e){let r=e.directiveStart,o=e.directiveEnd,s=e.index,i=t8();try{Su(s);for(let a=r;a<o;a++){let l=t.data[a],u=n[a];CI(a),(l.hostBindings!==null||l.hostVars!==0||l.hostAttrs!==null)&&B5(l,u)}}finally{Su(-1),CI(i)}}function B5(t,n){t.hostBindings!==null&&t.hostBindings(1,n)}function z5(t,n){let e=t.directiveRegistry,r=null,o=null;if(e)for(let s=0;s<e.length;s++){let i=e[s];if(f6(n,i.selectors,!1))if(r||(r=[]),zh(i))if(i.findHostDirectiveDefs!==null){let a=[];o=o||new Map,i.findHostDirectiveDefs(i,a,o),r.unshift(...a,i);let l=a.length;PI(t,n,l)}else r.unshift(i),PI(t,n,0);else o=o||new Map,i.findHostDirectiveDefs?.(i,r,o),r.push(i)}return r===null?null:[r,o]}function PI(t,n,e){n.componentOffset=e,(t.components??=[]).push(n.index)}function V5(t,n,e){if(n){let r=t.localNames=[];for(let o=0;o<n.length;o+=2){let s=e[n[o+1]];if(s==null)throw new Oe(-301,!1);r.push(n[o],s)}}}function U5(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;zh(n)&&(e[""]=t)}}function G5(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}function W5(t,n,e,r,o){t.data[r]=o;let s=o.factory||(o.factory=cp(o.type,!0)),i=new Mh(s,zh(o),ES);t.blueprint[r]=i,e[r]=i,$5(t,n,r,ER(t,e,o.hostVars,SR),o)}function j5(t,n,e){let r=xs(n,t),o=AR(e),s=t[Zs].rendererFactory,i=16;e.signals?i=4096:e.onPush&&(i=64);let a=DS(t,jy(t,o,null,i,r,n,null,s.createRenderer(r,e),null,null,null));t[n.index]=a}function H5(t,n,e,r,o,s){let i=s[n];if(i!==null)for(let a=0;a<i.length;){let l=i[a++],u=i[a++],c=i[a++],p=i[a++];TR(r,e,l,u,c,p)}}function q5(t,n,e){let r=null,o=0;for(;o<e.length;){let s=e[o];if(s===0){o+=4;continue}else if(s===5){o+=2;continue}if(typeof s=="number")break;if(t.hasOwnProperty(s)){r===null&&(r=[]);let i=t[s];for(let a=0;a<i.length;a+=3)if(i[a]===n){r.push(s,i[a+1],i[a+2],e[o+1]);break}}o+=2}return r}function K5(t,n,e,r){return[t,!0,0,n,null,r,null,e,null,null]}function MR(t,n){let e=t.contentQueries;if(e!==null){let r=Et(null);try{for(let o=0;o<e.length;o+=2){let s=e[o],i=e[o+1];if(i!==-1){let a=t.data[i];cS(s),a.contentQueries(2,n[i],i)}}}finally{Et(r)}}}function DS(t,n){return t[Oh]?t[yk][Uo]=n:t[Oh]=n,t[yk]=n,n}function LI(t,n,e){cS(0);let r=Et(null);try{n(t,e)}finally{Et(r)}}function X5(t){return t[bI]??=[]}function Y5(t){return t.cleanup??=[]}function Z5(t,n){let e=t[pp],r=e?e.get(ni,null):null;r&&r.handleError(n)}function $R(t,n,e,r,o){for(let s=0;s<e.length;){let i=e[s++],a=e[s++],l=e[s++],u=n[i],c=t.data[i];TR(c,u,r,a,l,o)}}function Q5(t,n){let e=Vh(n,t),r=e[Xe];J5(r,e);let o=e[Yr];o!==null&&e[ms]===null&&(e[ms]=vS(o,e[pp])),kS(r,e,e[_a])}function J5(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])}function kS(t,n,e){pS(n);try{let r=t.viewQuery;r!==null&&LI(1,r,e);let o=t.template;o!==null&&DR(t,n,o,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),n[Qs]?.finishViewCreation(t),t.staticContentQueries&&MR(t,n),t.staticViewQueries&&LI(2,t.viewQuery,e);let s=t.components;s!==null&&eX(n,s)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[Ue]&=-5,fS()}}function eX(t,n){for(let e=0;e<n.length;e++)Q5(t,n[e])}function tX(t,n,e,r){let o=Et(null);try{let s=n.tView,a=t[Ue]&4096?4096:16,l=jy(t,s,e,a,null,n,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),u=t[n.index];l[Cu]=u;let c=t[Qs];return c!==null&&(l[Qs]=c.createEmbeddedView(s)),kS(s,l,e),l}finally{Et(o)}}function Fk(t,n){return!n||n.firstChild===null||Cy(t)}function nX(t,n,e,r=!0){let o=n[Xe];if(u5(o,n,t,e),r){let i=$I(e,t),a=n[rr],l=bR(a,t[Js]);l!==null&&a5(o,t[Go],a,n,l,i)}let s=n[ms];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function Ty(t,n,e,r,o=!1){for(;e!==null;){if(e.type===128){e=o?e.projectionNext:e.next;continue}let s=n[e.index];s!==null&&r.push(ei(s)),ys(s)&&rX(s,r);let i=e.type;if(i&8)Ty(t,n,e.child,r);else if(i&32){let a=CS(e,n),l;for(;l=a();)r.push(l)}else if(i&16){let a=vR(n,e);if(Array.isArray(a))r.push(...a);else{let l=Iu(n[mo]);Ty(l[Xe],l,a,r,!0)}}e=o?e.projectionNext:e.next}return r}function rX(t,n){for(let e=kr;e<t.length;e++){let r=t[e],o=r[Xe].firstChild;o!==null&&Ty(r[Xe],r,o,n)}t[Js]!==t[Yr]&&n.push(t[Js])}var PR=[];function oX(t){return t[fo]??sX(t)}function sX(t){let n=PR.pop()??Object.create(aX);return n.lView=t,n}function iX(t){t.lView[fo]!==t&&(t.lView=null,PR.push(t))}var aX=an(Se({},O0),{consumerIsAlwaysLive:!0,consumerMarkedDirty:t=>{By(t.lView)},consumerOnSignalRead(){this.lView[fo]=this}});function lX(t){let n=t[fo]??Object.create(uX);return n.lView=t,n}var uX=an(Se({},O0),{consumerIsAlwaysLive:!0,consumerMarkedDirty:t=>{let n=Iu(t.lView);for(;n&&!LR(n[Xe]);)n=Iu(n);n&&xA(n)},consumerOnSignalRead(){this.lView[fo]=this}});function LR(t){return t.type!==2}var cX=100;function BR(t,n=!0,e=0){let r=t[Zs],o=r.rendererFactory,s=!1;s||o.begin?.();try{pX(t,e)}catch(i){throw n&&Z5(t,i),i}finally{s||(o.end?.(),r.inlineEffectRunner?.flush())}}function pX(t,n){let e=SA();try{vk(!0),BI(t,n);let r=0;for(;Ly(t);){if(r===cX)throw new Oe(103,!1);r++,BI(t,1)}}finally{vk(e)}}function fX(t,n,e,r){let o=n[Ue];if((o&256)===256)return;let s=!1,i=!1;!s&&n[Zs].inlineEffectRunner?.flush(),pS(n);let a=!0,l=null,u=null;s||(LR(t)?(u=oX(n),l=F0(u)):A1()===null?(a=!1,u=lX(n),l=F0(u)):n[fo]&&($0(n[fo]),n[fo]=null));try{yA(n),Q6(t.bindingStartIndex),e!==null&&DR(t,n,e,2,r);let c=(o&3)===3;if(!s)if(c){let d=t.preOrderCheckHooks;d!==null&&iy(n,d,null)}else{let d=t.preOrderHooks;d!==null&&ay(n,d,0,null),oI(n,0)}if(i||dX(n),zR(n,0),t.contentQueries!==null&&MR(t,n),!s)if(c){let d=t.contentCheckHooks;d!==null&&iy(n,d)}else{let d=t.contentHooks;d!==null&&ay(n,d,1),oI(n,1)}I5(t,n);let p=t.components;p!==null&&UR(n,p,0);let f=t.viewQuery;if(f!==null&&LI(2,f,r),!s)if(c){let d=t.viewCheckHooks;d!==null&&iy(n,d)}else{let d=t.viewHooks;d!==null&&ay(n,d,2),oI(n,2)}if(t.firstUpdatePass===!0&&(t.firstUpdatePass=!1),n[rI]){for(let d of n[rI])d();n[rI]=null}s||(n[Ue]&=-73)}catch(c){throw s||By(n),c}finally{u!==null&&(R1(u,l),a&&iX(u)),fS()}}function zR(t,n){for(let e=JA(t);e!==null;e=eR(e))for(let r=kr;r<e.length;r++){let o=e[r];VR(o,n)}}function dX(t){for(let n=JA(t);n!==null;n=eR(n)){if(!(n[Ue]&gy.HasTransplantedViews))continue;let e=n[fp];for(let r=0;r<e.length;r++){let o=e[r];xA(o)}}}function hX(t,n,e){let r=Vh(n,t);VR(r,e)}function VR(t,n){lS(t)&&BI(t,n)}function BI(t,n){let r=t[Xe],o=t[Ue],s=t[fo],i=!!(n===0&&o&16);if(i||=!!(o&64&&n===0),i||=!!(o&1024),i||=!!(s?.dirty&&M0(s)),i||=!1,s&&(s.dirty=!1),t[Ue]&=-9217,i)fX(r,t,r.template,t[_a]);else if(o&8192){zR(t,1);let a=r.components;a!==null&&UR(t,a,1)}}function UR(t,n,e){for(let r=0;r<n.length;r++)hX(t,n[r],e)}function GR(t,n){let e=SA()?64:1088;for(t[Zs].changeDetectionScheduler?.notify(n);t;){t[Ue]|=e;let r=Iu(t);if(yy(t)&&!r)return t;t=r}return null}var Tu=class{get rootNodes(){let n=this._lView,e=n[Xe];return Ty(e,n,e.firstChild,[])}constructor(n,e,r=!0){this._lView=n,this._cdRefInjectingView=e,this.notifyErrorHandler=r,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[_a]}set context(n){this._lView[_a]=n}get destroyed(){return(this._lView[Ue]&256)===256}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let n=this._lView[Kn];if(ys(n)){let e=n[my],r=e?e.indexOf(this):-1;r>-1&&(MI(n,r),dy(e,r))}this._attachedToViewContainer=!1}yR(this._lView[Xe],this._lView)}onDestroy(n){bA(this._lView,n)}markForCheck(){GR(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[Ue]&=-129}reattach(){wI(this._lView),this._lView[Ue]|=128}detectChanges(){this._lView[Ue]|=1024,BR(this._lView,this.notifyErrorHandler)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Oe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let n=yy(this._lView),e=this._lView[Cu];e!==null&&!n&&SS(e,this._lView),mR(this._lView[Xe],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new Oe(902,!1);this._appRef=n;let e=yy(this._lView),r=this._lView[Cu];r!==null&&!e&&gR(r,this._lView),wI(this._lView)}},$h=(()=>{class t{static{this.__NG_ELEMENT_ID__=yX}}return t})(),mX=$h,gX=class extends mX{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(n,e){return this.createEmbeddedViewImpl(n,e)}createEmbeddedViewImpl(n,e,r){let o=tX(this._declarationLView,this._declarationTContainer,n,{embeddedViewInjector:e,dehydratedView:r});return new Tu(o)}};function yX(){return AS(bs(),Ar())}function AS(t,n){return t.type&4?new gX(n,t,bp(t,n)):null}var xX=new RegExp(`^(\\d+)*(${oR}|${rR})*(.*)`);function bX(t){let n=t.match(xX),[e,r,o,s]=n,i=r?parseInt(r,10):o,a=[];for(let[l,u,c]of s.matchAll(/(f|n)(\d*)/g)){let p=parseInt(c,10)||1;a.push(u,p)}return[i,...a]}function vX(t){return!t.prev&&t.parent?.type===8}function cI(t){return t.index-go}function wX(t,n){let e=t.i18nNodes;if(e)return e.get(n)}function Hy(t,n,e,r){let o=cI(r),s=wX(t,o);if(s===void 0){let i=t.data[W8];if(i?.[o])s=IX(i[o],e);else if(n.firstChild===r)s=t.firstChild;else{let a=r.prev===null,l=r.prev??r.parent;if(vX(r)){let u=cI(r.parent);s=FI(t,u)}else{let u=xs(l,e);if(a)s=u.firstChild;else{let c=cI(l),p=FI(t,c);if(l.type===2&&p){let d=wS(t,c)+1;s=qy(d,p)}else s=u.nextSibling}}}}return s}function qy(t,n){let e=n;for(let r=0;r<t;r++)e=e.nextSibling;return e}function CX(t,n){let e=t;for(let r=0;r<n.length;r+=2){let o=n[r],s=n[r+1];for(let i=0;i<s;i++)switch(o){case OI.FirstChild:e=e.firstChild;break;case OI.NextSibling:e=e.nextSibling;break}}return e}function IX(t,n){let[e,...r]=bX(t),o;if(e===rR)o=n[mo][Yr];else if(e===oR)o=o5(n[mo][Yr]);else{let s=Number(e);o=ei(n[s+go])}return CX(o,r)}var SX=!1;function TX(t){SX=t}function NX(t){let n=t[ms];if(n){let{i18nNodes:e,dehydratedIcuData:r}=n;if(e&&r){let o=t[rr];for(let s of r.values())EX(o,e,s)}n.i18nNodes=void 0,n.dehydratedIcuData=void 0}}function EX(t,n,e){for(let r of e.node.cases[e.case]){let o=n.get(r.index-go);o&&TS(t,o,!1)}}function WR(t){let n=t[Fh]??[],r=t[Kn][rr];for(let o of n)DX(o,r);t[Fh]=bu}function DX(t,n){let e=0,r=t.firstChild;if(r){let o=t.data[Iy];for(;e<o;){let s=r.nextSibling;TS(n,r,!1),r=s,e++}}}function jR(t){WR(t);let n=t[Yr];ds(n)&&Ny(n);for(let e=kr;e<t.length;e++)Ny(t[e])}function Ny(t){NX(t);let n=t[Xe];for(let e=go;e<n.bindingStartIndex;e++)if(ys(t[e])){let r=t[e];jR(r)}else ds(t[e])&&Ny(t[e])}function kX(t){let n=t._views;for(let e of n){let r=X8(e);r!==null&&r[Yr]!==null&&(ds(r)?Ny(r):jR(r))}}function AX(t,n){let e=[];for(let r of n)for(let o=0;o<(r[sR]??1);o++){let s={data:r,firstChild:null};r[Iy]>0&&(s.firstChild=t,t=qy(r[Iy],t)),e.push(s)}return[t,e]}var HR=()=>null;function RX(t,n){let e=t[Fh];return!n||e===null||e.length===0?null:e[0].data[G8]===n?e.shift():(WR(t),null)}function _X(){HR=RX}function Mk(t,n){return HR(t,n)}var mp=class{},Ky=new Be("",{providedIn:"root",factory:()=>!1});var qR=new Be(""),KR=new Be(""),zI=class{},Ey=class{};function OX(t){let n=Error(`No component factory found for ${Xr(t)}.`);return n[FX]=t,n}var FX="ngComponent";var VI=class{resolveComponentFactory(n){throw OX(n)}},gp=class{static{this.NULL=new VI}},yp=class{};var MX=(()=>{class t{static{this.\u0275prov=Ge({token:t,providedIn:"root",factory:()=>null})}}return t})();function UI(t,n,e){let r=e?t.styles:null,o=e?t.classes:null,s=0;if(n!==null)for(let i=0;i<n.length;i++){let a=n[i];if(typeof a=="number")s=a;else if(s==1)o=ak(o,a);else if(s==2){let l=a,u=n[++i];r=ak(r,l+": "+u+";")}}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=o:t.classesWithoutHost=o}var Dy=class extends gp{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){let e=wu(n);return new Ph(e,this.ngModule)}};function $k(t,n){let e=[];for(let r in t){if(!t.hasOwnProperty(r))continue;let o=t[r];if(o===void 0)continue;let s=Array.isArray(o),i=s?o[0]:o,a=s?o[1]:Ra.None;n?e.push({propName:i,templateName:r,isSignal:(a&Ra.SignalBased)!==0}):e.push({propName:i,templateName:r})}return e}function $X(t){let n=t.toLowerCase();return n==="svg"?L6:n==="math"?B6:null}var Ph=class extends Ey{get inputs(){let n=this.componentDef,e=n.inputTransforms,r=$k(n.inputs,!0);if(e!==null)for(let o of r)e.hasOwnProperty(o.propName)&&(o.transform=e[o.propName]);return r}get outputs(){return $k(this.componentDef.outputs,!1)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=g6(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,o){let s=Et(null);try{o=o||this.ngModule;let i=o instanceof ho?o:o?.injector;i&&this.componentDef.getStandaloneInjector!==null&&(i=this.componentDef.getStandaloneInjector(i)||i);let a=i?new II(n,i):n,l=a.get(yp,null);if(l===null)throw new Oe(407,!1);let u=a.get(MX,null),c=a.get(mp,null),p={rendererFactory:l,sanitizer:u,inlineEffectRunner:null,changeDetectionScheduler:c},f=l.createRenderer(null,this.componentDef),d=this.componentDef.selectors[0][0]||"div",h=r?D5(f,r,this.componentDef.encapsulation,a):IS(f,d,$X(d)),g=512;this.componentDef.signals?g|=4096:this.componentDef.onPush||(g|=16);let m=null;h!==null&&(m=vS(h,a,!0));let y=RR(0,null,null,1,0,null,null,null,null,null,null),x=jy(null,y,null,g,null,null,p,f,a,null,m);pS(x);let v,w,T=null;try{let k=this.componentDef,A,O=null;k.findHostDirectiveDefs?(A=[],O=new Map,k.findHostDirectiveDefs(k,A,O),A.push(k)):A=[k];let M=PX(x,h);T=LX(M,h,k,A,x,p,f),w=z6(y,go),h&&VX(f,k,h,r),e!==void 0&&UX(w,this.ngContentSelectors,e),v=zX(T,k,A,O,x,[GX]),kS(y,x,null)}catch(k){throw T!==null&&RI(T),RI(x),k}finally{fS()}return new GI(this.componentType,v,bp(w,x),x,w)}finally{Et(s)}}},GI=class extends zI{constructor(n,e,r,o,s){super(),this.location=r,this._rootLView=o,this._tNode=s,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new Tu(o,void 0,!1),this.componentType=n}setInput(n,e){let r=this._tNode.inputs,o;if(r!==null&&(o=r[n])){if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),e))return;let s=this._rootLView;$R(s[Xe],s,o,n,e),this.previousInputValues.set(n,e);let i=Vh(this._tNode.index,s);GR(i,1)}}get injector(){return new xu(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}};function PX(t,n){let e=t[Xe],r=go;return t[r]=n,NR(e,r,2,"#host",null)}function LX(t,n,e,r,o,s,i){let a=o[Xe];BX(r,t,n,i);let l=null;n!==null&&(l=vS(n,o[pp]));let u=s.rendererFactory.createRenderer(n,e),c=16;e.signals?c=4096:e.onPush&&(c=64);let p=jy(o,AR(e),null,c,o[t.index],t,s,u,null,null,l);return a.firstCreatePass&&PI(a,t,r.length-1),DS(o,p),o[t.index]=p}function BX(t,n,e,r){for(let o of t)n.mergedAttrs=rS(n.mergedAttrs,o.hostAttrs);n.mergedAttrs!==null&&(UI(n,n.mergedAttrs,!0),e!==null&&IR(r,e,n))}function zX(t,n,e,r,o,s){let i=bs(),a=o[Xe],l=xs(i,o);OR(a,o,i,e,null,r);for(let c=0;c<e.length;c++){let p=i.directiveStart+c,f=dp(o,a,p,i);hp(f,o)}FR(a,o,i),l&&hp(l,o);let u=dp(o,a,i.directiveStart+i.componentOffset,i);if(t[_a]=o[_a]=u,s!==null)for(let c of s)c(u,n);return kR(a,i,o),u}function VX(t,n,e,r){if(r)hI(t,e,["ng-version","18.2.11"]);else{let{attrs:o,classes:s}=y6(n.selectors[0]);o&&hI(t,e,o),s&&s.length>0&&CR(t,e,s.join(" "))}}function UX(t,n,e){let r=t.projection=[];for(let o=0;o<n.length;o++){let s=e[o];r.push(s!=null?Array.from(s):null)}}function GX(){let t=bs();OA(Ar()[Xe],t)}var wp=(()=>{class t{static{this.__NG_ELEMENT_ID__=WX}}return t})();function WX(){let t=bs();return YR(t,Ar())}var jX=wp,XR=class extends jX{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return bp(this._hostTNode,this._hostLView)}get injector(){return new xu(this._hostTNode,this._hostLView)}get parentInjector(){let n=dS(this._hostTNode,this._hostLView);if(MA(n)){let e=by(n,this._hostLView),r=xy(n),o=e[Xe].data[r+8];return new xu(o,e)}else return new xu(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){let e=Pk(this._lContainer);return e!==null&&e[n]||null}get length(){return this._lContainer.length-kr}createEmbeddedView(n,e,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=Mk(this._lContainer,n.ssrId),a=n.createEmbeddedViewImpl(e||{},s,i);return this.insertImpl(a,o,Fk(this._hostTNode,i)),a}createComponent(n,e,r,o,s){let i=n&&!O6(n),a;if(i)a=e;else{let h=e||{};a=h.index,r=h.injector,o=h.projectableNodes,s=h.environmentInjector||h.ngModuleRef}let l=i?n:new Ph(wu(n)),u=r||this.parentInjector;if(!s&&l.ngModule==null){let g=(i?u:this.parentInjector).get(ho,null);g&&(s=g)}let c=wu(l.componentType??{}),p=Mk(this._lContainer,c?.id??null),f=p?.firstChild??null,d=l.create(u,o,f,s);return this.insertImpl(d.hostView,a,Fk(this._hostTNode,p)),d}insert(n,e){return this.insertImpl(n,e,!0)}insertImpl(n,e,r){let o=n._lView;if(U6(o)){let a=this.indexOf(n);if(a!==-1)this.detach(a);else{let l=o[Kn],u=new XR(l,l[Go],l[Kn]);u.detach(u.indexOf(n))}}let s=this._adjustIndex(e),i=this._lContainer;return nX(i,o,s,r),n.attachToViewContainerRef(),Yk(pI(i),s,n),n}move(n,e){return this.insert(n,e)}indexOf(n){let e=Pk(this._lContainer);return e!==null?e.indexOf(n):-1}remove(n){let e=this._adjustIndex(n,-1),r=MI(this._lContainer,e);r&&(dy(pI(this._lContainer),e),yR(r[Xe],r))}detach(n){let e=this._adjustIndex(n,-1),r=MI(this._lContainer,e);return r&&dy(pI(this._lContainer),e)!=null?new Tu(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function Pk(t){return t[my]}function pI(t){return t[my]||(t[my]=[])}function YR(t,n){let e,r=n[t.index];return ys(r)?e=r:(e=K5(r,n,null,t),n[t.index]=e,DS(n,e)),ZR(e,n,t,r),new XR(e,t,n)}function HX(t,n){let e=t[rr],r=e.createComment(""),o=xs(n,t),s=bR(e,o);return Sy(e,s,r,h5(e,o),!1),r}var ZR=JR,QR=()=>!1;function JR(t,n,e,r){if(t[Js])return;let o;e.type&8?o=ei(r):o=HX(n,e),t[Js]=o}function qX(t,n,e){if(t[Js]&&t[Fh])return!0;let r=e[ms],o=n.index-go;if(!r||F8(n)||Gh(r,o))return!1;let i=FI(r,o),a=r.data[bS]?.[o],[l,u]=AX(i,a);return t[Js]=l,t[Fh]=u,!0}function KX(t,n,e,r){QR(t,e,n)||JR(t,n,e,r)}function XX(){ZR=KX,QR=qX}var WI=class t{constructor(n){this.queryList=n,this.matches=null}clone(){return new t(this.queryList)}setDirty(){this.queryList.setDirty()}},jI=class t{constructor(n=[]){this.queries=n}createEmbeddedView(n){let e=n.queries;if(e!==null){let r=n.contentQueries!==null?n.contentQueries[0]:e.length,o=[];for(let s=0;s<r;s++){let i=e.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new t(o)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}finishViewCreation(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)RS(n,e).matches!==null&&this.queries[e].setDirty()}},HI=class{constructor(n,e,r=null){this.flags=e,this.read=r,typeof n=="string"?this.predicate=rY(n):this.predicate=n}},qI=class t{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){let o=e!==null?e.length:0,s=this.getByIndex(r).embeddedTView(n,o);s&&(s.indexInDeclarationView=r,e!==null?e.push(s):e=[s])}return e!==null?new t(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}},KI=class t{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new t(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let e=this._declarationNodeIndex,r=n.parent;for(;r!==null&&r.type&8&&r.index!==e;)r=r.parent;return e===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(n,e,YX(e,s)),this.matchTNodeWithReadOption(n,e,ly(e,n,s,!1,!1))}else r===$h?e.type&4&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,ly(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===Du||o===wp||o===$h&&e.type&4)this.addMatch(e.index,-2);else{let s=ly(e,n,o,!1,!1);s!==null&&this.addMatch(e.index,s)}else this.addMatch(e.index,r)}}addMatch(n,e){this.matches===null?this.matches=[n,e]:this.matches.push(n,e)}};function YX(t,n){let e=t.localNames;if(e!==null){for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1]}return null}function ZX(t,n){return t.type&11?bp(t,n):t.type&4?AS(t,n):null}function QX(t,n,e,r){return e===-1?ZX(n,t):e===-2?JX(t,n,r):dp(t,t[Xe],e,n)}function JX(t,n,e){if(e===Du)return bp(n,t);if(e===$h)return AS(n,t);if(e===wp)return YR(n,t)}function e_(t,n,e,r){let o=n[Qs].queries[r];if(o.matches===null){let s=t.data,i=e.matches,a=[];for(let l=0;i!==null&&l<i.length;l+=2){let u=i[l];if(u<0)a.push(null);else{let c=s[u];a.push(QX(n,c,i[l+1],e.metadata.read))}}o.matches=a}return o.matches}function XI(t,n,e,r){let o=t.queries.getByIndex(e),s=o.matches;if(s!==null){let i=e_(t,n,o,e);for(let a=0;a<s.length;a+=2){let l=s[a];if(l>0)r.push(i[a/2]);else{let u=s[a+1],c=n[-l];for(let p=kr;p<c.length;p++){let f=c[p];f[Cu]===f[Kn]&&XI(f[Xe],f,u,r)}if(c[fp]!==null){let p=c[fp];for(let f=0;f<p.length;f++){let d=p[f];XI(d[Xe],d,u,r)}}}}}return r}function eY(t,n){return t[Qs].queries[n].queryList}function tY(t,n,e){let r=new AI((e&4)===4);return _5(t,n,r,r.destroy),(n[Qs]??=new jI).queries.push(new WI(r))-1}function nY(t,n,e){let r=zy();return r.firstCreatePass&&(oY(r,new HI(t,n,e),-1),(n&2)===2&&(r.staticViewQueries=!0)),tY(r,Ar(),n)}function rY(t){return t.split(",").map(n=>n.trim())}function oY(t,n,e){t.queries===null&&(t.queries=new qI),t.queries.track(new KI(n,e))}function RS(t,n){return t.queries.getByIndex(n)}function sY(t,n){let e=t[Xe],r=RS(e,n);return r.crossesNgTemplate?XI(e,t,n,[]):e_(e,t,r,n)}var Lk=new Set;function Cp(t){Lk.has(t)||(Lk.add(t),performance?.mark?.("mark_feature_usage",{detail:{feature:t}}))}var Oa=class{},Lh=class{};var YI=class extends Oa{constructor(n,e,r,o=!0){super(),this.ngModuleType=n,this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Dy(this);let s=oA(n);this._bootstrapComponents=fR(s.bootstrap),this._r3Injector=jA(n,e,[{provide:Oa,useValue:this},{provide:gp,useValue:this.componentFactoryResolver},...r],Xr(n),new Set(["environment"])),o&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){let n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}},ZI=class extends Lh{constructor(n){super(),this.moduleType=n}create(n){return new YI(this.moduleType,n,[])}};var ky=class extends Oa{constructor(n){super(),this.componentFactoryResolver=new Dy(this),this.instance=null;let e=new _h([...n.providers,{provide:Oa,useValue:this},{provide:gp,useValue:this.componentFactoryResolver}],n.parent||aS(),n.debugName,new Set(["environment"]));this.injector=e,n.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}};function _S(t,n,e=null){return new ky({providers:t,parent:n,debugName:e,runEnvironmentInitializers:!0}).injector}function Wh(t){return(t.flags&32)===32}var iY=t_;function t_(t,n,e,r){return Fa(!0),n[rr].createComment("")}function aY(t,n,e,r){let o=n[ms],s=!o||Uh()||Wh(e)||Gh(o,r);if(Fa(s),s)return t_(t,n,e,r);let i=o.data[U8]?.[r]??null;i!==null&&e.tView!==null&&e.tView.ssrId===null&&(e.tView.ssrId=i);let a=Hy(o,t,n,e);Gy(o,r,a);let l=wS(o,r);return qy(l,a)}function lY(){iY=aY}var Dh=function(t){return t[t.EarlyRead=0]="EarlyRead",t[t.Write=1]="Write",t[t.MixedReadWrite=2]="MixedReadWrite",t[t.Read=3]="Read",t}(Dh||{}),uY=(()=>{class t{constructor(){this.impl=null}execute(){this.impl?.execute()}static{this.\u0275prov=Ge({token:t,providedIn:"root",factory:()=>new t})}}return t})(),Bk=class t{constructor(){this.ngZone=ue(dn),this.scheduler=ue(mp),this.errorHandler=ue(ni,{optional:!0}),this.sequences=new Set,this.deferredRegistrations=new Set,this.executing=!1}static{this.PHASES=[Dh.EarlyRead,Dh.Write,Dh.MixedReadWrite,Dh.Read]}execute(){this.executing=!0;for(let n of t.PHASES)for(let e of this.sequences)if(!(e.erroredOrDestroyed||!e.hooks[n]))try{e.pipelinedValue=this.ngZone.runOutsideAngular(()=>e.hooks[n](e.pipelinedValue))}catch(r){e.erroredOrDestroyed=!0,this.errorHandler?.handleError(r)}this.executing=!1;for(let n of this.sequences)n.afterRun(),n.once&&(this.sequences.delete(n),n.destroy());for(let n of this.deferredRegistrations)this.sequences.add(n);this.deferredRegistrations.size>0&&this.scheduler.notify(7),this.deferredRegistrations.clear()}register(n){this.executing?this.deferredRegistrations.add(n):(this.sequences.add(n),this.scheduler.notify(6))}unregister(n){this.executing&&this.sequences.has(n)?(n.erroredOrDestroyed=!0,n.pipelinedValue=void 0,n.once=!0):(this.sequences.delete(n),this.deferredRegistrations.delete(n))}static{this.\u0275prov=Ge({token:t,providedIn:"root",factory:()=>new t})}};function zk(t,n,e,r,o){let s=n.inputs,i=o?"class":"style";$R(t,e,s[i],i,r)}function cY(t,n,e,r,o,s){let i=n.consts,a=bk(i,o),l=NR(n,t,2,r,a);return M5(n,e,l,bk(i,s)),l.attrs!==null&&UI(l,l.attrs,!1),l.mergedAttrs!==null&&UI(l,l.mergedAttrs,!0),n.queries!==null&&n.queries.elementStart(n,l),l}function Xy(t,n,e,r){let o=Ar(),s=zy(),i=go+t,a=o[rr],l=s.firstCreatePass?cY(i,s,o,n,e,r):s.data[i],u=n_(s,o,l,a,n,t);o[i]=u;let c=F6(l);return uS(l,!0),IR(a,u,l),!Wh(l)&&o8()&&x5(s,o,u,l),W6()===0&&hp(u,o),j6(),c&&(T5(s,o,l),kR(s,l,o)),r!==null&&N5(o,l),Xy}function Yy(){let t=bs();IA()?Z6():(t=t.parent,uS(t,!1));let n=t;q6(n)&&X6(),H6();let e=zy();return e.firstCreatePass&&(OA(e,t),fA(t)&&e.queries.elementEnd(t)),n.classesWithoutHost!=null&&l8(n)&&zk(e,n,Ar(),n.classesWithoutHost,!0),n.stylesWithoutHost!=null&&u8(n)&&zk(e,n,Ar(),n.stylesWithoutHost,!1),Yy}function Au(t,n,e,r){return Xy(t,n,e,r),Yy(),Au}var n_=(t,n,e,r,o,s)=>(Fa(!0),IS(r,o,RA()));function pY(t,n,e,r,o,s){let i=n[ms],a=!i||Uh()||Wh(e)||Gh(i,s);if(Fa(a),a)return IS(r,o,RA());let l=Hy(i,t,n,e);return uR(i,s)&&Gy(i,s,l.nextSibling),i&&(YA(e)||ZA(l))&&$y(e)&&(K6(e),wR(l)),l}function fY(){n_=pY}var dY=(t,n,e,r)=>(Fa(!0),hR(n[rr],""));function hY(t,n,e,r){let o,s=n[ms],i=!s||Uh()||Gh(s,r)||Wh(e);if(Fa(i),i)return hR(n[rr],"");let a=Hy(s,t,n,e),l=Q8(s,r);return Gy(s,r,a),o=qy(l,a),o}function mY(){dY=hY}var Ay="en-US";var gY=Ay;function yY(t){typeof t=="string"&&(gY=t.toLowerCase().replace(/_/g,"-"))}function OS(t,n,e){nY(t,n,e)}function Zy(t){let n=Ar(),e=zy(),r=TA();cS(r+1);let o=RS(e,r);if(t.dirty&&V6(n)===((o.metadata.flags&2)===2)){if(o.matches===null)t.reset([]);else{let s=sY(n,r);t.reset(s,A8),t.notifyOnChanges()}return!0}return!1}function Qy(){return eY(Ar(),TA())}var xY=(t,n,e,r,o)=>(Fa(!0),dR(n[rr],r));function bY(t,n,e,r,o){let s=n[ms],i=!s||Uh()||Wh(e)||Gh(s,o);return Fa(i),i?dR(n[rr],r):Hy(s,t,n,e)}function vY(){xY=bY}var wY=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e)){let r=aA(!1,e.type),o=r.length>0?_S([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e,o)}return this.cachedInjectors.get(e)}ngOnDestroy(){try{for(let e of this.cachedInjectors.values())e!==null&&e.destroy()}finally{this.cachedInjectors.clear()}}static{this.\u0275prov=Ge({token:t,providedIn:"environment",factory:()=>new t(st(ho))})}}return t})();function Ip(t){Cp("NgStandalone"),t.getStandaloneInjector=n=>n.get(wY).getOrCreateStandaloneInjector(t)}var Jy=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"platform"})}}return t})();var r_=new Be("");function jh(t){return!!t&&typeof t.then=="function"}function o_(t){return!!t&&typeof t.subscribe=="function"}var s_=new Be(""),i_=(()=>{class t{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=ue(s_,{optional:!0})??[]}runInitializers(){if(this.initialized)return;let e=[];for(let o of this.appInits){let s=o();if(jh(s))e.push(s);else if(o_(s)){let i=new Promise((a,l)=>{s.subscribe({complete:a,error:l})});e.push(i)}}let r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(o=>{this.reject(o)}),e.length===0&&r(),this.initialized=!0}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),Sp=new Be("");function CY(){_1(()=>{throw new Oe(600,!1)})}function IY(t){return t.isBoundToModule}var SY=10;function TY(t,n,e){try{let r=e();return jh(r)?r.catch(o=>{throw n.runOutsideAngular(()=>t.handleError(o)),o}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}var ws=(()=>{class t{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=ue(D8),this.afterRenderManager=ue(uY),this.zonelessEnabled=ue(Ky),this.dirtyFlags=0,this.deferredDirtyFlags=0,this.externalTestViews=new Set,this.beforeRender=new gr,this.afterTick=new gr,this.componentTypes=[],this.components=[],this.isStable=ue(Eu).hasPendingTasks.pipe(nt(e=>!e)),this._injector=ue(ho)}get allViews(){return[...this.externalTestViews.keys(),...this._views]}get destroyed(){return this._destroyed}whenStable(){let e;return new Promise(r=>{e=this.isStable.subscribe({next:o=>{o&&r()}})}).finally(()=>{e.unsubscribe()})}get injector(){return this._injector}bootstrap(e,r){let o=e instanceof Ey;if(!this._injector.get(i_).done){let f=!o&&rA(e),d=!1;throw new Oe(405,d)}let i;o?i=e:i=this._injector.get(gp).resolveComponentFactory(e),this.componentTypes.push(i.componentType);let a=IY(i)?void 0:this._injector.get(Oa),l=r||i.selector,u=i.create(ti.NULL,[],l,a),c=u.location.nativeElement,p=u.injector.get(r_,null);return p?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),uy(this.components,u),p?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){if(this._runningTick)throw new Oe(101,!1);let e=Et(null);try{this._runningTick=!0,this.synchronize()}catch(r){this.internalErrorHandler(r)}finally{this._runningTick=!1,Et(e),this.afterTick.next()}}synchronize(){let e=null;this._injector.destroyed||(e=this._injector.get(yp,null,{optional:!0})),this.dirtyFlags|=this.deferredDirtyFlags,this.deferredDirtyFlags=0;let r=0;for(;this.dirtyFlags!==0&&r++<SY;)this.synchronizeOnce(e)}synchronizeOnce(e){if(this.dirtyFlags|=this.deferredDirtyFlags,this.deferredDirtyFlags=0,this.dirtyFlags&7){let r=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8,this.beforeRender.next(r);for(let{_lView:o,notifyErrorHandler:s}of this._views)NY(o,s,r,this.zonelessEnabled);if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&7)return}else e?.begin?.(),e?.end?.();this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:e})=>Ly(e))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(e){let r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){let r=e;uy(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);let r=this._injector.get(Sp,[]);[...this._bootstrapListeners,...r].forEach(o=>o(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>uy(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new Oe(406,!1);let e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();function uy(t,n){let e=t.indexOf(n);e>-1&&t.splice(e,1)}var ry;function ex(t){ry??=new WeakMap;let n=ry.get(t);if(n)return n;let e=t.isStable.pipe(zo(r=>r)).toPromise().then(()=>{});return ry.set(t,e),t.onDestroy(()=>ry?.delete(t)),e}function NY(t,n,e,r){if(!e&&!Ly(t))return;BR(t,n,e&&!r?0:1)}var QI=class{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}},FS=(()=>{class t{compileModuleSync(e){return new ZI(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){let r=this.compileModuleSync(e),o=oA(e),s=fR(o.declarations).reduce((i,a)=>{let l=wu(a);return l&&i.push(new Ph(l)),i},[]);return new QI(r,s)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();var EY=(()=>{class t{constructor(){this.zone=ue(dn),this.changeDetectionScheduler=ue(mp),this.applicationRef=ue(ws)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),DY=new Be("",{factory:()=>!1});function a_({ngZoneFactory:t,ignoreChangesOutsideZone:n,scheduleInRootZone:e}){return t??=()=>new dn(an(Se({},u_()),{scheduleInRootZone:e})),[{provide:dn,useFactory:t},{provide:vu,multi:!0,useFactory:()=>{let r=ue(EY,{optional:!0});return()=>r.initialize()}},{provide:vu,multi:!0,useFactory:()=>{let r=ue(kY);return()=>{r.initialize()}}},n===!0?{provide:qR,useValue:!0}:[],{provide:KR,useValue:e??HA}]}function l_(t){let n=t?.ignoreChangesOutsideZone,e=t?.scheduleInRootZone,r=a_({ngZoneFactory:()=>{let o=u_(t);return o.scheduleInRootZone=e,o.shouldCoalesceEventChangeDetection&&Cp("NgZone_CoalesceEvent"),new dn(o)},ignoreChangesOutsideZone:n,scheduleInRootZone:e});return Nu([{provide:DY,useValue:!0},{provide:Ky,useValue:!1},r])}function u_(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:t?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:t?.runCoalescing??!1}}var kY=(()=>{class t{constructor(){this.subscription=new gn,this.initialized=!1,this.zone=ue(dn),this.pendingTasks=ue(Eu)}initialize(){if(this.initialized)return;this.initialized=!0;let e=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(e=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{dn.assertNotInAngularZone(),queueMicrotask(()=>{e!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(e),e=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{dn.assertInAngularZone(),e??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();var AY=(()=>{class t{constructor(){this.appRef=ue(ws),this.taskService=ue(Eu),this.ngZone=ue(dn),this.zonelessEnabled=ue(Ky),this.disableScheduling=ue(qR,{optional:!0})??!1,this.zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run,this.schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}],this.subscriptions=new gn,this.angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(wy):null,this.scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(ue(KR,{optional:!0})??!1),this.cancelScheduledCallback=null,this.useMicrotaskScheduler=!1,this.runningTick=!1,this.pendingRenderTaskId=null,this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof kI||!this.zoneIsDefined)}notify(e){if(!this.zonelessEnabled&&e===5)return;switch(e){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 7:{this.appRef.deferredDirtyFlags|=8;break}case 9:case 8:case 6:case 10:default:this.appRef.dirtyFlags|=8}if(!this.shouldScheduleTick())return;let r=this.useMicrotaskScheduler?Nk:KA;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>r(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>r(()=>this.tick()))}shouldScheduleTick(){return!(this.disableScheduling||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(wy+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let e=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){throw this.taskService.remove(e),r}finally{this.cleanup()}this.useMicrotaskScheduler=!0,Nk(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(e)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let e=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(e)}}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();function RY(){return typeof $localize<"u"&&$localize.locale||Ay}var MS=new Be("",{providedIn:"root",factory:()=>ue(MS,Qe.Optional|Qe.SkipSelf)||RY()});var JI=new Be("");function oy(t){return!t.moduleRef}function _Y(t){let n=oy(t)?t.r3Injector:t.moduleRef.injector,e=n.get(dn);return e.run(()=>{oy(t)?t.r3Injector.resolveInjectorInitializers():t.moduleRef.resolveInjectorInitializers();let r=n.get(ni,null),o;if(e.runOutsideAngular(()=>{o=e.onError.subscribe({next:s=>{r.handleError(s)}})}),oy(t)){let s=()=>n.destroy(),i=t.platformInjector.get(JI);i.add(s),n.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else{let s=()=>t.moduleRef.destroy(),i=t.platformInjector.get(JI);i.add(s),t.moduleRef.onDestroy(()=>{uy(t.allPlatformModules,t.moduleRef),o.unsubscribe(),i.delete(s)})}return TY(r,e,()=>{let s=n.get(i_);return s.runInitializers(),s.donePromise.then(()=>{let i=n.get(MS,Ay);if(yY(i||Ay),oy(t)){let a=n.get(ws);return t.rootComponent!==void 0&&a.bootstrap(t.rootComponent),a}else return OY(t.moduleRef,t.allPlatformModules),t.moduleRef})})})}function OY(t,n){let e=t.injector.get(ws);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(r=>e.bootstrap(r));else if(t.instance.ngDoBootstrap)t.instance.ngDoBootstrap(e);else throw new Oe(-403,!1);n.push(t)}var cy=null;function FY(t=[],n){return ti.create({name:n,providers:[{provide:Fy,useValue:"platform"},{provide:JI,useValue:new Set([()=>cy=null])},...t]})}function MY(t=[]){if(cy)return cy;let n=FY(t);return cy=n,CY(),$Y(n),n}function $Y(t){t.get(yS,null)?.forEach(e=>e())}var Hh=(()=>{class t{static{this.__NG_ELEMENT_ID__=PY}}return t})();function PY(t){return LY(bs(),Ar(),(t&16)===16)}function LY(t,n,e){if($y(t)&&!e){let r=Vh(t.index,n);return new Tu(r,r)}else if(t.type&175){let r=n[mo];return new Tu(r,n)}return null}function c_(t){try{let{rootComponent:n,appProviders:e,platformProviders:r}=t,o=MY(r),s=[a_({}),{provide:mp,useExisting:AY},...e||[]],i=new ky({providers:s,parent:o,debugName:"",runEnvironmentInitializers:!1});return _Y({r3Injector:i.injector,platformInjector:o,rootComponent:n})}catch(n){return Promise.reject(n)}}var Vk=!1;function BY(){Vk||(Vk=!0,K8(),fY(),vY(),mY(),lY(),XX(),_X(),R5())}function zY(t,n){return ex(t)}function p_(){return Nu([{provide:ty,useFactory:()=>{let t=!0;return ny()&&(t=!!ue(vp,{optional:!0})?.get(aR,null)),t&&Cp("NgHydration"),t}},{provide:vu,useValue:()=>{TX(!1),ny()&&ue(ty)&&(VY(),BY())},multi:!0},{provide:pR,useFactory:()=>ny()&&ue(ty)},{provide:Sp,useFactory:()=>{if(ny()&&ue(ty)){let t=ue(ws),n=ue(ti);return()=>{zY(t,n).then(()=>{kX(t)})}}return()=>{}},multi:!0}])}function VY(){let t=Vy(),n;for(let e of t.body.childNodes)if(e.nodeType===Node.COMMENT_NODE&&e.textContent?.trim()===H8){n=e;break}if(!n)throw new Oe(-507,!1)}var x_=null;function Tp(){return x_}function b_(t){x_??=t}var tx=class{};var Zr=new Be(""),v_=(()=>{class t{historyGo(e){throw new Error("")}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(HY),providedIn:"platform"})}}return t})();var HY=(()=>{class t extends v_{constructor(){super(),this._doc=ue(Zr),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Tp().getBaseHref(this._doc)}onPopState(e){let r=Tp().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){let r=Tp().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,o){this._history.pushState(e,r,o)}replaceState(e,r,o){this._history.replaceState(e,r,o)}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>new t,providedIn:"platform"})}}return t})();function w_(t,n){if(t.length==0)return n;if(n.length==0)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,e==2?t+n.substring(1):e==1?t+n:t+"/"+n}function f_(t){let n=t.match(/#|\?|$/),e=n&&n.index||t.length,r=e-(t[e-1]==="/"?1:0);return t.slice(0,r)+t.slice(e)}function Ru(t){return t&&t[0]!=="?"?"?"+t:t}var rx=(()=>{class t{historyGo(e){throw new Error("")}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(C_),providedIn:"root"})}}return t})(),qY=new Be(""),C_=(()=>{class t extends rx{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??ue(Zr).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return w_(this._baseHref,e)}path(e=!1){let r=this._platformLocation.pathname+Ru(this._platformLocation.search),o=this._platformLocation.hash;return o&&e?`${r}${o}`:r}pushState(e,r,o,s){let i=this.prepareExternalUrl(o+Ru(s));this._platformLocation.pushState(e,r,i)}replaceState(e,r,o,s){let i=this.prepareExternalUrl(o+Ru(s));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static{this.\u0275fac=function(r){return new(r||t)(st(v_),st(qY,8))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();var Kh=(()=>{class t{constructor(e){this._subject=new nr,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;let r=this._locationStrategy.getBaseHref();this._basePath=YY(f_(d_(r))),this._locationStrategy.onPopState(o=>{this._subject.emit({url:this.path(!0),pop:!0,state:o.state,type:o.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+Ru(r))}normalize(e){return t.stripTrailingSlash(XY(this._basePath,d_(e)))}prepareExternalUrl(e){return e&&e[0]!=="/"&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",o=null){this._locationStrategy.pushState(o,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(r)),o)}replaceState(e,r="",o=null){this._locationStrategy.replaceState(o,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(r)),o)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription??=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}),()=>{let r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),this._urlChangeListeners.length===0&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(o=>o(e,r))}subscribe(e,r,o){return this._subject.subscribe({next:e,error:r,complete:o})}static{this.normalizeQueryParams=Ru}static{this.joinWithSlash=w_}static{this.stripTrailingSlash=f_}static{this.\u0275fac=function(r){return new(r||t)(st(rx))}}static{this.\u0275prov=Ge({token:t,factory:()=>KY(),providedIn:"root"})}}return t})();function KY(){return new Kh(st(rx))}function XY(t,n){if(!t||!n.startsWith(t))return n;let e=n.substring(t.length);return e===""||["/",";","?","#"].includes(e[0])?e:n}function d_(t){return t.replace(/\/index.html$/,"")}function YY(t){if(new RegExp("^(https?:)?//").test(t)){let[,e]=t.split(/\/\/[^\/]+/);return e}return t}function $S(t,n){n=encodeURIComponent(n);for(let e of t.split(";")){let r=e.indexOf("="),[o,s]=r==-1?[e,""]:[e.slice(0,r),e.slice(r+1)];if(o.trim()===n)return decodeURIComponent(s)}return null}var I_="browser",ZY="server";function Xh(t){return t===ZY}var nx=class{};var sx=class t{constructor(n){this.normalizedNames=new Map,this.lazyUpdate=null,n?typeof n=="string"?this.lazyInit=()=>{this.headers=new Map,n.split(`
`).forEach(e=>{let r=e.indexOf(":");if(r>0){let o=e.slice(0,r),s=o.toLowerCase(),i=e.slice(r+1).trim();this.maybeSetNormalizedName(o,s),this.headers.has(s)?this.headers.get(s).push(i):this.headers.set(s,[i])}})}:typeof Headers<"u"&&n instanceof Headers?(this.headers=new Map,n.forEach((e,r)=>{this.setHeaderEntries(r,e)})):this.lazyInit=()=>{this.headers=new Map,Object.entries(n).forEach(([e,r])=>{this.setHeaderEntries(e,r)})}:this.headers=new Map}has(n){return this.init(),this.headers.has(n.toLowerCase())}get(n){this.init();let e=this.headers.get(n.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(n){return this.init(),this.headers.get(n.toLowerCase())||null}append(n,e){return this.clone({name:n,value:e,op:"a"})}set(n,e){return this.clone({name:n,value:e,op:"s"})}delete(n,e){return this.clone({name:n,value:e,op:"d"})}maybeSetNormalizedName(n,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,n)}init(){this.lazyInit&&(this.lazyInit instanceof t?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(n=>this.applyUpdate(n)),this.lazyUpdate=null))}copyFrom(n){n.init(),Array.from(n.headers.keys()).forEach(e=>{this.headers.set(e,n.headers.get(e)),this.normalizedNames.set(e,n.normalizedNames.get(e))})}clone(n){let e=new t;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof t?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([n]),e}applyUpdate(n){let e=n.name.toLowerCase();switch(n.op){case"a":case"s":let r=n.value;if(typeof r=="string"&&(r=[r]),r.length===0)return;this.maybeSetNormalizedName(n.name,e);let o=(n.op==="a"?this.headers.get(e):void 0)||[];o.push(...r),this.headers.set(e,o);break;case"d":let s=n.value;if(!s)this.headers.delete(e),this.normalizedNames.delete(e);else{let i=this.headers.get(e);if(!i)return;i=i.filter(a=>s.indexOf(a)===-1),i.length===0?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,i)}break}}setHeaderEntries(n,e){let r=(Array.isArray(e)?e:[e]).map(s=>s.toString()),o=n.toLowerCase();this.headers.set(o,r),this.maybeSetNormalizedName(n,o)}forEach(n){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>n(this.normalizedNames.get(e),this.headers.get(e)))}};var R_=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}(R_||{}),PS=class{constructor(n,e=200,r="OK"){this.headers=n.headers||new sx,this.status=n.status!==void 0?n.status:e,this.statusText=n.statusText||r,this.url=n.url||null,this.ok=this.status>=200&&this.status<300}};var ix=class t extends PS{constructor(n={}){super(n),this.type=R_.Response,this.body=n.body!==void 0?n.body:null}clone(n={}){return new t({body:n.body!==void 0?n.body:this.body,headers:n.headers||this.headers,status:n.status!==void 0?n.status:this.status,statusText:n.statusText||this.statusText,url:n.url||this.url||void 0})}};var QY=new Be("");var JY=new Be(""),S_="b",T_="h",N_="s",E_="st",D_="u",k_="rt",ox=new Be(""),eZ=["GET","HEAD"];function tZ(t,n){let d=ue(ox),{isCacheActive:e}=d,r=D1(d,["isCacheActive"]),{transferCache:o,method:s}=t;if(!e||o===!1||s==="POST"&&!r.includePostRequests&&!o||s!=="POST"&&!eZ.includes(s)||!r.includeRequestsWithAuthHeaders&&nZ(t)||r.filter?.(t)===!1)return n(t);let i=ue(vp),a=ue(JY,{optional:!0}),l=Xh(ue(vs));if(a&&!l)throw new Oe(2803,!1);let u=l&&a?iZ(t.url,a):t.url,c=oZ(t,u),p=i.get(c,null),f=r.includeHeaders;if(typeof o=="object"&&o.includeHeaders&&(f=o.includeHeaders),p){let{[S_]:h,[k_]:g,[T_]:m,[N_]:y,[E_]:x,[D_]:v}=p,w=h;switch(g){case"arraybuffer":w=new TextEncoder().encode(h).buffer;break;case"blob":w=new Blob([h]);break}let T=new sx(m);return Ve(new ix({body:w,headers:T,status:y,statusText:x,url:v}))}return n(t).pipe(kn(h=>{h instanceof ix&&l&&i.set(c,{[S_]:h.body,[T_]:rZ(h.headers,f),[N_]:h.status,[E_]:h.statusText,[D_]:u,[k_]:t.responseType})}))}function nZ(t){return t.headers.has("authorization")||t.headers.has("proxy-authorization")}function rZ(t,n){if(!n)return{};let e={};for(let r of n){let o=t.getAll(r);o!==null&&(e[r]=o)}return e}function A_(t){return[...t.keys()].sort().map(n=>`${n}=${t.getAll(n)}`).join("&")}function oZ(t,n){let{params:e,method:r,responseType:o}=t,s=A_(e),i=t.serializeBody();i instanceof URLSearchParams?i=A_(i):typeof i!="string"&&(i="");let a=[r,o,n,i,s].join("|"),l=sZ(a);return l}function sZ(t){let n=0;for(let e of t)n=Math.imul(31,n)+e.charCodeAt(0)<<0;return n+=2147483648,n.toString()}function __(t){return[{provide:ox,useFactory:()=>(Cp("NgHttpTransferCache"),Se({isCacheActive:!0},t))},{provide:QY,useValue:tZ,multi:!0,deps:[vp,ox]},{provide:Sp,multi:!0,useFactory:()=>{let n=ue(ws),e=ue(ox);return()=>{ex(n).then(()=>{e.isCacheActive=!1})}}}]}function iZ(t,n){let e=new URL(t,"resolve://").origin,r=n[e];return r?t.replace(e,r):t}var zS=class extends tx{constructor(){super(...arguments),this.supportsDOMEvents=!0}},VS=class t extends zS{static makeCurrent(){b_(new t)}onAndCancel(n,e,r){return n.addEventListener(e,r),()=>{n.removeEventListener(e,r)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.remove()}createElement(n,e){return e=e||this.getDefaultDocument(),e.createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return e==="window"?window:e==="document"?n:e==="body"?n.body:null}getBaseHref(n){let e=lZ();return e==null?null:uZ(e)}resetBaseElement(){Yh=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return $S(document.cookie,n)}},Yh=null;function lZ(){return Yh=Yh||document.querySelector("base"),Yh?Yh.getAttribute("href"):null}function uZ(t){return new URL(t,document.baseURI).pathname}var cZ=(()=>{class t{build(){return new XMLHttpRequest}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})(),US=new Be(""),$_=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(o=>{o.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,o){return this._findPluginFor(r).addEventListener(e,r,o)}getZone(){return this._zone}_findPluginFor(e){let r=this._eventNameToPlugin.get(e);if(r)return r;if(r=this._plugins.find(s=>s.supports(e)),!r)throw new Oe(5101,!1);return this._eventNameToPlugin.set(e,r),r}static{this.\u0275fac=function(r){return new(r||t)(st(US),st(dn))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})(),ax=class{constructor(n){this._doc=n}},LS="ng-app-id",P_=(()=>{class t{constructor(e,r,o,s={}){this.doc=e,this.appId=r,this.nonce=o,this.platformId=s,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=Xh(s),this.resetHostNodes()}addStyles(e){for(let r of e)this.changeUsageCount(r,1)===1&&this.onStyleAdded(r)}removeStyles(e){for(let r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){let e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(let r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(let r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(let r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){let r=this.styleRef;r.get(e)?.elements?.forEach(o=>o.remove()),r.delete(e)}collectServerRenderedStyles(){let e=this.doc.head?.querySelectorAll(`style[${LS}="${this.appId}"]`);if(e?.length){let r=new Map;return e.forEach(o=>{o.textContent!=null&&r.set(o.textContent,o)}),r}return null}changeUsageCount(e,r){let o=this.styleRef;if(o.has(e)){let s=o.get(e);return s.usage+=r,s.usage}return o.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){let o=this.styleNodesInDOM,s=o?.get(r);if(s?.parentNode===e)return o.delete(r),s.removeAttribute(LS),s;{let i=this.doc.createElement("style");return this.nonce&&i.setAttribute("nonce",this.nonce),i.textContent=r,this.platformIsServer&&i.setAttribute(LS,this.appId),e.appendChild(i),i}}addStyleToHost(e,r){let o=this.getStyleElement(e,r),s=this.styleRef,i=s.get(r)?.elements;i?i.push(o):s.set(r,{elements:[o],usage:1})}resetHostNodes(){let e=this.hostNodes;e.clear(),e.add(this.doc.head)}static{this.\u0275fac=function(r){return new(r||t)(st(Zr),st(Uy),st(xS,8),st(vs))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})(),BS={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},jS=/%COMP%/g,L_="%COMP%",pZ=`_nghost-${L_}`,fZ=`_ngcontent-${L_}`,dZ=!0,hZ=new Be("",{providedIn:"root",factory:()=>dZ});function mZ(t){return fZ.replace(jS,t)}function gZ(t){return pZ.replace(jS,t)}function B_(t,n){return n.map(e=>e.replace(jS,t))}var O_=(()=>{class t{constructor(e,r,o,s,i,a,l,u=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=o,this.removeStylesOnCompDestroy=s,this.doc=i,this.platformId=a,this.ngZone=l,this.nonce=u,this.rendererByCompId=new Map,this.platformIsServer=Xh(a),this.defaultRenderer=new Zh(e,i,l,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===hs.ShadowDom&&(r=an(Se({},r),{encapsulation:hs.Emulated}));let o=this.getOrCreateRenderer(e,r);return o instanceof lx?o.applyToHost(e):o instanceof Qh&&o.applyStyles(),o}getOrCreateRenderer(e,r){let o=this.rendererByCompId,s=o.get(r.id);if(!s){let i=this.doc,a=this.ngZone,l=this.eventManager,u=this.sharedStylesHost,c=this.removeStylesOnCompDestroy,p=this.platformIsServer;switch(r.encapsulation){case hs.Emulated:s=new lx(l,u,r,this.appId,c,i,a,p);break;case hs.ShadowDom:return new GS(l,u,e,r,i,a,this.nonce,p);default:s=new Qh(l,u,r,c,i,a,p);break}o.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}static{this.\u0275fac=function(r){return new(r||t)(st($_),st(P_),st(Uy),st(hZ),st(Zr),st(vs),st(dn),st(xS))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})(),Zh=class{constructor(n,e,r,o){this.eventManager=n,this.doc=e,this.ngZone=r,this.platformIsServer=o,this.data=Object.create(null),this.throwOnSyntheticProps=!0,this.destroyNode=null}destroy(){}createElement(n,e){return e?this.doc.createElementNS(BS[e]||e,n):this.doc.createElement(n)}createComment(n){return this.doc.createComment(n)}createText(n){return this.doc.createTextNode(n)}appendChild(n,e){(F_(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(F_(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){e.remove()}selectRootElement(n,e){let r=typeof n=="string"?this.doc.querySelector(n):n;if(!r)throw new Oe(-5104,!1);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,o){if(o){e=o+":"+e;let s=BS[o];s?n.setAttributeNS(s,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){let o=BS[r];o?n.removeAttributeNS(o,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,o){o&(ku.DashCase|ku.Important)?n.style.setProperty(e,r,o&ku.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&ku.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n!=null&&(n[e]=r)}setValue(n,e){n.nodeValue=e}listen(n,e,r){if(typeof n=="string"&&(n=Tp().getGlobalEventTarget(this.doc,n),!n))throw new Error(`Unsupported event target ${n} for event ${e}`);return this.eventManager.addEventListener(n,e,this.decoratePreventDefault(r))}decoratePreventDefault(n){return e=>{if(e==="__ngUnwrap__")return n;(this.platformIsServer?this.ngZone.runGuarded(()=>n(e)):n(e))===!1&&e.preventDefault()}}};function F_(t){return t.tagName==="TEMPLATE"&&t.content!==void 0}var GS=class extends Zh{constructor(n,e,r,o,s,i,a,l){super(n,s,i,l),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);let u=B_(o.id,o.styles);for(let c of u){let p=document.createElement("style");a&&p.setAttribute("nonce",a),p.textContent=c,this.shadowRoot.appendChild(p)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(null,e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}},Qh=class extends Zh{constructor(n,e,r,o,s,i,a,l){super(n,s,i,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=o,this.styles=l?B_(l,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}},lx=class extends Qh{constructor(n,e,r,o,s,i,a,l){let u=o+"-"+r.id;super(n,e,r,s,i,a,l,u),this.contentAttr=mZ(u),this.hostAttr=gZ(u)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){let r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}},yZ=(()=>{class t extends ax{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,o){return e.addEventListener(r,o,!1),()=>this.removeEventListener(e,r,o)}removeEventListener(e,r,o){return e.removeEventListener(r,o)}static{this.\u0275fac=function(r){return new(r||t)(st(Zr))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})(),M_=["alt","control","meta","shift"],xZ={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},bZ={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey},vZ=(()=>{class t extends ax{constructor(e){super(e)}supports(e){return t.parseEventName(e)!=null}addEventListener(e,r,o){let s=t.parseEventName(r),i=t.eventCallback(s.fullKey,o,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Tp().onAndCancel(e,s.domEventName,i))}static parseEventName(e){let r=e.toLowerCase().split("."),o=r.shift();if(r.length===0||!(o==="keydown"||o==="keyup"))return null;let s=t._normalizeKey(r.pop()),i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),M_.forEach(u=>{let c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=s,r.length!=0||s.length===0)return null;let l={};return l.domEventName=o,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let o=xZ[e.key]||e.key,s="";return r.indexOf("code.")>-1&&(o=e.code,s="code."),o==null||!o?!1:(o=o.toLowerCase(),o===" "?o="space":o==="."&&(o="dot"),M_.forEach(i=>{if(i!==o){let a=bZ[i];a(e)&&(s+=i+".")}}),s+=o,s===r)}static eventCallback(e,r,o){return s=>{t.matchEventFullKeyCode(s,e)&&o.runGuarded(()=>r(s))}}static _normalizeKey(e){return e==="esc"?"escape":e}static{this.\u0275fac=function(r){return new(r||t)(st(Zr))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac})}}return t})();function z_(t,n){return c_(Se({rootComponent:t},wZ(n)))}function wZ(t){return{appProviders:[...NZ,...t?.providers??[]],platformProviders:TZ}}function CZ(){VS.makeCurrent()}function IZ(){return new ni}function SZ(){return nR(document),document}var TZ=[{provide:vs,useValue:I_},{provide:yS,useValue:CZ,multi:!0},{provide:Zr,useFactory:SZ,deps:[]}];var NZ=[{provide:Fy,useValue:"root"},{provide:ni,useFactory:IZ,deps:[]},{provide:US,useClass:yZ,multi:!0,deps:[Zr,dn,vs]},{provide:US,useClass:vZ,multi:!0,deps:[Zr]},O_,P_,$_,{provide:yp,useExisting:O_},{provide:nx,useClass:cZ,deps:[]},[]];var V_=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}static{this.\u0275fac=function(r){return new(r||t)(st(Zr))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();var WS=function(t){return t[t.NoHttpTransferCache=0]="NoHttpTransferCache",t[t.HttpTransferCacheOptions=1]="HttpTransferCacheOptions",t[t.I18nSupport=2]="I18nSupport",t[t.EventReplay=3]="EventReplay",t}(WS||{});function U_(...t){let n=[],e=new Set,r=e.has(WS.HttpTransferCacheOptions);for(let{\u0275providers:o,\u0275kind:s}of t)e.add(s),o.length&&n.push(o);return Nu([[],p_(),e.has(WS.NoHttpTransferCache)||r?[]:__({}),n])}var Ye="primary",mm=Symbol("RouteTitle"),YS=class{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){let e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){let e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}};function Rp(t){return new YS(t)}function DZ(t,n,e){let r=e.path.split("/");if(r.length>t.length||e.pathMatch==="full"&&(n.hasChildren()||r.length<t.length))return null;let o={};for(let s=0;s<r.length;s++){let i=r[s],a=t[s];if(i[0]===":")o[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:o}}function kZ(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Cs(t[e],n[e]))return!1;return!0}function Cs(t,n){let e=t?ZS(t):void 0,r=n?ZS(n):void 0;if(!e||!r||e.length!=r.length)return!1;let o;for(let s=0;s<e.length;s++)if(o=e[s],!Y_(t[o],n[o]))return!1;return!0}function ZS(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}function Y_(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;let e=[...t].sort(),r=[...n].sort();return e.every((o,s)=>r[s]===o)}else return t===n}function Z_(t){return t.length>0?t[t.length-1]:null}function Ma(t){return X0(t)?t:jh(t)?yn(Promise.resolve(t)):Ve(t)}var AZ={exact:J_,subset:eO},Q_={exact:RZ,subset:_Z,ignored:()=>!0};function G_(t,n,e){return AZ[e.paths](t.root,n.root,e.matrixParams)&&Q_[e.queryParams](t.queryParams,n.queryParams)&&!(e.fragment==="exact"&&t.fragment!==n.fragment)}function RZ(t,n){return Cs(t,n)}function J_(t,n,e){if(!Ou(t.segments,n.segments)||!px(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(let r in n.children)if(!t.children[r]||!J_(t.children[r],n.children[r],e))return!1;return!0}function _Z(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>Y_(t[e],n[e]))}function eO(t,n,e){return tO(t,n,n.segments,e)}function tO(t,n,e,r){if(t.segments.length>e.length){let o=t.segments.slice(0,e.length);return!(!Ou(o,e)||n.hasChildren()||!px(o,e,r))}else if(t.segments.length===e.length){if(!Ou(t.segments,e)||!px(t.segments,e,r))return!1;for(let o in n.children)if(!t.children[o]||!eO(t.children[o],n.children[o],r))return!1;return!0}else{let o=e.slice(0,t.segments.length),s=e.slice(t.segments.length);return!Ou(t.segments,o)||!px(t.segments,o,r)||!t.children[Ye]?!1:tO(t.children[Ye],n,s,r)}}function px(t,n,e){return n.every((r,o)=>Q_[e](t[o].parameters,r.parameters))}var oi=class{constructor(n=new It([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap??=Rp(this.queryParams),this._queryParamMap}toString(){return MZ.serialize(this)}},It=class{constructor(n,e){this.segments=n,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return fx(this)}},_u=class{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap??=Rp(this.parameters),this._parameterMap}toString(){return rO(this)}};function OZ(t,n){return Ou(t,n)&&t.every((e,r)=>Cs(e.parameters,n[r].parameters))}function Ou(t,n){return t.length!==n.length?!1:t.every((e,r)=>e.path===n[r].path)}function FZ(t,n){let e=[];return Object.entries(t.children).forEach(([r,o])=>{r===Ye&&(e=e.concat(n(o,r)))}),Object.entries(t.children).forEach(([r,o])=>{r!==Ye&&(e=e.concat(n(o,r)))}),e}var IT=(()=>{class t{static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>new sm,providedIn:"root"})}}return t})(),sm=class{parse(n){let e=new JS(n);return new oi(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){let e=`/${Jh(n.root,!0)}`,r=LZ(n.queryParams),o=typeof n.fragment=="string"?`#${$Z(n.fragment)}`:"";return`${e}${r}${o}`}},MZ=new sm;function fx(t){return t.segments.map(n=>rO(n)).join("/")}function Jh(t,n){if(!t.hasChildren())return fx(t);if(n){let e=t.children[Ye]?Jh(t.children[Ye],!1):"",r=[];return Object.entries(t.children).forEach(([o,s])=>{o!==Ye&&r.push(`${o}:${Jh(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}else{let e=FZ(t,(r,o)=>o===Ye?[Jh(t.children[Ye],!1)]:[`${o}:${Jh(r,!1)}`]);return Object.keys(t.children).length===1&&t.children[Ye]!=null?`${fx(t)}/${e[0]}`:`${fx(t)}/(${e.join("//")})`}}function nO(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function ux(t){return nO(t).replace(/%3B/gi,";")}function $Z(t){return encodeURI(t)}function QS(t){return nO(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function dx(t){return decodeURIComponent(t)}function W_(t){return dx(t.replace(/\+/g,"%20"))}function rO(t){return`${QS(t.path)}${PZ(t.parameters)}`}function PZ(t){return Object.entries(t).map(([n,e])=>`;${QS(n)}=${QS(e)}`).join("")}function LZ(t){let n=Object.entries(t).map(([e,r])=>Array.isArray(r)?r.map(o=>`${ux(e)}=${ux(o)}`).join("&"):`${ux(e)}=${ux(r)}`).filter(e=>e);return n.length?`?${n.join("&")}`:""}var BZ=/^[^\/()?;#]+/;function HS(t){let n=t.match(BZ);return n?n[0]:""}var zZ=/^[^\/()?;=#]+/;function VZ(t){let n=t.match(zZ);return n?n[0]:""}var UZ=/^[^=?&#]+/;function GZ(t){let n=t.match(UZ);return n?n[0]:""}var WZ=/^[^&#]+/;function jZ(t){let n=t.match(WZ);return n?n[0]:""}var JS=class{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),this.remaining===""||this.peekStartsWith("?")||this.peekStartsWith("#")?new It([],{}):new It([],this.parseChildren())}parseQueryParams(){let n={};if(this.consumeOptional("?"))do this.parseQueryParam(n);while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(this.remaining==="")return{};this.consumeOptional("/");let n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[Ye]=new It(n,e)),r}parseSegment(){let n=HS(this.remaining);if(n===""&&this.peekStartsWith(";"))throw new Oe(4009,!1);return this.capture(n),new _u(dx(n),this.parseMatrixParams())}parseMatrixParams(){let n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){let e=VZ(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let o=HS(this.remaining);o&&(r=o,this.capture(r))}n[dx(e)]=dx(r)}parseQueryParam(n){let e=GZ(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let i=jZ(this.remaining);i&&(r=i,this.capture(r))}let o=W_(e),s=W_(r);if(n.hasOwnProperty(o)){let i=n[o];Array.isArray(i)||(i=[i],n[o]=i),i.push(s)}else n[o]=s}parseParens(n){let e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){let r=HS(this.remaining),o=this.remaining[r.length];if(o!=="/"&&o!==")"&&o!==";")throw new Oe(4010,!1);let s;r.indexOf(":")>-1?(s=r.slice(0,r.indexOf(":")),this.capture(s),this.capture(":")):n&&(s=Ye);let i=this.parseChildren();e[s]=Object.keys(i).length===1?i[Ye]:new It([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return this.peekStartsWith(n)?(this.remaining=this.remaining.substring(n.length),!0):!1}capture(n){if(!this.consumeOptional(n))throw new Oe(4011,!1)}};function oO(t){return t.segments.length>0?new It([],{[Ye]:t}):t}function sO(t){let n={};for(let[r,o]of Object.entries(t.children)){let s=sO(o);if(r===Ye&&s.segments.length===0&&s.hasChildren())for(let[i,a]of Object.entries(s.children))n[i]=a;else(s.segments.length>0||s.hasChildren())&&(n[r]=s)}let e=new It(t.segments,n);return HZ(e)}function HZ(t){if(t.numberOfChildren===1&&t.children[Ye]){let n=t.children[Ye];return new It(t.segments.concat(n.segments),n.children)}return t}function im(t){return t instanceof oi}function qZ(t,n,e=null,r=null){let o=iO(t);return aO(o,n,e,r)}function iO(t){let n;function e(s){let i={};for(let l of s.children){let u=e(l);i[l.outlet]=u}let a=new It(s.url,i);return s===t&&(n=a),a}let r=e(t.root),o=oO(r);return n??o}function aO(t,n,e,r){let o=t;for(;o.parent;)o=o.parent;if(n.length===0)return qS(o,o,o,e,r);let s=KZ(n);if(s.toRoot())return qS(o,o,new It([],{}),e,r);let i=XZ(s,o,t),a=i.processChildren?nm(i.segmentGroup,i.index,s.commands):uO(i.segmentGroup,i.index,s.commands);return qS(o,i.segmentGroup,a,e,r)}function hx(t){return typeof t=="object"&&t!=null&&!t.outlets&&!t.segmentPath}function am(t){return typeof t=="object"&&t!=null&&t.outlets}function qS(t,n,e,r,o){let s={};r&&Object.entries(r).forEach(([l,u])=>{s[l]=Array.isArray(u)?u.map(c=>`${c}`):`${u}`});let i;t===n?i=e:i=lO(t,n,e);let a=oO(sO(i));return new oi(a,s,o)}function lO(t,n,e){let r={};return Object.entries(t.children).forEach(([o,s])=>{s===n?r[o]=e:r[o]=lO(s,n,e)}),new It(t.segments,r)}var mx=class{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&hx(r[0]))throw new Oe(4003,!1);let o=r.find(am);if(o&&o!==Z_(r))throw new Oe(4004,!1)}toRoot(){return this.isAbsolute&&this.commands.length===1&&this.commands[0]=="/"}};function KZ(t){if(typeof t[0]=="string"&&t.length===1&&t[0]==="/")return new mx(!0,0,t);let n=0,e=!1,r=t.reduce((o,s,i)=>{if(typeof s=="object"&&s!=null){if(s.outlets){let a={};return Object.entries(s.outlets).forEach(([l,u])=>{a[l]=typeof u=="string"?u.split("/"):u}),[...o,{outlets:a}]}if(s.segmentPath)return[...o,s.segmentPath]}return typeof s!="string"?[...o,s]:i===0?(s.split("/").forEach((a,l)=>{l==0&&a==="."||(l==0&&a===""?e=!0:a===".."?n++:a!=""&&o.push(a))}),o):[...o,s]},[]);return new mx(e,n,r)}var Dp=class{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}};function XZ(t,n,e){if(t.isAbsolute)return new Dp(n,!0,0);if(!e)return new Dp(n,!1,NaN);if(e.parent===null)return new Dp(e,!0,0);let r=hx(t.commands[0])?0:1,o=e.segments.length-1+r;return YZ(e,o,t.numberOfDoubleDots)}function YZ(t,n,e){let r=t,o=n,s=e;for(;s>o;){if(s-=o,r=r.parent,!r)throw new Oe(4005,!1);o=r.segments.length}return new Dp(r,!1,o-s)}function ZZ(t){return am(t[0])?t[0].outlets:{[Ye]:t}}function uO(t,n,e){if(t??=new It([],{}),t.segments.length===0&&t.hasChildren())return nm(t,n,e);let r=QZ(t,n,e),o=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){let s=new It(t.segments.slice(0,r.pathIndex),{});return s.children[Ye]=new It(t.segments.slice(r.pathIndex),t.children),nm(s,0,o)}else return r.match&&o.length===0?new It(t.segments,{}):r.match&&!t.hasChildren()?eT(t,n,e):r.match?nm(t,0,o):eT(t,n,e)}function nm(t,n,e){if(e.length===0)return new It(t.segments,{});{let r=ZZ(e),o={};if(Object.keys(r).some(s=>s!==Ye)&&t.children[Ye]&&t.numberOfChildren===1&&t.children[Ye].segments.length===0){let s=nm(t.children[Ye],n,e);return new It(t.segments,s.children)}return Object.entries(r).forEach(([s,i])=>{typeof i=="string"&&(i=[i]),i!==null&&(o[s]=uO(t.children[s],n,i))}),Object.entries(t.children).forEach(([s,i])=>{r[s]===void 0&&(o[s]=i)}),new It(t.segments,o)}}function QZ(t,n,e){let r=0,o=n,s={match:!1,pathIndex:0,commandIndex:0};for(;o<t.segments.length;){if(r>=e.length)return s;let i=t.segments[o],a=e[r];if(am(a))break;let l=`${a}`,u=r<e.length-1?e[r+1]:null;if(o>0&&l===void 0)break;if(l&&u&&typeof u=="object"&&u.outlets===void 0){if(!H_(l,u,i))return s;r+=2}else{if(!H_(l,{},i))return s;r++}o++}return{match:!0,pathIndex:o,commandIndex:r}}function eT(t,n,e){let r=t.segments.slice(0,n),o=0;for(;o<e.length;){let s=e[o];if(am(s)){let l=JZ(s.outlets);return new It(r,l)}if(o===0&&hx(e[0])){let l=t.segments[n];r.push(new _u(l.path,j_(e[0]))),o++;continue}let i=am(s)?s.outlets[Ye]:`${s}`,a=o<e.length-1?e[o+1]:null;i&&a&&hx(a)?(r.push(new _u(i,j_(a))),o+=2):(r.push(new _u(i,{})),o++)}return new It(r,{})}function JZ(t){let n={};return Object.entries(t).forEach(([e,r])=>{typeof r=="string"&&(r=[r]),r!==null&&(n[e]=eT(new It([],{}),0,r))}),n}function j_(t){let n={};return Object.entries(t).forEach(([e,r])=>n[e]=`${r}`),n}function H_(t,n,e){return t==e.path&&Cs(n,e.parameters)}var rm="imperative",Xn=function(t){return t[t.NavigationStart=0]="NavigationStart",t[t.NavigationEnd=1]="NavigationEnd",t[t.NavigationCancel=2]="NavigationCancel",t[t.NavigationError=3]="NavigationError",t[t.RoutesRecognized=4]="RoutesRecognized",t[t.ResolveStart=5]="ResolveStart",t[t.ResolveEnd=6]="ResolveEnd",t[t.GuardsCheckStart=7]="GuardsCheckStart",t[t.GuardsCheckEnd=8]="GuardsCheckEnd",t[t.RouteConfigLoadStart=9]="RouteConfigLoadStart",t[t.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",t[t.ChildActivationStart=11]="ChildActivationStart",t[t.ChildActivationEnd=12]="ChildActivationEnd",t[t.ActivationStart=13]="ActivationStart",t[t.ActivationEnd=14]="ActivationEnd",t[t.Scroll=15]="Scroll",t[t.NavigationSkipped=16]="NavigationSkipped",t}(Xn||{}),yo=class{constructor(n,e){this.id=n,this.url=e}},lm=class extends yo{constructor(n,e,r="imperative",o=null){super(n,e),this.type=Xn.NavigationStart,this.navigationTrigger=r,this.restoredState=o}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}},Fu=class extends yo{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=Xn.NavigationEnd}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}},Jr=function(t){return t[t.Redirect=0]="Redirect",t[t.SupersededByNewNavigation=1]="SupersededByNewNavigation",t[t.NoDataFromResolver=2]="NoDataFromResolver",t[t.GuardRejected=3]="GuardRejected",t}(Jr||{}),tT=function(t){return t[t.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",t[t.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",t}(tT||{}),ri=class extends yo{constructor(n,e,r,o){super(n,e),this.reason=r,this.code=o,this.type=Xn.NavigationCancel}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}},Mu=class extends yo{constructor(n,e,r,o){super(n,e),this.reason=r,this.code=o,this.type=Xn.NavigationSkipped}},um=class extends yo{constructor(n,e,r,o){super(n,e),this.error=r,this.target=o,this.type=Xn.NavigationError}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}},gx=class extends yo{constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o,this.type=Xn.RoutesRecognized}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},nT=class extends yo{constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o,this.type=Xn.GuardsCheckStart}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},rT=class extends yo{constructor(n,e,r,o,s){super(n,e),this.urlAfterRedirects=r,this.state=o,this.shouldActivate=s,this.type=Xn.GuardsCheckEnd}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}},oT=class extends yo{constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o,this.type=Xn.ResolveStart}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},sT=class extends yo{constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o,this.type=Xn.ResolveEnd}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},iT=class{constructor(n){this.route=n,this.type=Xn.RouteConfigLoadStart}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}},aT=class{constructor(n){this.route=n,this.type=Xn.RouteConfigLoadEnd}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}},lT=class{constructor(n){this.snapshot=n,this.type=Xn.ChildActivationStart}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},uT=class{constructor(n){this.snapshot=n,this.type=Xn.ChildActivationEnd}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},cT=class{constructor(n){this.snapshot=n,this.type=Xn.ActivationStart}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},pT=class{constructor(n){this.snapshot=n,this.type=Xn.ActivationEnd}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}};var cm=class{},_p=class{constructor(n,e){this.url=n,this.navigationBehaviorOptions=e}};function e9(t,n){return t.providers&&!t._injector&&(t._injector=_S(t.providers,n,`Route: ${t.path}`)),t._injector??n}function Wo(t){return t.outlet||Ye}function t9(t,n){let e=t.filter(r=>Wo(r)===n);return e.push(...t.filter(r=>Wo(r)!==n)),e}function gm(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){let e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}var fT=class{get injector(){return gm(this.route?.snapshot)??this.rootInjector}set injector(n){}constructor(n){this.rootInjector=n,this.outlet=null,this.route=null,this.children=new Ix(this.rootInjector),this.attachRef=null}},Ix=(()=>{class t{constructor(e){this.rootInjector=e,this.contexts=new Map}onChildOutletCreated(e,r){let o=this.getOrCreateContext(e);o.outlet=r,this.contexts.set(e,o)}onChildOutletDestroyed(e){let r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){let e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new fT(this.rootInjector),this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}static{this.\u0275fac=function(r){return new(r||t)(st(ho))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),yx=class{constructor(n){this._root=n}get root(){return this._root.value}parent(n){let e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){let e=dT(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){let e=dT(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){let e=hT(n,this._root);return e.length<2?[]:e[e.length-2].children.map(o=>o.value).filter(o=>o!==n)}pathFromRoot(n){return hT(n,this._root).map(e=>e.value)}};function dT(t,n){if(t===n.value)return n;for(let e of n.children){let r=dT(t,e);if(r)return r}return null}function hT(t,n){if(t===n.value)return[n];for(let e of n.children){let r=hT(t,e);if(r.length)return r.unshift(n),r}return[]}var Qr=class{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}};function Ep(t){let n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}var xx=class extends yx{constructor(n,e){super(n),this.snapshot=e,ST(this,n)}toString(){return this.snapshot.toString()}};function cO(t){let n=n9(t),e=new qn([new _u("",{})]),r=new qn({}),o=new qn({}),s=new qn({}),i=new qn(""),a=new Op(e,r,s,i,o,Ye,t,n.root);return a.snapshot=n.root,new xx(new Qr(a,[]),n)}function n9(t){let n={},e={},r={},o="",s=new kp([],n,r,o,e,Ye,t,null,{});return new vx("",new Qr(s,[]))}var Op=class{constructor(n,e,r,o,s,i,a,l){this.urlSubject=n,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=o,this.dataSubject=s,this.outlet=i,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(nt(u=>u[mm]))??Ve(void 0),this.url=n,this.params=e,this.queryParams=r,this.fragment=o,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe(nt(n=>Rp(n))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe(nt(n=>Rp(n))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}};function bx(t,n,e="emptyOnly"){let r,{routeConfig:o}=t;return n!==null&&(e==="always"||o?.path===""||!n.component&&!n.routeConfig?.loadComponent)?r={params:Se(Se({},n.params),t.params),data:Se(Se({},n.data),t.data),resolve:Se(Se(Se(Se({},t.data),n.data),o?.data),t._resolvedData)}:r={params:Se({},t.params),data:Se({},t.data),resolve:Se(Se({},t.data),t._resolvedData??{})},o&&fO(o)&&(r.resolve[mm]=o.title),r}var kp=class{get title(){return this.data?.[mm]}constructor(n,e,r,o,s,i,a,l,u){this.url=n,this.params=e,this.queryParams=r,this.fragment=o,this.data=s,this.outlet=i,this.component=a,this.routeConfig=l,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=Rp(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=Rp(this.queryParams),this._queryParamMap}toString(){let n=this.url.map(r=>r.toString()).join("/"),e=this.routeConfig?this.routeConfig.path:"";return`Route(url:'${n}', path:'${e}')`}},vx=class extends yx{constructor(n,e){super(e),this.url=n,ST(this,e)}toString(){return pO(this._root)}};function ST(t,n){n.value._routerState=t,n.children.forEach(e=>ST(t,e))}function pO(t){let n=t.children.length>0?` { ${t.children.map(pO).join(", ")} } `:"";return`${t.value}${n}`}function KS(t){if(t.snapshot){let n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Cs(n.queryParams,e.queryParams)||t.queryParamsSubject.next(e.queryParams),n.fragment!==e.fragment&&t.fragmentSubject.next(e.fragment),Cs(n.params,e.params)||t.paramsSubject.next(e.params),kZ(n.url,e.url)||t.urlSubject.next(e.url),Cs(n.data,e.data)||t.dataSubject.next(e.data)}else t.snapshot=t._futureSnapshot,t.dataSubject.next(t._futureSnapshot.data)}function mT(t,n){let e=Cs(t.params,n.params)&&OZ(t.url,n.url),r=!t.parent!=!n.parent;return e&&!r&&(!t.parent||mT(t.parent,n.parent))}function fO(t){return typeof t.title=="string"||t.title===null}var r9=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=Ye,this.activateEvents=new nr,this.deactivateEvents=new nr,this.attachEvents=new nr,this.detachEvents=new nr,this.parentContexts=ue(Ix),this.location=ue(wp),this.changeDetector=ue(Hh),this.inputBinder=ue(TT,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){let{firstChange:r,previousValue:o}=e.name;if(r)return;this.isTrackedInParentContexts(o)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(o)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;let e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Oe(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Oe(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Oe(4012,!1);this.location.detach();let e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){let e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new Oe(4013,!1);this._activatedRoute=e;let o=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new gT(e,a,o.injector);this.activated=o.createComponent(i,{index:o.length,injector:l,environmentInjector:r}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275dir=sS({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Py]})}}return t})(),gT=class t{__ngOutletInjector(n){return new t(this.route,this.childContexts,n)}constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===Op?this.route:n===Ix?this.childContexts:this.parent.get(n,e)}},TT=new Be("");function o9(t,n,e){let r=pm(t,n._root,e?e._root:void 0);return new xx(r,n)}function pm(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){let r=e.value;r._futureSnapshot=n.value;let o=s9(t,n,e);return new Qr(r,o)}else{if(t.shouldAttach(n.value)){let s=t.retrieve(n.value);if(s!==null){let i=s.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>pm(t,a)),i}}let r=i9(n.value),o=n.children.map(s=>pm(t,s));return new Qr(r,o)}}function s9(t,n,e){return n.children.map(r=>{for(let o of e.children)if(t.shouldReuseRoute(r.value,o.value.snapshot))return pm(t,r,o);return pm(t,r)})}function i9(t){return new Op(new qn(t.url),new qn(t.params),new qn(t.queryParams),new qn(t.fragment),new qn(t.data),t.outlet,t.component,t)}var fm=class{constructor(n,e){this.redirectTo=n,this.navigationBehaviorOptions=e}},dO="ngNavigationCancelingError";function wx(t,n){let{redirectTo:e,navigationBehaviorOptions:r}=im(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,o=hO(!1,Jr.Redirect);return o.url=e,o.navigationBehaviorOptions=r,o}function hO(t,n){let e=new Error(`NavigationCancelingError: ${t||""}`);return e[dO]=!0,e.cancellationCode=n,e}function a9(t){return mO(t)&&im(t.url)}function mO(t){return!!t&&t[dO]}var l9=(t,n,e,r)=>nt(o=>(new yT(n,o.targetRouterState,o.currentRouterState,e,r).activate(t),o)),yT=class{constructor(n,e,r,o,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=o,this.inputBindingEnabled=s}activate(n){let e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),KS(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){let o=Ep(e);n.children.forEach(s=>{let i=s.value.outlet;this.deactivateRoutes(s,o[i],r),delete o[i]}),Object.values(o).forEach(s=>{this.deactivateRouteAndItsChildren(s,r)})}deactivateRoutes(n,e,r){let o=n.value,s=e?e.value:null;if(o===s)if(o.component){let i=r.getContext(o.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else s&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){let r=e.getContext(n.value.outlet),o=r&&n.value.component?r.children:e,s=Ep(n);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);if(r&&r.outlet){let i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){let r=e.getContext(n.value.outlet),o=r&&n.value.component?r.children:e,s=Ep(n);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(n,e,r){let o=Ep(e);n.children.forEach(s=>{this.activateRoutes(s,o[s.value.outlet],r),this.forwardEvent(new pT(s.value.snapshot))}),n.children.length&&this.forwardEvent(new uT(n.value.snapshot))}activateRoutes(n,e,r){let o=n.value,s=e?e.value:null;if(KS(o),o===s)if(o.component){let i=r.getOrCreateContext(o.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(o.component){let i=r.getOrCreateContext(o.outlet);if(this.routeReuseStrategy.shouldAttach(o.snapshot)){let a=this.routeReuseStrategy.retrieve(o.snapshot);this.routeReuseStrategy.store(o.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),KS(a.route.value),this.activateChildRoutes(n,null,i.children)}else i.attachRef=null,i.route=o,i.outlet&&i.outlet.activateWith(o,i.injector),this.activateChildRoutes(n,null,i.children)}else this.activateChildRoutes(n,null,r)}},Cx=class{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}},Ap=class{constructor(n,e){this.component=n,this.route=e}};function u9(t,n,e){let r=t._root,o=n?n._root:null;return em(r,o,e,[r.value])}function c9(t){let n=t.routeConfig?t.routeConfig.canActivateChild:null;return!n||n.length===0?null:{node:t,guards:n}}function Mp(t,n){let e=Symbol(),r=n.get(t,e);return r===e?typeof t=="function"&&!Wk(t)?t:n.get(t):r}function em(t,n,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=Ep(n);return t.children.forEach(i=>{p9(i,s[i.value.outlet],e,r.concat([i.value]),o),delete s[i.value.outlet]}),Object.entries(s).forEach(([i,a])=>om(a,e.getContext(i),o)),o}function p9(t,n,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&s.routeConfig===i.routeConfig){let l=f9(i,s,s.routeConfig.runGuardsAndResolvers);l?o.canActivateChecks.push(new Cx(r)):(s.data=i.data,s._resolvedData=i._resolvedData),s.component?em(t,n,a?a.children:null,r,o):em(t,n,e,r,o),l&&a&&a.outlet&&a.outlet.isActivated&&o.canDeactivateChecks.push(new Ap(a.outlet.component,i))}else i&&om(n,a,o),o.canActivateChecks.push(new Cx(r)),s.component?em(t,null,a?a.children:null,r,o):em(t,null,e,r,o);return o}function f9(t,n,e){if(typeof e=="function")return e(t,n);switch(e){case"pathParamsChange":return!Ou(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Ou(t.url,n.url)||!Cs(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!mT(t,n)||!Cs(t.queryParams,n.queryParams);case"paramsChange":default:return!mT(t,n)}}function om(t,n,e){let r=Ep(t),o=t.value;Object.entries(r).forEach(([s,i])=>{o.component?n?om(i,n.children.getContext(s),e):om(i,null,e):om(i,n,e)}),o.component?n&&n.outlet&&n.outlet.isActivated?e.canDeactivateChecks.push(new Ap(n.outlet.component,o)):e.canDeactivateChecks.push(new Ap(null,o)):e.canDeactivateChecks.push(new Ap(null,o))}function ym(t){return typeof t=="function"}function d9(t){return typeof t=="boolean"}function h9(t){return t&&ym(t.canLoad)}function m9(t){return t&&ym(t.canActivate)}function g9(t){return t&&ym(t.canActivateChild)}function y9(t){return t&&ym(t.canDeactivate)}function x9(t){return t&&ym(t.canMatch)}function gO(t){return t instanceof Xs||t?.name==="EmptyError"}var cx=Symbol("INITIAL_VALUE");function Fp(){return uo(t=>Qg(t.map(n=>n.pipe(Ys(1),eI(cx)))).pipe(nt(n=>{for(let e of n)if(e!==!0){if(e===cx)return cx;if(e===!1||b9(e))return e}return!0}),lo(n=>n!==cx),Ys(1)))}function b9(t){return im(t)||t instanceof fm}function v9(t,n){return Dn(e=>{let{targetSnapshot:r,currentSnapshot:o,guards:{canActivateChecks:s,canDeactivateChecks:i}}=e;return i.length===0&&s.length===0?Ve(an(Se({},e),{guardsResult:!0})):w9(i,r,o,t).pipe(Dn(a=>a&&d9(a)?C9(r,s,t,n):Ve(a)),nt(a=>an(Se({},e),{guardsResult:a})))})}function w9(t,n,e,r){return yn(t).pipe(Dn(o=>E9(o.component,o.route,e,n,r)),zo(o=>o!==!0,!0))}function C9(t,n,e,r){return yn(n).pipe(yu(o=>np(S9(o.route.parent,r),I9(o.route,r),N9(t,o.path,e),T9(t,o.route,e))),zo(o=>o!==!0,!0))}function I9(t,n){return t!==null&&n&&n(new cT(t)),Ve(!0)}function S9(t,n){return t!==null&&n&&n(new lT(t)),Ve(!0)}function T9(t,n,e){let r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||r.length===0)return Ve(!0);let o=r.map(s=>Jg(()=>{let i=gm(n)??e,a=Mp(s,i),l=m9(a)?a.canActivate(n,t):gs(i,()=>a(n,t));return Ma(l).pipe(zo())}));return Ve(o).pipe(Fp())}function N9(t,n,e){let r=n[n.length-1],s=n.slice(0,n.length-1).reverse().map(i=>c9(i)).filter(i=>i!==null).map(i=>Jg(()=>{let a=i.guards.map(l=>{let u=gm(i.node)??e,c=Mp(l,u),p=g9(c)?c.canActivateChild(r,t):gs(u,()=>c(r,t));return Ma(p).pipe(zo())});return Ve(a).pipe(Fp())}));return Ve(s).pipe(Fp())}function E9(t,n,e,r,o){let s=n&&n.routeConfig?n.routeConfig.canDeactivate:null;if(!s||s.length===0)return Ve(!0);let i=s.map(a=>{let l=gm(n)??o,u=Mp(a,l),c=y9(u)?u.canDeactivate(t,n,e,r):gs(l,()=>u(t,n,e,r));return Ma(c).pipe(zo())});return Ve(i).pipe(Fp())}function D9(t,n,e,r){let o=n.canLoad;if(o===void 0||o.length===0)return Ve(!0);let s=o.map(i=>{let a=Mp(i,t),l=h9(a)?a.canLoad(n,e):gs(t,()=>a(n,e));return Ma(l)});return Ve(s).pipe(Fp(),yO(r))}function yO(t){return j0(kn(n=>{if(typeof n!="boolean")throw wx(t,n)}),nt(n=>n===!0))}function k9(t,n,e,r){let o=n.canMatch;if(!o||o.length===0)return Ve(!0);let s=o.map(i=>{let a=Mp(i,t),l=x9(a)?a.canMatch(n,e):gs(t,()=>a(n,e));return Ma(l)});return Ve(s).pipe(Fp(),yO(r))}var dm=class{constructor(n){this.segmentGroup=n||null}},hm=class extends Error{constructor(n){super(),this.urlTree=n}};function Np(t){return tp(new dm(t))}function A9(t){return tp(new Oe(4e3,!1))}function R9(t){return tp(hO(!1,Jr.GuardRejected))}var xT=class{constructor(n,e){this.urlSerializer=n,this.urlTree=e}lineralizeSegments(n,e){let r=[],o=e.root;for(;;){if(r=r.concat(o.segments),o.numberOfChildren===0)return Ve(r);if(o.numberOfChildren>1||!o.children[Ye])return A9(`${n.redirectTo}`);o=o.children[Ye]}}applyRedirectCommands(n,e,r,o,s){if(typeof e!="string"){let a=e,{queryParams:l,fragment:u,routeConfig:c,url:p,outlet:f,params:d,data:h,title:g}=o,m=gs(s,()=>a({params:d,data:h,queryParams:l,fragment:u,routeConfig:c,url:p,outlet:f,title:g}));if(m instanceof oi)throw new hm(m);e=m}let i=this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r);if(e[0]==="/")throw new hm(i);return i}applyRedirectCreateUrlTree(n,e,r,o){let s=this.createSegmentGroup(n,e.root,r,o);return new oi(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){let r={};return Object.entries(n).forEach(([o,s])=>{if(typeof s=="string"&&s[0]===":"){let a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,o){let s=this.createSegments(n,e.segments,r,o),i={};return Object.entries(e.children).forEach(([a,l])=>{i[a]=this.createSegmentGroup(n,l,r,o)}),new It(s,i)}createSegments(n,e,r,o){return e.map(s=>s.path[0]===":"?this.findPosParam(n,s,o):this.findOrReturn(s,r))}findPosParam(n,e,r){let o=r[e.path.substring(1)];if(!o)throw new Oe(4001,!1);return o}findOrReturn(n,e){let r=0;for(let o of e){if(o.path===n.path)return e.splice(r),o;r++}return n}},bT={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function _9(t,n,e,r,o){let s=xO(t,n,e);return s.matched?(r=e9(n,r),k9(r,n,e,o).pipe(nt(i=>i===!0?s:Se({},bT)))):Ve(s)}function xO(t,n,e){if(n.path==="**")return O9(e);if(n.path==="")return n.pathMatch==="full"&&(t.hasChildren()||e.length>0)?Se({},bT):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};let o=(n.matcher||DZ)(e,t,n);if(!o)return Se({},bT);let s={};Object.entries(o.posParams??{}).forEach(([a,l])=>{s[a]=l.path});let i=o.consumed.length>0?Se(Se({},s),o.consumed[o.consumed.length-1].parameters):s;return{matched:!0,consumedSegments:o.consumed,remainingSegments:e.slice(o.consumed.length),parameters:i,positionalParamSegments:o.posParams??{}}}function O9(t){return{matched:!0,parameters:t.length>0?Z_(t).parameters:{},consumedSegments:t,remainingSegments:[],positionalParamSegments:{}}}function q_(t,n,e,r){return e.length>0&&$9(t,e,r)?{segmentGroup:new It(n,M9(r,new It(e,t.children))),slicedSegments:[]}:e.length===0&&P9(t,e,r)?{segmentGroup:new It(t.segments,F9(t,e,r,t.children)),slicedSegments:e}:{segmentGroup:new It(t.segments,t.children),slicedSegments:e}}function F9(t,n,e,r){let o={};for(let s of e)if(Sx(t,n,s)&&!r[Wo(s)]){let i=new It([],{});o[Wo(s)]=i}return Se(Se({},r),o)}function M9(t,n){let e={};e[Ye]=n;for(let r of t)if(r.path===""&&Wo(r)!==Ye){let o=new It([],{});e[Wo(r)]=o}return e}function $9(t,n,e){return e.some(r=>Sx(t,n,r)&&Wo(r)!==Ye)}function P9(t,n,e){return e.some(r=>Sx(t,n,r))}function Sx(t,n,e){return(t.hasChildren()||n.length>0)&&e.pathMatch==="full"?!1:e.path===""}function L9(t,n,e){return n.length===0&&!t.children[e]}var vT=class{};function B9(t,n,e,r,o,s,i="emptyOnly"){return new wT(t,n,e,r,o,i,s).recognize()}var z9=31,wT=class{constructor(n,e,r,o,s,i,a){this.injector=n,this.configLoader=e,this.rootComponentType=r,this.config=o,this.urlTree=s,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.applyRedirects=new xT(this.urlSerializer,this.urlTree),this.absoluteRedirectCount=0,this.allowRedirects=!0}noMatchError(n){return new Oe(4002,`'${n.segmentGroup}'`)}recognize(){let n=q_(this.urlTree.root,[],[],this.config).segmentGroup;return this.match(n).pipe(nt(({children:e,rootSnapshot:r})=>{let o=new Qr(r,e),s=new vx("",o),i=qZ(r,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(i),{state:s,tree:i}}))}match(n){let e=new kp([],Object.freeze({}),Object.freeze(Se({},this.urlTree.queryParams)),this.urlTree.fragment,Object.freeze({}),Ye,this.rootComponentType,null,{});return this.processSegmentGroup(this.injector,this.config,n,Ye,e).pipe(nt(r=>({children:r,rootSnapshot:e})),Na(r=>{if(r instanceof hm)return this.urlTree=r.urlTree,this.match(r.urlTree.root);throw r instanceof dm?this.noMatchError(r):r}))}processSegmentGroup(n,e,r,o,s){return r.segments.length===0&&r.hasChildren()?this.processChildren(n,e,r,s):this.processSegment(n,e,r,r.segments,o,!0,s).pipe(nt(i=>i instanceof Qr?[i]:[]))}processChildren(n,e,r,o){let s=[];for(let i of Object.keys(r.children))i==="primary"?s.unshift(i):s.push(i);return yn(s).pipe(yu(i=>{let a=r.children[i],l=t9(e,i);return this.processSegmentGroup(n,l,a,i,o)}),J0((i,a)=>(i.push(...a),i)),Ea(null),Q0(),Dn(i=>{if(i===null)return Np(r);let a=bO(i);return V9(a),Ve(a)}))}processSegment(n,e,r,o,s,i,a){return yn(e).pipe(yu(l=>this.processSegmentAgainstRoute(l._injector??n,e,l,r,o,s,i,a).pipe(Na(u=>{if(u instanceof dm)return Ve(null);throw u}))),zo(l=>!!l),Na(l=>{if(gO(l))return L9(r,o,s)?Ve(new vT):Np(r);throw l}))}processSegmentAgainstRoute(n,e,r,o,s,i,a,l){return Wo(r)!==i&&(i===Ye||!Sx(o,s,r))?Np(o):r.redirectTo===void 0?this.matchSegmentAgainstRoute(n,o,r,s,i,l):this.allowRedirects&&a?this.expandSegmentAgainstRouteUsingRedirect(n,o,e,r,s,i,l):Np(o)}expandSegmentAgainstRouteUsingRedirect(n,e,r,o,s,i,a){let{matched:l,parameters:u,consumedSegments:c,positionalParamSegments:p,remainingSegments:f}=xO(e,o,s);if(!l)return Np(e);typeof o.redirectTo=="string"&&o.redirectTo[0]==="/"&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>z9&&(this.allowRedirects=!1));let d=new kp(s,u,Object.freeze(Se({},this.urlTree.queryParams)),this.urlTree.fragment,K_(o),Wo(o),o.component??o._loadedComponent??null,o,X_(o)),h=bx(d,a,this.paramsInheritanceStrategy);d.params=Object.freeze(h.params),d.data=Object.freeze(h.data);let g=this.applyRedirects.applyRedirectCommands(c,o.redirectTo,p,d,n);return this.applyRedirects.lineralizeSegments(o,g).pipe(Dn(m=>this.processSegment(n,r,e,m.concat(f),i,!1,a)))}matchSegmentAgainstRoute(n,e,r,o,s,i){let a=_9(e,r,o,n,this.urlSerializer);return r.path==="**"&&(e.children={}),a.pipe(uo(l=>l.matched?(n=r._injector??n,this.getChildConfig(n,r,o).pipe(uo(({routes:u})=>{let c=r._loadedInjector??n,{parameters:p,consumedSegments:f,remainingSegments:d}=l,h=new kp(f,p,Object.freeze(Se({},this.urlTree.queryParams)),this.urlTree.fragment,K_(r),Wo(r),r.component??r._loadedComponent??null,r,X_(r)),g=bx(h,i,this.paramsInheritanceStrategy);h.params=Object.freeze(g.params),h.data=Object.freeze(g.data);let{segmentGroup:m,slicedSegments:y}=q_(e,f,d,u);if(y.length===0&&m.hasChildren())return this.processChildren(c,u,m,h).pipe(nt(v=>new Qr(h,v)));if(u.length===0&&y.length===0)return Ve(new Qr(h,[]));let x=Wo(r)===s;return this.processSegment(c,u,m,y,x?Ye:s,!0,h).pipe(nt(v=>new Qr(h,v instanceof Qr?[v]:[])))}))):Np(e)))}getChildConfig(n,e,r){return e.children?Ve({routes:e.children,injector:n}):e.loadChildren?e._loadedRoutes!==void 0?Ve({routes:e._loadedRoutes,injector:e._loadedInjector}):D9(n,e,r,this.urlSerializer).pipe(Dn(o=>o?this.configLoader.loadChildren(n,e).pipe(kn(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):R9(e))):Ve({routes:[],injector:n})}};function V9(t){t.sort((n,e)=>n.value.outlet===Ye?-1:e.value.outlet===Ye?1:n.value.outlet.localeCompare(e.value.outlet))}function U9(t){let n=t.value.routeConfig;return n&&n.path===""}function bO(t){let n=[],e=new Set;for(let r of t){if(!U9(r)){n.push(r);continue}let o=n.find(s=>r.value.routeConfig===s.value.routeConfig);o!==void 0?(o.children.push(...r.children),e.add(o)):n.push(r)}for(let r of e){let o=bO(r.children);n.push(new Qr(r.value,o))}return n.filter(r=>!e.has(r))}function K_(t){return t.data||{}}function X_(t){return t.resolve||{}}function G9(t,n,e,r,o,s){return Dn(i=>B9(t,n,e,r,i.extractedUrl,o,s).pipe(nt(({state:a,tree:l})=>an(Se({},i),{targetSnapshot:a,urlAfterRedirects:l}))))}function W9(t,n){return Dn(e=>{let{targetSnapshot:r,guards:{canActivateChecks:o}}=e;if(!o.length)return Ve(e);let s=new Set(o.map(l=>l.route)),i=new Set;for(let l of s)if(!i.has(l))for(let u of vO(l))i.add(u);let a=0;return yn(i).pipe(yu(l=>s.has(l)?j9(l,r,t,n):(l.data=bx(l,l.parent,t).resolve,Ve(void 0))),kn(()=>a++),op(1),Dn(l=>a===i.size?Ve(e):Kr))})}function vO(t){let n=t.children.map(e=>vO(e)).flat();return[t,...n]}function j9(t,n,e,r){let o=t.routeConfig,s=t._resolve;return o?.title!==void 0&&!fO(o)&&(s[mm]=o.title),H9(s,t,n,r).pipe(nt(i=>(t._resolvedData=i,t.data=bx(t,t.parent,e).resolve,null)))}function H9(t,n,e,r){let o=ZS(t);if(o.length===0)return Ve({});let s={};return yn(o).pipe(Dn(i=>q9(t[i],n,e,r).pipe(zo(),kn(a=>{if(a instanceof fm)throw wx(new sm,a);s[i]=a}))),op(1),Z0(s),Na(i=>gO(i)?Kr:tp(i)))}function q9(t,n,e,r){let o=gm(n)??r,s=Mp(t,o),i=s.resolve?s.resolve(n,e):gs(o,()=>s(n,e));return Ma(i)}function XS(t){return uo(n=>{let e=t(n);return e?yn(e).pipe(nt(()=>n)):Ve(n)})}var wO=(()=>{class t{buildTitle(e){let r,o=e.root;for(;o!==void 0;)r=this.getResolvedTitleForRoute(o)??r,o=o.children.find(s=>s.outlet===Ye);return r}getResolvedTitleForRoute(e){return e.data[mm]}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(K9),providedIn:"root"})}}return t})(),K9=(()=>{class t extends wO{constructor(e){super(),this.title=e}updateTitle(e){let r=this.buildTitle(e);r!==void 0&&this.title.setTitle(r)}static{this.\u0275fac=function(r){return new(r||t)(st(V_))}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),NT=new Be("",{providedIn:"root",factory:()=>({})}),X9=(()=>{class t{static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275cmp=xp({type:t,selectors:[["ng-component"]],standalone:!0,features:[Ip],decls:1,vars:0,template:function(r,o){r&1&&Au(0,"router-outlet")},dependencies:[r9],encapsulation:2})}}return t})();function ET(t){let n=t.children&&t.children.map(ET),e=n?an(Se({},t),{children:n}):Se({},t);return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==Ye&&(e.component=X9),e}var DT=new Be(""),Y9=(()=>{class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=ue(FS)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Ve(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);let r=Ma(e.loadComponent()).pipe(nt(CO),kn(s=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=s}),rp(()=>{this.componentLoaders.delete(e)})),o=new ep(r,()=>new gr).pipe(Jc());return this.componentLoaders.set(e,o),o}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Ve({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);let s=Z9(r,this.compiler,e,this.onLoadEndListener).pipe(rp(()=>{this.childrenLoaders.delete(r)})),i=new ep(s,()=>new gr).pipe(Jc());return this.childrenLoaders.set(r,i),i}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();function Z9(t,n,e,r){return Ma(t.loadChildren()).pipe(nt(CO),Dn(o=>o instanceof Lh||Array.isArray(o)?Ve(o):yn(n.compileModuleAsync(o))),nt(o=>{r&&r(t);let s,i,a=!1;return Array.isArray(o)?(i=o,a=!0):(s=o.create(e).injector,i=s.get(DT,[],{optional:!0,self:!0}).flat()),{routes:i.map(ET),injector:s}}))}function Q9(t){return t&&typeof t=="object"&&"default"in t}function CO(t){return Q9(t)?t.default:t}var kT=(()=>{class t{static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(J9),providedIn:"root"})}}return t})(),J9=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),e7=new Be("");var t7=new Be(""),n7=(()=>{class t{get hasRequestedNavigation(){return this.navigationId!==0}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new gr,this.transitionAbortSubject=new gr,this.configLoader=ue(Y9),this.environmentInjector=ue(ho),this.urlSerializer=ue(IT),this.rootContexts=ue(Ix),this.location=ue(Kh),this.inputBindingEnabled=ue(TT,{optional:!0})!==null,this.titleStrategy=ue(wO),this.options=ue(NT,{optional:!0})||{},this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlHandlingStrategy=ue(kT),this.createViewTransition=ue(e7,{optional:!0}),this.navigationErrorHandler=ue(t7,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>Ve(void 0),this.rootComponentType=null;let e=o=>this.events.next(new iT(o)),r=o=>this.events.next(new aT(o));this.configLoader.onLoadEndListener=r,this.configLoader.onLoadStartListener=e}complete(){this.transitions?.complete()}handleNavigationRequest(e){let r=++this.navigationId;this.transitions?.next(an(Se(Se({},this.transitions.value),e),{id:r}))}setupNavigations(e,r,o){return this.transitions=new qn({id:0,currentUrlTree:r,currentRawUrl:r,extractedUrl:this.urlHandlingStrategy.extract(r),urlAfterRedirects:this.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:()=>{},reject:()=>{},promise:Promise.resolve(!0),source:rm,restoredState:null,currentSnapshot:o.snapshot,targetSnapshot:null,currentRouterState:o,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(lo(s=>s.id!==0),nt(s=>an(Se({},s),{extractedUrl:this.urlHandlingStrategy.extract(s.rawUrl)})),uo(s=>{let i=!1,a=!1;return Ve(s).pipe(uo(l=>{if(this.navigationId>s.id)return this.cancelNavigationTransition(s,"",Jr.SupersededByNewNavigation),Kr;this.currentTransition=s,this.currentNavigation={id:l.id,initialUrl:l.rawUrl,extractedUrl:l.extractedUrl,targetBrowserUrl:typeof l.extras.browserUrl=="string"?this.urlSerializer.parse(l.extras.browserUrl):l.extras.browserUrl,trigger:l.source,extras:l.extras,previousNavigation:this.lastSuccessfulNavigation?an(Se({},this.lastSuccessfulNavigation),{previousNavigation:null}):null};let u=!e.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl(),c=l.extras.onSameUrlNavigation??e.onSameUrlNavigation;if(!u&&c!=="reload"){let p="";return this.events.next(new Mu(l.id,this.urlSerializer.serialize(l.rawUrl),p,tT.IgnoredSameUrlNavigation)),l.resolve(!1),Kr}if(this.urlHandlingStrategy.shouldProcessUrl(l.rawUrl))return Ve(l).pipe(uo(p=>{let f=this.transitions?.getValue();return this.events.next(new lm(p.id,this.urlSerializer.serialize(p.extractedUrl),p.source,p.restoredState)),f!==this.transitions?.getValue()?Kr:Promise.resolve(p)}),G9(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,this.paramsInheritanceStrategy),kn(p=>{s.targetSnapshot=p.targetSnapshot,s.urlAfterRedirects=p.urlAfterRedirects,this.currentNavigation=an(Se({},this.currentNavigation),{finalUrl:p.urlAfterRedirects});let f=new gx(p.id,this.urlSerializer.serialize(p.extractedUrl),this.urlSerializer.serialize(p.urlAfterRedirects),p.targetSnapshot);this.events.next(f)}));if(u&&this.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)){let{id:p,extractedUrl:f,source:d,restoredState:h,extras:g}=l,m=new lm(p,this.urlSerializer.serialize(f),d,h);this.events.next(m);let y=cO(this.rootComponentType).snapshot;return this.currentTransition=s=an(Se({},l),{targetSnapshot:y,urlAfterRedirects:f,extras:an(Se({},g),{skipLocationChange:!1,replaceUrl:!1})}),this.currentNavigation.finalUrl=f,Ve(s)}else{let p="";return this.events.next(new Mu(l.id,this.urlSerializer.serialize(l.extractedUrl),p,tT.IgnoredByUrlHandlingStrategy)),l.resolve(!1),Kr}}),kn(l=>{let u=new nT(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);this.events.next(u)}),nt(l=>(this.currentTransition=s=an(Se({},l),{guards:u9(l.targetSnapshot,l.currentSnapshot,this.rootContexts)}),s)),v9(this.environmentInjector,l=>this.events.next(l)),kn(l=>{if(s.guardsResult=l.guardsResult,l.guardsResult&&typeof l.guardsResult!="boolean")throw wx(this.urlSerializer,l.guardsResult);let u=new rT(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot,!!l.guardsResult);this.events.next(u)}),lo(l=>l.guardsResult?!0:(this.cancelNavigationTransition(l,"",Jr.GuardRejected),!1)),XS(l=>{if(l.guards.canActivateChecks.length)return Ve(l).pipe(kn(u=>{let c=new oT(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),uo(u=>{let c=!1;return Ve(u).pipe(W9(this.paramsInheritanceStrategy,this.environmentInjector),kn({next:()=>c=!0,complete:()=>{c||this.cancelNavigationTransition(u,"",Jr.NoDataFromResolver)}}))}),kn(u=>{let c=new sT(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}))}),XS(l=>{let u=c=>{let p=[];c.routeConfig?.loadComponent&&!c.routeConfig._loadedComponent&&p.push(this.configLoader.loadComponent(c.routeConfig).pipe(kn(f=>{c.component=f}),nt(()=>{})));for(let f of c.children)p.push(...u(f));return p};return Qg(u(l.targetSnapshot.root)).pipe(Ea(null),Ys(1))}),XS(()=>this.afterPreactivation()),uo(()=>{let{currentSnapshot:l,targetSnapshot:u}=s,c=this.createViewTransition?.(this.environmentInjector,l.root,u.root);return c?yn(c).pipe(nt(()=>s)):Ve(s)}),nt(l=>{let u=o9(e.routeReuseStrategy,l.targetSnapshot,l.currentRouterState);return this.currentTransition=s=an(Se({},l),{targetRouterState:u}),this.currentNavigation.targetRouterState=u,s}),kn(()=>{this.events.next(new cm)}),l9(this.rootContexts,e.routeReuseStrategy,l=>this.events.next(l),this.inputBindingEnabled),Ys(1),kn({next:l=>{i=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Fu(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects))),this.titleStrategy?.updateTitle(l.targetRouterState.snapshot),l.resolve(!0)},complete:()=>{i=!0}}),tI(this.transitionAbortSubject.pipe(kn(l=>{throw l}))),rp(()=>{!i&&!a&&this.cancelNavigationTransition(s,"",Jr.SupersededByNewNavigation),this.currentTransition?.id===s.id&&(this.currentNavigation=null,this.currentTransition=null)}),Na(l=>{if(a=!0,mO(l))this.events.next(new ri(s.id,this.urlSerializer.serialize(s.extractedUrl),l.message,l.cancellationCode)),a9(l)?this.events.next(new _p(l.url,l.navigationBehaviorOptions)):s.resolve(!1);else{let u=new um(s.id,this.urlSerializer.serialize(s.extractedUrl),l,s.targetSnapshot??void 0);try{let c=gs(this.environmentInjector,()=>this.navigationErrorHandler?.(u));if(c instanceof fm){let{message:p,cancellationCode:f}=wx(this.urlSerializer,c);this.events.next(new ri(s.id,this.urlSerializer.serialize(s.extractedUrl),p,f)),this.events.next(new _p(c.redirectTo,c.navigationBehaviorOptions))}else{this.events.next(u);let p=e.errorHandler(l);s.resolve(!!p)}}catch(c){this.options.resolveNavigationPromiseOnError?s.resolve(!1):s.reject(c)}}return Kr}))}))}cancelNavigationTransition(e,r,o){let s=new ri(e.id,this.urlSerializer.serialize(e.extractedUrl),r,o);this.events.next(s),e.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){let e=this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))),r=this.currentNavigation?.targetBrowserUrl??this.currentNavigation?.extractedUrl;return e.toString()!==r?.toString()&&!this.currentNavigation?.extras.skipLocationChange}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();function r7(t){return t!==rm}var o7=(()=>{class t{static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(s7),providedIn:"root"})}}return t})(),CT=class{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}},s7=(()=>{class t extends CT{static{this.\u0275fac=(()=>{let e;return function(o){return(e||(e=hS(t)))(o||t)}})()}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),IO=(()=>{class t{static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:()=>ue(i7),providedIn:"root"})}}return t})(),i7=(()=>{class t extends IO{constructor(){super(...arguments),this.location=ue(Kh),this.urlSerializer=ue(IT),this.options=ue(NT,{optional:!0})||{},this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.urlHandlingStrategy=ue(kT),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.currentUrlTree=new oi,this.rawUrlTree=this.currentUrlTree,this.currentPageId=0,this.lastSuccessfulId=-1,this.routerState=cO(null),this.stateMemento=this.createStateMemento()}getCurrentUrlTree(){return this.currentUrlTree}getRawUrlTree(){return this.rawUrlTree}restoredState(){return this.location.getState()}get browserPageId(){return this.canceledNavigationResolution!=="computed"?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}getRouterState(){return this.routerState}createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}registerNonRouterCurrentEntryChangeListener(e){return this.location.subscribe(r=>{r.type==="popstate"&&e(r.url,r.state)})}handleRouterEvent(e,r){if(e instanceof lm)this.stateMemento=this.createStateMemento();else if(e instanceof Mu)this.rawUrlTree=r.initialUrl;else if(e instanceof gx){if(this.urlUpdateStrategy==="eager"&&!r.extras.skipLocationChange){let o=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl);this.setBrowserUrl(r.targetBrowserUrl??o,r)}}else e instanceof cm?(this.currentUrlTree=r.finalUrl,this.rawUrlTree=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl),this.routerState=r.targetRouterState,this.urlUpdateStrategy==="deferred"&&!r.extras.skipLocationChange&&this.setBrowserUrl(r.targetBrowserUrl??this.rawUrlTree,r)):e instanceof ri&&(e.code===Jr.GuardRejected||e.code===Jr.NoDataFromResolver)?this.restoreHistory(r):e instanceof um?this.restoreHistory(r,!0):e instanceof Fu&&(this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId)}setBrowserUrl(e,r){let o=e instanceof oi?this.urlSerializer.serialize(e):e;if(this.location.isCurrentPathEqualTo(o)||r.extras.replaceUrl){let s=this.browserPageId,i=Se(Se({},r.extras.state),this.generateNgRouterState(r.id,s));this.location.replaceState(o,"",i)}else{let s=Se(Se({},r.extras.state),this.generateNgRouterState(r.id,this.browserPageId+1));this.location.go(o,"",s)}}restoreHistory(e,r=!1){if(this.canceledNavigationResolution==="computed"){let o=this.browserPageId,s=this.currentPageId-o;s!==0?this.location.historyGo(s):this.currentUrlTree===e.finalUrl&&s===0&&(this.resetState(e),this.resetUrlToCurrentUrlTree())}else this.canceledNavigationResolution==="replace"&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.finalUrl??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return this.canceledNavigationResolution==="computed"?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}static{this.\u0275fac=(()=>{let e;return function(o){return(e||(e=hS(t)))(o||t)}})()}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})(),tm=function(t){return t[t.COMPLETE=0]="COMPLETE",t[t.FAILED=1]="FAILED",t[t.REDIRECTING=2]="REDIRECTING",t}(tm||{});function a7(t,n){t.events.pipe(lo(e=>e instanceof Fu||e instanceof ri||e instanceof um||e instanceof Mu),nt(e=>e instanceof Fu||e instanceof Mu?tm.COMPLETE:(e instanceof ri?e.code===Jr.Redirect||e.code===Jr.SupersededByNewNavigation:!1)?tm.REDIRECTING:tm.FAILED),lo(e=>e!==tm.REDIRECTING),Ys(1)).subscribe(()=>{n()})}function l7(t){throw t}var u7={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},c7={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"},SO=(()=>{class t{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}constructor(){this.disposed=!1,this.console=ue(Jy),this.stateManager=ue(IO),this.options=ue(NT,{optional:!0})||{},this.pendingTasks=ue(Eu),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.navigationTransitions=ue(n7),this.urlSerializer=ue(IT),this.location=ue(Kh),this.urlHandlingStrategy=ue(kT),this._events=new gr,this.errorHandler=this.options.errorHandler||l7,this.navigated=!1,this.routeReuseStrategy=ue(o7),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.config=ue(DT,{optional:!0})?.flat()??[],this.componentInputBindingEnabled=!!ue(TT,{optional:!0}),this.eventsSubscription=new gn,this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe({error:e=>{this.console.warn(e)}}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){let e=this.navigationTransitions.events.subscribe(r=>{try{let o=this.navigationTransitions.currentTransition,s=this.navigationTransitions.currentNavigation;if(o!==null&&s!==null){if(this.stateManager.handleRouterEvent(r,s),r instanceof ri&&r.code!==Jr.Redirect&&r.code!==Jr.SupersededByNewNavigation)this.navigated=!0;else if(r instanceof Fu)this.navigated=!0;else if(r instanceof _p){let i=r.navigationBehaviorOptions,a=this.urlHandlingStrategy.merge(r.url,o.currentRawUrl),l=Se({browserUrl:o.extras.browserUrl,info:o.extras.info,skipLocationChange:o.extras.skipLocationChange,replaceUrl:o.extras.replaceUrl||this.urlUpdateStrategy==="eager"||r7(o.source)},i);this.scheduleNavigation(a,rm,null,l,{resolve:o.resolve,reject:o.reject,promise:o.promise})}}f7(r)&&this._events.next(r)}catch(o){this.navigationTransitions.transitionAbortSubject.next(o)}});this.eventsSubscription.add(e)}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),rm,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((e,r)=>{setTimeout(()=>{this.navigateToSyncWithBrowser(e,"popstate",r)},0)})}navigateToSyncWithBrowser(e,r,o){let s={replaceUrl:!0},i=o?.navigationId?o:null;if(o){let l=Se({},o);delete l.navigationId,delete l.\u0275routerPageId,Object.keys(l).length!==0&&(s.state=l)}let a=this.parseUrl(e);this.scheduleNavigation(a,r,i,s)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(ET),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription&&(this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(e,r={}){let{relativeTo:o,queryParams:s,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=l?this.currentUrlTree.fragment:i,c=null;switch(a??this.options.defaultQueryParamsHandling){case"merge":c=Se(Se({},this.currentUrlTree.queryParams),s);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=s||null}c!==null&&(c=this.removeEmptyProps(c));let p;try{let f=o?o.snapshot:this.routerState.snapshot.root;p=iO(f)}catch{(typeof e[0]!="string"||e[0][0]!=="/")&&(e=[]),p=this.currentUrlTree.root}return aO(p,e,c,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){let o=im(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(o,this.rawUrlTree);return this.scheduleNavigation(s,rm,null,r)}navigate(e,r={skipLocationChange:!1}){return p7(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){try{return this.urlSerializer.parse(e)}catch{return this.urlSerializer.parse("/")}}isActive(e,r){let o;if(r===!0?o=Se({},u7):r===!1?o=Se({},c7):o=r,im(e))return G_(this.currentUrlTree,e,o);let s=this.parseUrl(e);return G_(this.currentUrlTree,s,o)}removeEmptyProps(e){return Object.entries(e).reduce((r,[o,s])=>(s!=null&&(r[o]=s),r),{})}scheduleNavigation(e,r,o,s,i){if(this.disposed)return Promise.resolve(!1);let a,l,u;i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((p,f)=>{a=p,l=f});let c=this.pendingTasks.add();return a7(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(c))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:o,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:s,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(p=>Promise.reject(p))}static{this.\u0275fac=function(r){return new(r||t)}}static{this.\u0275prov=Ge({token:t,factory:t.\u0275fac,providedIn:"root"})}}return t})();function p7(t){for(let n=0;n<t.length;n++)if(t[n]==null)throw new Oe(4008,!1)}function f7(t){return!(t instanceof cm)&&!(t instanceof _p)}var d7=new Be("");function TO(t,...n){return Nu([{provide:DT,multi:!0,useValue:t},[],{provide:Op,useFactory:h7,deps:[SO]},{provide:Sp,multi:!0,useFactory:m7},n.map(e=>e.\u0275providers)])}function h7(t){return t.routerState.root}function m7(){let t=ue(ti);return n=>{let e=t.get(ws);if(n!==e.components[0])return;let r=t.get(SO),o=t.get(g7);t.get(y7)===1&&r.initialNavigation(),t.get(x7,null,Qe.Optional)?.setUpPreloading(),t.get(d7,null,Qe.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),o.closed||(o.next(),o.complete(),o.unsubscribe())}}var g7=new Be("",{factory:()=>new gr}),y7=new Be("",{providedIn:"root",factory:()=>1});var x7=new Be("");var NO=[];var EO={providers:[l_({eventCoalescing:!0}),TO(NO),U_()]};var $u=class{constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}},si=class{refCount(n){return Rr("refCount")}incRef(n){return Rr("incRef")}timerAvailable(){return!0}time(n){return Rr("time")}read(n){return Rr("read")}readSync(n){return Rr("readSync")}readToGPU(n,e){return Rr("readToGPU")}numDataIds(){return Rr("numDataIds")}disposeData(n,e){return Rr("disposeData")}write(n,e,r){return Rr("write")}move(n,e,r,o,s){return Rr("move")}createTensorFromGPUData(n,e,r){return Rr("createTensorFromGPUData")}memory(){return Rr("memory")}floatPrecision(){return Rr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Rr("dispose")}};function Rr(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function DO(t){let n=t.length,e=0;for(;n>0;)e=Math.random()*n|0,n--,Tx(t,n,e)}function b7(t,n){if(t.length!==n.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${n.length}`);let e=t.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,Tx(t,e,r),Tx(n,e,r)}function $p(t,n,e){return Math.max(t,Math.min(n,e))}function v7(t){return t%2===0?t:t+1}function Tx(t,n,e){let r=t[n];t[n]=t[e],t[e]=r}function w7(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}function C7(t,n){let e=Math.random();return n*e+(1-e)*t}function I7(t,n){let e=0;for(let r=0;r<t.length;r++){let o=Number(t[r])-Number(n[r]);e+=o*o}return e}function D(t,n){if(!t)throw new Error(typeof n=="string"?n:n())}function Kt(t,n,e=""){D(_r(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function eo(t){D(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Le(t){if(t.length===0)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function S7(t){return t.length===0}function AT(t,n){if(t===n)return!0;if(t==null||n==null||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==null&&n[e]!==null&&t[e]!==n[e])return!1;return!0}function _r(t,n){if(t===n)return!0;if(t==null||n==null||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function ii(t){return t%1===0}function T7(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{let n=Math.exp(2*t);return(n-1)/(n+1)}}function N7(t){let n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function E7(t){let n=new Uint32Array(t);for(let e=0;e<t;++e)n[e]=e;return DO(n),n}function Lu(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function D7(t,n=o=>0,e,r){return new Promise((o,s)=>{let i=0,a=()=>{if(t()){o();return}i++;let l=n(i);if(e!=null&&i>=e){s();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function k7(t,n){let e=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)e*=t[s];else if(t[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(r===-1){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(e===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);let o=t.slice();return o[r]=n/e,o}function ln(t,n){let e=n.length;return t=t==null?n.map((r,o)=>o):[].concat(t),D(t.every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),D(t.every(r=>ii(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function RT(t,n){let e=[],r=[],o=n!=null&&Array.isArray(n)&&n.length===0,s=n==null||o?null:ln(n,t).sort(),i=0;for(let a=0;a<t.length;++a){if(s!=null){if(s[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(s[i]==null||s[i]>a)&&t[a]===1&&(e.push(t[a]),r.push(a)),s[i]<=a&&i++}t[a]!==1&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function _T(t,n){return Nx(t,n)}function Nx(t,n){let e=null;if(t==null||t==="float32")e=new Float32Array(n);else if(t==="int32")e=new Int32Array(n);else if(t==="bool")e=new Uint8Array(n);else if(t==="string")e=new Array(n);else throw new Error(`Unknown data type ${t}`);return e}function OT(t,n){for(let e=0;e<t.length;e++){let r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}function FT(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function A7(t,n){return!(n==="complex64"||n==="float32"&&t!=="complex64"||n==="int32"&&t!=="float32"&&t!=="complex64"||n==="bool"&&t==="bool")}function Pp(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function MT(t){if(t==null)return 0;let n=0;return t.forEach(e=>n+=e.length),n}function Lp(t){return typeof t=="string"||t instanceof String}function kO(t){return typeof t=="boolean"}function AO(t){return typeof t=="number"}function $a(t){return Array.isArray(t)?$a(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":AO(t)?"float32":Lp(t)?"string":kO(t)?"bool":"float32"}function Bp(t){return!!(t&&t.constructor&&t.call&&t.apply)}function zp(t,n){for(let e=n;e<t;++e)if(t%e===0)return e;return t}function Is(t){let n=t.length;if(n<2)return[];let e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function RO(t,n,e,r=!1){let o=new Array;if(n.length===1){let s=n[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=e[t+i]}else{let s=n[0],i=n.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<s;l++)o[l]=RO(t+l*a,i,e,r)}return o}function Pu(t,n,e=!1){if(t.length===0)return n[0];let r=t.reduce((o,s)=>o*s)*(e?2:1);if(r===0)return[];if(r!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`);return RO(0,t,n,e)}function R7(t,n){if(Array.isArray(t))return t;if(n==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(n==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(n==="bool"||n==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${n}`)}function xm(t,n){let e=Vp(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function Vp(t,n){if(n==null||n==="float32"||n==="complex64")return new Float32Array(t);if(n==="int32")return new Int32Array(t);if(n==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function _7(t,n){let e=t.reduce((r,o)=>r*o,1);if(n==null||n==="float32")return Pu(t,new Float32Array(e));if(n==="int32")return Pu(t,new Int32Array(e));if(n==="bool")return Pu(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function Mt(t){t.forEach(n=>{D(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function O7(t,n,e){if(n===0)return 0;if(n===1)return t[0];let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=e[o]*t[o];return r}function F7(t,n,e){if(n===0)return[];if(n===1)return[t];let r=new Array(n);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(t/e[o]),t-=r[o]*e[o];return r[r.length-1]=t,r}function Bu(t){return t&&t.then&&typeof t.then=="function"}var _O="tfjsflags",bm=class{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$7,this.populateURLFlags()}setPlatform(n,e){this.platform!=null&&($().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},this.urlFlags[n]!=null){let o=this.urlFlags[n];$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${o}.`),this.set(n,o)}}getAsync(n){return z(this,null,function*(){return n in this.flags?this.flags[n]:(this.flags[n]=yield this.evaluateFlag(n),this.flags[n])})}get(n){if(n in this.flags)return this.flags[n];let e=this.evaluateFlag(n);if(Bu(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getString(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(this.flagRegistry[n]==null)throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,this.flagRegistry[n].setHook!=null&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(this.flagRegistry[n]==null)throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let n=this.getQueryParams(this.global.location.search);_O in n&&n[_O].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=L7(o,s)})}};function $7(t){let n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(P7(n,r[0],r[1]),r.join("="))),n}function P7(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}function L7(t,n){let e=n.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:n}function $(){return $T}var $T=null;function OO(t){$T=t}var PT;function LT(){if(PT==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");PT=t}return PT}function B7(){let t=LT();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function vm(t,n){let e=B7();if(e.has(t))return e.get(t);{let r=n();return e.set(t,r),e.get(t)}}var Pa="Abs",ai="Acos",li="Acosh",jo="Add",La="AddN",Up="All",Gp="Any",Ba="ArgMax",za="ArgMin",ui="Asin",ci="Asinh",pi="Atan",fi="Atanh",di="Atan2",Va="AvgPool",Wp="AvgPoolGrad",Ua="AvgPool3D",jp="AvgPool3DGrad",Ga="BatchMatMul",Wa="BatchToSpaceND",Hp="Bincount",zu="BitwiseAnd",FO="BroadcastTo",qp="BroadcastArgs",Ss="Cast",hi="Ceil",mi="ClipByValue",Kp="Complex",ja="ComplexAbs",Ha="Concat",qa="Conv2D",Xp="Conv2DBackpropFilter",Ka="Conv2DBackpropInput",Xa="Conv3D",Yp="Conv3DBackpropFilterV2",Zp="Conv3DBackpropInputV2",gi="Cos",yi="Cosh",Qp="Cumprod",Ya="Cumsum",Jp="CropAndResize",ef="DenseBincount",tf="DepthToSpace",Za="DepthwiseConv2dNative",nf="DepthwiseConv2dNativeBackpropFilter",rf="DepthwiseConv2dNativeBackpropInput",of="Diag",Qa="Dilation2D",wm="Dilation2DBackpropInput",Cm="Dilation2DBackpropFilter",Im="Draw",xi="RealDiv",sf="Einsum",bi="Elu",af="EluGrad",vi="Erf",Vu="Equal",wi="Exp",Ja="ExpandDims",Ci="Expm1",lf="FFT",uf="Fill",cf="FlipLeftRight",Ii="Floor",Si="FloorDiv",el="FusedBatchNorm",tl="GatherV2",pf="GatherNd",Uu="Greater",Ti="GreaterEqual",Ts="Identity",ff="IFFT",df="Imag",Ni="IsFinite",Ei="IsInf",Di="IsNan",nl="LeakyRelu",Gu="Less",Wu="LessEqual",hf="LinSpace",ki="Log",Ai="Log1p",ju="LogicalAnd",Hu="LogicalNot",qu="LogicalOr";var MO="LogSoftmax";var rl="LRN",mf="LRNGrad";var ol="Max",Ri="Maximum",sl="MaxPool",gf="MaxPoolGrad",il="MaxPool3D",yf="MaxPool3DGrad",xf="MaxPoolWithArgmax",al="Mean",ll="Min",_i="Minimum",ul="MirrorPad",Oi="Mod",bf="Multinomial",Fi="Multiply",cl="Neg",Ku="NotEqual",vf="NonMaxSuppressionV3",wf="NonMaxSuppressionV4",Cf="NonMaxSuppressionV5",pl="OnesLike",fl="OneHot",dl="Pack",hl="PadV2";var Mi="Pow",ml="Prelu",gl="Prod",If="RaggedGather",Sf="RaggedRange",Tf="RaggedTensorToTensor",Nf="Range",Ef="Real",$i="Reciprocal",Pi="Relu",yl="Reshape",xl="ResizeNearestNeighbor",Df="ResizeNearestNeighborGrad",bl="ResizeBilinear",kf="ResizeBilinearGrad",Li="Relu6",vl="Reverse",Bi="Round",zi="Rsqrt",Af="ScatterNd",Rf="TensorScatterUpdate",_f="SearchSorted",wl="Select",Vi="Selu",Cl="Slice",Ui="Sin",Gi="Sinh",Wi="Sign",ji="Sigmoid",Hi="Softplus",qi="Sqrt",Il="Sum",Sl="SpaceToBatchND",Tl="SplitV",Nl="Softmax",Of="SparseFillEmptyRows",Ff="SparseReshape",Mf="SparseSegmentMean",$f="SparseSegmentSum",Pf="SparseToDense",Ki="SquaredDifference",Lf="Square",Xu="StaticRegexReplace",Bf="StridedSlice",zf="StringNGrams",Vf="StringSplit",Uf="StringToHashBucketFast",Xi="Sub",Yi="Tan",Zi="Tanh",Ns="Tile",Gf="TopK",Wf="Transform",Es="Transpose",jf="Unique",El="Unpack",Dl="UnsortedSegmentSum";var kl="ZerosLike",Qi="Step",Sm="FromPixels",Hf="RotateWithOffset",Yu="_FusedMatMul",Zu="FusedConv2D",Qu="FusedDepthwiseConv2D";function Ds(...t){$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(...t)}function z7(...t){$().getBool("IS_TEST")||$().getBool("PROD")||console.log(...t)}var Ex=vm("kernelRegistry",()=>new Map),BT=vm("gradRegistry",()=>new Map);function qf(t,n){let e=LO(t,n);return Ex.get(e)}function zT(t){return BT.get(t)}function VT(t){let n=Ex.entries(),e=[];for(;;){let{done:r,value:o}=n.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===t&&e.push(i)}return e}function Dx(t){let{kernelName:n,backendName:e}=t,r=LO(n,e);Ex.has(r)&&Ds(`The kernel '${n}' for backend '${e}' is already registered`),Ex.set(r,t)}function PO(t){let{kernelName:n}=t;BT.has(n)&&$().getBool("DEBUG")&&Ds(`Overriding the gradient for '${n}'`),BT.set(n,t)}function LO(t,n){return`${n}_${t}`}var b={};ft(b,{arraysEqual:()=>_r,arraysEqualWithNull:()=>AT,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Mt,assertNonNull:()=>eo,assertShapesMatch:()=>Kt,bytesFromStringArray:()=>MT,bytesPerElement:()=>Pp,checkConversionForErrors:()=>OT,clamp:()=>$p,computeStrides:()=>Is,convertBackendValuesAndArrayBuffer:()=>R7,createScalarValue:()=>q7,createShuffledIndices:()=>E7,decodeString:()=>Qf,distSquared:()=>I7,encodeString:()=>Zf,fetch:()=>X7,fingerPrint64:()=>H7,flatten:()=>Rl,getArrayFromDType:()=>Nx,getTypedArrayFromDType:()=>_T,hasEncodingLoss:()=>A7,hexToLong:()=>Tm,indexToLoc:()=>F7,inferDtype:()=>$a,inferFromImplicitShape:()=>k7,isBoolean:()=>kO,isFunction:()=>Bp,isInt:()=>ii,isNumber:()=>AO,isPromise:()=>Bu,isScalarShape:()=>S7,isString:()=>Lp,isTypedArray:()=>Yn,isValidDtype:()=>FT,locToIndex:()=>O7,makeOnesTypedArray:()=>xm,makeZerosNestedTypedArray:()=>_7,makeZerosTypedArray:()=>Vp,nearestDivisor:()=>zp,nearestLargerEven:()=>v7,now:()=>rc,parseAxisParam:()=>ln,randUniform:()=>C7,repeatedTry:()=>D7,rightPad:()=>Lu,shuffle:()=>DO,shuffleCombo:()=>b7,sizeFromShape:()=>Le,sizeToSquarishShape:()=>N7,squeezeShape:()=>RT,sum:()=>w7,swap:()=>Tx,tanh:()=>T7,toNestedArray:()=>Pu,toTypedArray:()=>Yf});function kx(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var jT=Sh(XO());var nc=jT.default||jT;function Tm(t){return nc.fromString(t,!0,16)}var ZO=Tm("c3a5c85c97cb3127"),tc=Tm("b492b66fbe98f273"),or=Tm("9ae16a3b2f90404f");function WT(t){return t.xor(t.shru(47))}function QO(t,n,e){let r=t.slice(n,n+e);return nc.fromBytes(Array.from(r),!0,!0)}function $t(t,n){return QO(t,n,8)}function YO(t,n){return QO(t,n,4)}function An(t,n){return n===0?t:t.shru(n).or(t.shl(64-n))}function Al(t,n,e=Tm("9ddfea08eb382d69")){let r=t.xor(n).mul(e);r=r.xor(r.shru(47));let o=n.xor(r).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function U7(t,n,e,r,o,s){o=o.add(t),s=An(s.add(o).add(r),21);let i=o;return o=o.add(n),o=o.add(e),s=s.add(An(o,44)),[o.add(r),s.add(i)]}function Rx(t,n,e,r){return U7($t(t,n),$t(t,n+8),$t(t,n+16),$t(t,n+24),e,r)}function G7(t,n=t.length){if(n>=8){let e=or.add(n*2),r=$t(t,0).add(or),o=$t(t,n-8),s=An(o,37).mul(e).add(r),i=An(r,25).add(o).mul(e);return Al(s,i,e)}if(n>=4){let e=or.add(n*2),r=YO(t,0);return Al(r.shl(3).add(n),YO(t,n-4),e)}if(n>0){let e=t[0],r=t[n>>1],o=t[n-1],s=e+(r<<8),i=n+(o<<2);return WT(or.mul(s).xor(ZO.mul(i))).mul(or)}return or}function W7(t,n=t.length){let e=or.add(n*2),r=$t(t,0).mul(tc),o=$t(t,8),s=$t(t,n-8).mul(e),i=$t(t,n-16).mul(or);return Al(An(r.add(o),43).add(An(s,30)).add(i),r.add(An(o.add(or),18)).add(s),e)}function j7(t,n=t.length){let e=or.add(n*2),r=$t(t,0).mul(or),o=$t(t,8),s=$t(t,n-8).mul(e),i=$t(t,n-16).mul(or),a=An(r.add(o),43).add(An(s,30)).add(i),l=Al(a,r.add(An(o.add(or),18)).add(s),e),u=$t(t,16).mul(e),c=$t(t,24),p=a.add($t(t,n-32)).mul(e),f=l.add($t(t,n-24)).mul(e);return Al(An(u.add(c),43).add(An(p,30)).add(f),u.add(An(c.add(r),18)).add(p),e)}function H7(t,n=t.length){let e=nc.fromNumber(81,!0);if(n<=32)return n<=16?G7(t,n):W7(t,n);if(n<=64)return j7(t,n);let r=e,o=e.mul(tc).add(113),s=WT(o.mul(or).add(113)).mul(or),i=[nc.UZERO,nc.UZERO],a=[nc.UZERO,nc.UZERO];r=r.mul(or).add($t(t,0));let l=0,u=(n-1>>6)*64,c=u+(n-1&63)-63;do r=An(r.add(o).add(i[0]).add($t(t,l+8)),37).mul(tc),o=An(o.add(i[1]).add($t(t,l+48)),42).mul(tc),r=r.xor(a[1]),o=o.add(i[0]).add($t(t,l+40)),s=An(s.add(a[0]),33).mul(tc),i=Rx(t,l,i[1].mul(tc),r.add(a[0])),a=Rx(t,l+32,s.add(a[1]),o.add($t(t,l+16))),[s,r]=[r,s],l+=64;while(l!==u);let p=tc.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=An(r.add(o).add(i[0]).add($t(t,l+8)),37).mul(p),o=An(o.add(i[1]).add($t(t,l+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add($t(t,l+40))),s=An(s.add(a[0]),33).mul(p),i=Rx(t,l,i[1].mul(p),r.add(a[0])),a=Rx(t,l+32,s.add(a[1]),o.add($t(t,l+16))),[s,r]=[r,s],Al(Al(i[0],a[0],p).add(WT(o).mul(ZO)).add(s),Al(i[1],a[1],p).add(r),p)}function q7(t,n){return n==="string"?Zf(t):Yf([t],n)}function K7(t,n){return t instanceof Float32Array&&n==="float32"||t instanceof Int32Array&&n==="int32"||t instanceof Uint8Array&&n==="bool"}function Yf(t,n){if(n==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Rl(t)),$().getBool("DEBUG")&&OT(t,n),K7(t,n))return t;if(n==null||n==="float32"||n==="complex64")return new Float32Array(t);if(n==="int32")return new Int32Array(t);if(n==="bool"){let e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)Math.round(t[r])!==0&&(e[r]=1);return e}else throw new Error(`Unknown data type ${n}`)}function rc(){return $().platform.now()}function X7(t,n){return $().platform.fetch(t,n)}function Zf(t,n="utf-8"){return n=n||"utf-8",$().platform.encode(t,n)}function Qf(t,n="utf-8"){return n=n||"utf-8",$().platform.decode(t,n)}function Yn(t){return $().platform.isTypedArray!=null?$().platform.isTypedArray(t):kx(t)}function Rl(t,n=[],e=!1){if(n==null&&(n=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Bu(t)||t==null||Yn(t)&&e)n.push(t);else if(Array.isArray(t)||Yn(t))for(let r=0;r<t.length;++r)Rl(t[r],n,e);else{let r=-1;for(let o of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)Rl(t[o],n,e)}return n}var _x=class{constructor(n,e){this.backendTimer=n,this.logger=e,e==null&&(this.logger=new HT)}profileKernel(n,e,r){let o,s=()=>{o=r()},i,a=rc();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let u of o)u.dataSync();i=Promise.resolve({kernelMs:rc()-a})}if($().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<o.length;u++){let c=o[u];c.data().then(p=>{Y7(p,c.dtype,n)})}return{kernelName:n,outputs:o,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(n){let{kernelName:e,outputs:r,timeMs:o,inputs:s,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),o,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],s,l[2])})})}};function Y7(t,n,e){if(n!=="float32")return!1;for(let r=0;r<t.length;r++){let o=t[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var HT=class{logKernelProfile(n,e,r,o,s,i){let a=typeof o=="number"?Lu(`${o}ms`,9):o.error,l=Lu(n,25),u=e.rank,c=e.size,p=Lu(e.shape.toString(),14),f="";for(let d in s){let h=s[d];if(h!=null){let g=h.shape||e.shape,m=g.length;f+=`${d}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${p}	%c${c}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function JO(t,n,e){let r={},o={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){let u=t[l],c=u.inputs;for(let p in c){let f=c[p],d=!1;for(let h=0;h<n.length;h++)if(r[f.id]){u.outputs.forEach(g=>r[g.id]=!0),d=!0,o[u.id]=!0;break}if(d)break}}let s={};s[e.id]=!0;let i={};for(let l=t.length-1;l>=0;l--){let u=t[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let f in c)s[c[f].id]=!0,i[u.id]=!0;break}}let a=[];for(let l=0;l<t.length;l++){let u=t[l];if(o[u.id]&&i[u.id]){let c={};for(let f in u.inputs){let d=u.inputs[f];r[d.id]&&(c[f]=d)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,a.push(p)}}return a}function eF(t,n,e,r){for(let o=n.length-1;o>=0;o--){let s=n[o],i=[];if(s.outputs.forEach(l=>{let u=t[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);let u=e(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!_r(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{let p=t[c.id];t[c.id]=r(p,u),p.dispose()}}}}var tF=20,Nm=3,qT=7;function nF(t,n,e,r){let o=Is(n),s=Z7(t,n,e,o),i=n.length,a=Ox(t,n,e,o,s),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Z7(t,n,e,r){let o=Le(n),s=r[r.length-1],i=new Array(s).fill(0),a=n.length,l=e==="complex64"?Dm(t):t;if(a>1)for(let u=0;u<o/s;u++){let c=u*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],Em(l[c+p],0,e).length)}return i}function Em(t,n,e){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(qT))} + ${parseFloat(t[1].toFixed(qT))}j`:Lp(t)?r=`'${t}'`:e==="bool"?r=rF(t):r=parseFloat(t.toFixed(qT)).toString(),Lu(r,n)}function rF(t){return t===0?"false":"true"}function Ox(t,n,e,r,o,s=!0){let i=e==="complex64"?2:1,a=n[0],l=n.length;if(l===0){if(e==="complex64"){let g=Dm(t);return[Em(g[0],0,e)]}return e==="bool"?[rF(t[0])]:[t[0].toString()]}if(l===1){if(a>tF){let m=Nm*i,y=Array.from(t.slice(0,m)),x=Array.from(t.slice((a-Nm)*i,a*i));return e==="complex64"&&(y=Dm(y),x=Dm(x)),["["+y.map((v,w)=>Em(v,o[w],e)).join(", ")+", ..., "+x.map((v,w)=>Em(v,o[a-Nm+w],e)).join(", ")+"]"]}return["["+(e==="complex64"?Dm(t):Array.from(t)).map((m,y)=>Em(m,o[y],e)).join(", ")+"]"]}let u=n.slice(1),c=r.slice(1),p=r[0]*i,f=[];if(a>tF){for(let g=0;g<Nm;g++){let m=g*p,y=m+p;f.push(...Ox(t.slice(m,y),u,e,c,o,!1))}f.push("...");for(let g=a-Nm;g<a;g++){let m=g*p,y=m+p;f.push(...Ox(t.slice(m,y),u,e,c,o,g===a-1))}}else for(let g=0;g<a;g++){let m=g*p,y=m+p;f.push(...Ox(t.slice(m,y),u,e,c,o,g===a-1))}let d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let g=1;g<f.length-1;g++)f[g]=" "+f[g]+d;let h=`,
`;for(let g=2;g<l;g++)h+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":h),f}function Dm(t){let n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}var tt=class{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=Le(n),r!=null){let o=r.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Nx(e,this.size),this.strides=Is(n)}set(n,...e){e.length===0&&(e=[0]),D(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let r=this.locToIndex(e);this.values[r]=n}get(...n){n.length===0&&(n=[0]);let e=0;for(let o of n){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${n}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=this.strides[o]*n[o];return this.values[r]}locToIndex(n){if(this.rank===0)return 0;if(this.rank===1)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(this.rank===0)return[];if(this.rank===1)return[n];let e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return qo().makeTensor(this.values,this.shape,this.dtype)}},qo=null,Jf=null,Q7=null;function oF(t){qo=t}function sF(t){Jf=t}function iF(t){Q7=t}var Pe=class{constructor(n,e,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=Le(n),this.strides=Is(n),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return z(this,null,function*(){let n=yield this.data();return Jf.buffer(this.shape,this.dtype,n)})}bufferSync(){return Jf.buffer(this.shape,this.dtype,this.dataSync())}array(){return z(this,null,function*(){let n=yield this.data();return Pu(this.shape,n,this.dtype==="complex64")})}arraySync(){return Pu(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return z(this,null,function*(){this.throwIfDisposed();let n=qo().read(this.dataId);if(this.dtype==="string"){let e=yield n;try{return e.map(r=>Qf(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return n})}dataToGPU(n){return this.throwIfDisposed(),qo().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();let n=qo().readSync(this.dataId);if(this.dtype==="string")try{return n.map(e=>Qf(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){return z(this,null,function*(){this.throwIfDisposed();let n=yield qo().read(this.dataId);return this.dtype==="string"?n:new Uint8Array(n.buffer)})}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),qo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return Jf.print(this,n)}clone(){return this.throwIfDisposed(),Jf.clone(this)}toString(n=!1){let e=this.dataSync();return nF(e,this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),Jf.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),qo().makeVariable(this,n,e,r)}};Object.defineProperty(Pe,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function F(){return vm("Tensor",()=>Pe)}F();var Ji=class extends Pe{constructor(n,e,r,o){super(n.shape,n.dtype,n.dataId,o),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!_r(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);qo().disposeTensor(this),this.dataId=n.dataId,qo().incRef(this,null)}dispose(){qo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ji,Symbol.hasInstance,{value:t=>t instanceof Pe&&t.assign!=null&&t.assign instanceof Function});var aF=function(t){return t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",t}(aF||{}),lF=function(t){return t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",t}(lF||{}),uF=function(t){return t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",t}(uF||{}),cF=function(t){return t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",t}(cF||{}),J7={float32:uF,int32:aF,bool:lF,complex64:cF};function nn(t,n){if(t==="string"||n==="string"){if(t==="string"&&n==="string")return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return J7[t][n]}function oc(t){return nn(t,"int32")}function Fx(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function Mx(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}function ze(t,n){if(t.dtype===n.dtype)return[t,n];let e=nn(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function pF(t,n){D(t.dtype===n.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${n.dtype}) input must match`)}function $x(t){let n=[];return fF(t,n,new Set),n}function fF(t,n,e){if(t==null)return;if(t instanceof Pe){n.push(t);return}if(!eQ(t))return;let r=t;for(let o in r){let s=r[o];e.has(s)||(e.add(s),fF(s,n,e))}}function eQ(t){return Array.isArray(t)||typeof t=="object"}function KT(t){return t.kernelName!=null}var Px=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(let n in this.registeredVariables)this.registeredVariables[n].dispose()}},nQ=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Px}ready(){return z(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r];if(yield this.initializeBackend(o).success){yield this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:r}=this.initializeBackend(e);if(r)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,o=1){return e in this.registryFactory?(Ds(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:o},!0)}setBackend(e){return z(this,null,function*(){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(e);if(!(o?yield r:r))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new _x(this.backendInstance),!0})}setupRegisteredKernels(){VT(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){VT(e).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[e])})}initializeBackend(e){let r=this.registryFactory[e];if(r==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof si)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Ds(`Initialization of backend ${e} failed`),Ds(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=o,{success:!0,asyncInit:!1}}catch(o){return Ds(`Initialization of backend ${e} failed`),Ds(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=e,e.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o=null;if(r==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");r=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,r,o){e();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){let r=E.runKernel(Ts,{x:e}),o={x:e},s=a=>({x:()=>{let l="float32",u={x:a},c={dtype:l};return E.runKernel(Ss,u,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(e,r,o){if(this.backendName==null&&this.backend,!(qf(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(u=>{i+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=s-r-i-a;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let u,c=KT(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(KT(e)){let{kernelName:g,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;let x=qf(g,this.backendName);D(x!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{let v=this.backend.numDataIds();u=x.kernelFunc({inputs:m,attrs:y,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,v,w);let T=w.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(s){let k=this.getTensorsForGradient(g,m,T);o=this.saveTensorsForBackwardMode(k)}return T}}else{let{forwardFunc:g}=e,m=y=>{s&&(o=y.map(x=>this.keep(this.clone(x))))};l=()=>{let y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));let x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,x),x}}let{inputs:p,attrs:f}=e,d=KT(e)?null:e.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=l():(h=this.profiler.profileKernel(c,p,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),r=h.outputs)}),s&&this.addTapeNode(c,p,r,d,o,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(g=>p[g]!=null?p[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(e,r,o){let s=zT(e);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],l;s.saveAllInputs?(D(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);let u=o.filter((c,p)=>a[p]);return l.concat(u)}return[]}makeTensor(e,r,o,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=e;o==="string"&&Lp(e[0])&&(i=e.map(u=>Zf(u)));let a=s.write(i,r,o),l=new Pe(r,o,a,this.nextTensorId());if(this.trackTensor(l,s),o==="string"){let u=this.state.tensorInfo.get(a),c=MT(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,o,s){o=o||"float32";let i={dataId:e,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,r){let{dataId:o,shape:s,dtype:i}=e,a=new Pe(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));let i=new Ji(e,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let o=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(o=e.size*Pp(e.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:o})),e instanceof Ji||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let o=e.size*Pp(e.dtype);this.state.numBytes-=o}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let r=this.state.registeredVariables[e];this.disposeVariable(r)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){return z(this,null,function*(){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,r,o,s,i,a){let l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:o,saved:i},u=zT(e);u!=null&&(s=u.gradFunc),s!=null&&(l.gradient=c=>(c=c.map((p,f)=>{if(p==null){let d=o[f],h=Vp(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return p}),s(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){let r=$x(e),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,r,o,s=!1){if(D(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(i instanceof Pe,()=>"The result y returned by f() must be a tensor.");let a=JO(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let l={};l[i.id]=o??rQ(i.shape),eF(l,a,c=>this.tidy(c),oQ);let u=r.map(c=>l[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let p of c.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return D(Bp(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{D(r.every(l=>l instanceof Pe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((l,u)=>{s[u]=l});let i=(l,u)=>(o=e(...r,u),D(o.value instanceof Pe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Bp(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(l,u)=>{let c=o.gradFunc(l,u),p=Array.isArray(c)?c:[c];D(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(d=>d instanceof Pe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let f={};return p.forEach((d,h)=>{f[h]=()=>d}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){return z(this,null,function*(){let r=rc(),o=yield this.backend.time(e);return o.wallMs=rc()-r,o})}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Px;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function rQ(t){let n=xm(Le(t),"float32");return E.makeTensor(n,t,"float32")}function XT(){let t=LT();if(t._tfengine==null){let n=new bm(t);t._tfengine=new nQ(n)}return OO(t._tfengine.ENV),oF(()=>t._tfengine),t._tfengine}var E=XT();function oQ(t,n){let e={a:t,b:n};return E.runKernel(jo,e)}var _l={};ft(_l,{isBrowser:()=>ZT,isMobile:()=>aQ,mockIsMobile:()=>iQ});function sQ(){return typeof navigator<"u"&&navigator!=null}var YT;function iQ(t){YT=t}function aQ(t){if(YT!==void 0)return YT;if(t||sQ()){if(t||(t=navigator),t.product==="ReactNative")return!0;let n=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!n){let e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function ZT(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var yr=$();yr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});yr.registerFlag("IS_BROWSER",()=>ZT());yr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");yr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));yr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));yr.registerFlag("PROD",()=>!1);yr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>yr.getBool("DEBUG"));yr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);yr.registerFlag("IS_TEST",()=>!1);yr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>yr.getBool("DEBUG"));yr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);yr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);yr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function xr(t,n){let e=t;if(Yn(t))return n==="string"?[]:[t.length];if(Fx(t)){let o=t.channels||"RGBA";return[t.height,t.width*o.length]}else if(Mx(t))return[t.buffer.size/(n==null?4:Pp(n))];if(!Array.isArray(t))return[];let r=[];for(;Array.isArray(e)||Yn(e)&&n!=="string";)r.push(e.length),e=e[0];return Array.isArray(t)&&$().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hF(t,r,[]),r}function hF(t,n,e){if(e=e||[],!Array.isArray(t)&&!Yn(t)){D(n.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);return}D(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),D(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);let r=n.slice(1);for(let o=0;o<t.length;++o)hF(t[o],r,e.concat(o))}function dF(t,n,e,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==n||t==="numeric"&&n==="string")throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function I(t,n,e,r="numeric"){if(t instanceof F())return dF(r,t.dtype,n,e),t;let o=$a(t);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),dF(r,o,n,e),t==null||!Yn(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){let l=t==null?"null":t.constructor.name;throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}let s=xr(t,o);!Yn(t)&&!Array.isArray(t)&&(t=[t]);let a=o!=="string"?Yf(t,o):Rl(t,[],!0);return E.makeTensor(a,s,o)}function sc(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((s,i)=>I(s,`${n}[${i}]`,e,r))}var QT="__op";function S(t){let n=Object.keys(t);if(n.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0],r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+QT;let o=(...s)=>{E.startScope(e);try{let i=r(...s);return Bu(i)&&console.error("Cannot return a Promise inside of tidy."),E.endScope(i),i}catch(i){throw E.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function lQ(t,n){let e=I(t,"real","complex"),r=I(n,"imag","complex");Kt(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:e,imag:r};return E.runKernel(Kp,o)}var br=S({complex_:lQ});function sr(t,n,e,r){if(r==null)r=$a(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Mx(t)||Fx(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return E.backend.createTensorFromGPUData(t,n||e,r)}if(!Yn(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(n!=null){Mt(n);let o=Le(n),s=Le(e);D(o===s,()=>`Based on the provided shape, [${n}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],l=i===e.length-1?a!==Le(n.slice(i)):!0;D(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!Yn(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t=r!=="string"?Yf(t,r):Rl(t,[],!0),E.makeTensor(t,n,r)}function xn(t,n,e){let r=xr(t,e);return sr(t,n,r,e)}var ea={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Bn=class t{static join(n){return new t(n).slice()}constructor(n){if(this.shards=[],this.previousShardIndex=0,n==null||(n instanceof Array||(n=[n]),n=n.map(r=>Yn(r)?r.buffer:r),n.length===0))return;this.bufferUniformSize=n[0].byteLength;let e=0;for(let r=0;r<n.length;r++){let o=n[r];r!==n.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=e+o.byteLength;this.shards.push({buffer:o,start:e,end:s}),e=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(n=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(n=isNaN(Number(n))?0:n,e=isNaN(Number(e))?0:e,n=Math.max(0,n),e=Math.min(this.byteLength,e),e<=n)return new ArrayBuffer(0);let r=this.findShardForByte(n);if(r===-1)throw new Error(`Could not find start shard for byte ${n}`);let o=e-n,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],p=n+a-u.start,f=a,h=Math.min(e,u.end)-u.start,g=new Uint8Array(u.buffer,p,h-p);if(i.set(g,f),a+=g.length,e<u.end)break}return s}findShardForByte(n){if(this.shards.length===0||n<0||n>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(n/this.bufferUniformSize),this.previousShardIndex;function e(o){return n<o.start?-1:n>=o.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=uQ(this.shards,e);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function uQ(t,n){let e=0,r=t.length;for(;e<=r;){let o=Math.floor((r-e)/2)+e,s=n(t[o]);if(s===0)return o;s<0?r=o:e=o+1}return-1}function cQ(t){$().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}iF(cQ);function wo(){return E}function km(){return E.memory()}function B(t,n){return E.tidy(t,n)}function Ne(t){$x(t).forEach(e=>e.dispose())}function kt(t){return E.keep(t)}function Am(){return E.backendName}function Lx(t,n,e=1){return E.registerBackend(t,n,e)}function Bx(){return E.backend}var Ol=4;function yF(t,n){return z(this,null,function*(){let e=[],r=[],o=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<o.length;++i){let a=o[i],l=Array.isArray(t)?t[i].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);let u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(p=>z(this,null,function*(){let f=yield l.bytes(),d=f.reduce((m,y)=>m+y.length,0)+Ol*f.length,h=new Uint8Array(d),g=0;for(let m=0;m<f.length;m++){let y=f[m],x=new Uint8Array(new Uint32Array([y.length]).buffer);h.set(x,g),g+=Ol,h.set(y,g),g+=y.length}p(h)}));r.push(c)}else r.push(l.data());n!=null&&(u.group=n),e.push(u)}let s=yield Promise.all(r);return{data:dQ(s),specs:e}})}function zx(t,n){let e=new Bn(t),r={},o=0;for(let s of n){let i=pQ(s,(a,l)=>e.slice(o+a,o+l));r[s.name]=xF(s,e.slice(o,o+i)),o+=i}return r}function pQ(t,n){let e=Le(t.shape),r;if("quantization"in t){let o=t.quantization;r=ea[o.dtype]}else if(t.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Ol+new Uint32Array(n(o,o+Ol))[0];return o}else r=ea[t.dtype];return e*r}function fQ(t,n){return z(this,null,function*(){let e=Le(t.shape),r;if("quantization"in t){let o=t.quantization;r=ea[o.dtype]}else if(t.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Ol+new Uint32Array(yield n(o,o+Ol))[0];return o}else r=ea[t.dtype];return e*r})}function xF(t,n){let e=t.name,r=t.dtype,o=t.shape,s=Le(o),i,a=0;if("quantization"in t){let l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=ea[l.dtype],c=l.dtype==="uint8"?new Uint8Array(n):new Uint16Array(n);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let p=0;p<c.length;p++){let f=c[p];i[p]=f*l.scale+l.min}}else if(l.dtype==="float16")i=yQ()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let p=0;p<c.length;p++){let f=c[p];i[p]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*u}else if(r==="string"){let l=Le(t.shape);i=[];for(let u=0;u<l;u++){let c=new Uint32Array(n.slice(a,a+Ol))[0];a+=Ol;let p=new Uint8Array(n.slice(a,a+c));i.push(p),a+=c}}else{let l=ea[r];if(r==="float32")i=new Float32Array(n);else if(r==="int32")i=new Int32Array(n);else if(r==="bool")i=new Uint8Array(n);else if(r==="complex64"){i=new Float32Array(n);let u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let h=0;h<u.length;h++)u[h]=i[h*2],c[h]=i[h*2+1];let p=xn(u,o,"float32"),f=xn(c,o,"float32"),d=br(p,f);return p.dispose(),f.dispose(),d}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*l}return xn(i,o,r)}function mF(t,n,e){return z(this,null,function*(){let r=new Uint8Array(n);for(;r.byteLength<e;){let{done:o,value:s}=yield t.read();if(o&&s==null){let a=e-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer})}function Vx(t,n){return z(this,null,function*(){let e={},r=t.getReader(),o=new ArrayBuffer(0);for(let s of n){let i=yield fQ(s,(u,c)=>z(this,null,function*(){return o=yield mF(r,o,c),o.slice(u,c)}));o=yield mF(r,o,i);let a=o.slice(0,i);o=o.slice(i);let l=xF(s,a);if(e[s.name]=l,Am()==="webgpu"){let u=Bx();"uploadToGPU"in u&&Le(l.shape)>=$().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return e})}function dQ(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0,e=[];t.forEach(s=>{if(n+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(n),o=0;return e.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}var JT=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function gF(t){return JT?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function bF(t){if(JT)return Buffer.from(t).toString("base64");let n=new Uint8Array(t),e="";for(let r=0,o=n.length;r<o;r++)e+=String.fromCharCode(n[r]);return btoa(e)}function vF(t){if(JT){let r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}function wF(t){return Bn.join(t)}function eN(t){let n="/";for(t=t.trim();t.endsWith(n);)t=t.slice(0,t.length-1);let e=t.split(n);return e[e.length-1]}function Ux(t,n){let e={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};return t.signature!=null&&(e.signature=t.signature),t.userDefinedMetadata!=null&&(e.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(e.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(e.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(e.trainingConfig=t.trainingConfig),e}function tN(t,n,e){let r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=e}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}function ed(t,n){return z(this,null,function*(){let e,r;return t.weightsManifest!=null&&([e,r]=yield n(t.weightsManifest)),tN(t,e,r)})}function ks(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:gF(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:gF(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Bn(t.weightData).byteLength}}function Rm(t){let n=[];for(let e of t)n.push(...e.weights);return n}function hQ(){let t=e=>{let r=e<<13,o=0;for(;!(r&8388608);)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}function mQ(){let t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}function gQ(){let t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}function yQ(){let t=hQ(),n=mQ(),e=gQ();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],l=t[e[a>>10]+(a&1023)]+n[a>>10];s[i]=l}return new Float32Array(o)}}var bn=class t{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return t.instance==null&&(t.instance=new t),t.instance}static registerSaveRouter(n){t.getInstance().saveRouters.push(n)}static registerLoadRouter(n){t.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return t.getHandlers(n,"save")}static getLoadHandlers(n,e){return t.getHandlers(n,"load",e)}static getHandlers(n,e,r){let o=[];return(e==="load"?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(i=>{let a=i(n,r);a!==null&&o.push(a)}),o}},CF=t=>bn.registerSaveRouter(t),IF=t=>bn.registerLoadRouter(t),SF=t=>bn.getSaveHandlers(t),TF=(t,n)=>bn.getLoadHandlers(t,n);var nN="tensorflowjs",rN=1,ic="models_store",Fl="model_info_store";function NF(){if(!$().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(n==null)throw new Error("The current browser does not appear to support IndexedDB.");return n}function oN(t){let n=t.result;n.createObjectStore(ic,{keyPath:"modelPath"}),n.createObjectStore(Fl,{keyPath:"modelPath"})}var ac=(()=>{class t{constructor(e){if(this.indexedDB=NF(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)})}load(){return z(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(e,r){return new Promise((o,s)=>{let i=this.indexedDB.open(nN,rN);i.onupgradeneeded=()=>oN(i),i.onsuccess=()=>{let a=i.result;if(r==null){let l=a.transaction(ic,"readonly"),c=l.objectStore(ic).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(c.result.modelArtifacts)},c.onerror=p=>(a.close(),s(c.error)),l.oncomplete=()=>a.close()}else{r.weightData=Bn.join(r.weightData);let l=ks(r),u=a.transaction(Fl,"readwrite"),c=u.objectStore(Fl),p;try{p=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(d){return s(d)}let f;p.onsuccess=()=>{f=a.transaction(ic,"readwrite");let d=f.objectStore(ic),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return s(g)}h.onsuccess=()=>o({modelArtifactsInfo:l}),h.onerror=g=>{c=u.objectStore(Fl);let m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(h.error)),m.onerror=y=>(a.close(),s(h.error))}},p.onerror=d=>(a.close(),s(p.error)),u.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();var EF=t=>$().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ac.URL_SCHEME)?xQ(t.slice(ac.URL_SCHEME.length)):null;bn.registerSaveRouter(EF);bn.registerLoadRouter(EF);function xQ(t){return new ac(t)}function bQ(t){return t.startsWith(ac.URL_SCHEME)?t.slice(ac.URL_SCHEME.length):t}var Gx=class{constructor(){this.indexedDB=NF()}listModels(){return z(this,null,function*(){return new Promise((n,e)=>{let r=this.indexedDB.open(nN,rN);r.onupgradeneeded=()=>oN(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(Fl,"readonly"),a=s.objectStore(Fl).getAll();a.onsuccess=()=>{let l={};for(let u of a.result)l[u.modelPath]=u.modelArtifactsInfo;n(l)},a.onerror=l=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>e(r.error)})})}removeModel(n){return z(this,null,function*(){return n=bQ(n),new Promise((e,r)=>{let o=this.indexedDB.open(nN,rN);o.onupgradeneeded=()=>oN(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Fl,"readwrite"),a=i.objectStore(Fl),l=a.get(n),u;l.onsuccess=()=>{if(l.result==null)return s.close(),r(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{let c=a.delete(n),p=()=>{u=s.transaction(ic,"readwrite");let d=u.objectStore(ic).delete(n);d.onsuccess=()=>e(l.result.modelArtifactsInfo),d.onerror=h=>r(l.error)};c.onsuccess=p,c.onerror=f=>(p(),s.close(),r(l.error))}},l.onerror=c=>(s.close(),r(l.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})})}};var ta="/",td="tensorflowjs_models",DF="info",vQ="model_topology",wQ="weight_specs",CQ="weight_data",IQ="model_metadata";function kF(t){return{info:[td,t,DF].join(ta),topology:[td,t,vQ].join(ta),weightSpecs:[td,t,wQ].join(ta),weightData:[td,t,CQ].join(ta),modelMetadata:[td,t,IQ].join(ta)}}function AF(t){for(let n of Object.values(t))window.localStorage.removeItem(n)}function SQ(t){let n=t.split(ta);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join(ta)}function TQ(t){return t.startsWith(lc.URL_SCHEME)?t.slice(lc.URL_SCHEME.length):t}var lc=(()=>{class t{constructor(e){if(!$().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=kF(this.modelPath)}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),s=ks(e),i=Bn.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,bF(i));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw AF(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})}load(){return z(this,null,function*(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let l=JSON.parse(i);r.format=l.format,r.generatedBy=l.generatedBy,r.convertedBy=l.convertedBy,l.signature!=null&&(r.signature=l.signature),l.userDefinedMetadata!=null&&(r.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(r.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(r.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(r.trainingConfig=l.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=vF(a),r})}}return t.URL_SCHEME="localstorage://",t})();var RF=t=>$().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(lc.URL_SCHEME)?NQ(t.slice(lc.URL_SCHEME.length)):null;bn.registerSaveRouter(RF);bn.registerLoadRouter(RF);function NQ(t){return new lc(t)}var Wx=class{constructor(){D($().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return z(this,null,function*(){let n={},e=td+ta,r=ta+DF;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(r)){let i=SQ(s);n[i]=JSON.parse(this.LS.getItem(s))}}return n})}removeModel(n){return z(this,null,function*(){n=TQ(n);let e=kF(n);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${n}'`);let r=JSON.parse(this.LS.getItem(e.info));return AF(e),r})}};var nd="://",Ko=class t{constructor(){this.managers={}}static getInstance(){return t.instance==null&&(t.instance=new t),t.instance}static registerManager(n,e){D(n!=null,()=>"scheme must not be undefined or null."),n.endsWith(nd)&&(n=n.slice(0,n.indexOf(nd))),D(n.length>0,()=>"scheme must not be an empty string.");let r=t.getInstance();D(r.managers[n]==null,()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){let e=t.getInstance().managers[n];if(e==null)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(t.getInstance().managers)}};function jx(t){if(t.indexOf(nd)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ko.getSchemes().join(",")}`);return{scheme:t.split(nd)[0],path:t.split(nd)[1]}}function _F(t,n,e=!1){return z(this,null,function*(){D(t!==n,()=>`Old path and new path are the same: '${t}'`);let r=bn.getLoadHandlers(t);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);let o=r[0],s=bn.getSaveHandlers(n);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${n}.`),D(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${n}.`);let i=s[0],a=jx(t).scheme,l=jx(t).path,u=a===jx(t).scheme,c=yield o.load();e&&u&&(yield Ko.getManager(a).removeModel(l));let p=yield i.save(c);return e&&!u&&(yield Ko.getManager(a).removeModel(l)),p.modelArtifactsInfo})}function OF(){return z(this,null,function*(){let t=Ko.getSchemes(),n={};for(let e of t){let r=yield Ko.getManager(e).listModels();for(let o in r){let s=e+nd+o;n[s]=r[o]}}return n})}function FF(t){return z(this,null,function*(){let n=jx(t);return Ko.getManager(n.scheme).removeModel(n.path)})}function MF(t,n){return z(this,null,function*(){return _F(t,n,!1)})}function $F(t,n){return z(this,null,function*(){return _F(t,n,!0)})}var sN=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}setTimeoutCustom(n,e){if(typeof window>"u"||!$().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(n,e);return}this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(n){return kx(n)}};if($().get("IS_BROWSER")){$().setPlatform("browser",new sN);try{Ko.registerManager(lc.URL_SCHEME,new Wx)}catch{}try{Ko.registerManager(ac.URL_SCHEME,new Gx)}catch{}}var DQ={importFetch:()=>LF()},iN;var aN=class{constructor(){this.util=BF(),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return $().global.fetch!=null?$().global.fetch(n,e):(iN==null&&(iN=DQ.importFetch()),iN(n,e))}now(){let n=process.hrtime();return n[0]*1e3+n[1]/1e6}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return n.length===0?"":new this.util.TextDecoder(e).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}};$().get("IS_NODE")&&!$().get("IS_BROWSER")&&$().setPlatform("node",new aN);function he(t,n="float32",e){return n=n||"float32",Mt(t),new tt(t,n,e)}function kQ(t,n){let e=I(t,"x","cast");if(!FT(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if(n==="string"&&e.dtype!=="string"||n!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:e},o={dtype:n};return E.runKernel(Ss,r,o)}var K=S({cast_:kQ});function AQ(t){let e={x:I(t,"x","clone","string_or_numeric")};return E.runKernel(Ts,e)}var ir=S({clone_:AQ});function Hx(t,n=!1){console.log(t.toString(n))}XT();var RQ={buffer:he,cast:K,clone:ir,print:Hx};sF(RQ);function _Q(t,n){let e=I(t,"a","add"),r=I(n,"b","add");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(jo,o)}var W=S({add_:_Q});function OQ(t,n){let e=I(t,"a","floorDiv"),r=I(n,"b","floorDiv");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(Si,o)}var od=S({floorDiv_:OQ});function FQ(t,n){let e=I(t,"a","div"),r=I(n,"b","div");if([e,r]=ze(e,r),e.dtype==="int32"&&r.dtype==="int32")return od(e,r);let o={a:e,b:r},s={};return E.runKernel(xi,o,s)}var ne=S({div_:FQ});function MQ(t,n){let e=I(t,"a","mul"),r=I(n,"b","mul");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(Fi,o)}var R=S({mul_:MQ});function $Q(t){let n=I(t,"x","abs");if(n.dtype==="complex64"){let e={x:n};return E.runKernel(ja,e)}else{let e={x:n};return E.runKernel(Pa,e)}}var St=S({abs_:$Q});function PQ(t){let e={x:I(t,"x","acos")};return E.runKernel(ai,e)}var qx=S({acos_:PQ});function LQ(t){let e={x:I(t,"x","acosh")};return E.runKernel(li,e)}var Kx=S({acosh_:LQ});function BQ(t){D(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),D(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);let n=t.map((o,s)=>I(o,`tensors${s}`,"addN")),e=n[0];n.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(o=>{if(!_r(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=n;return E.runKernel(La,r)}var zF=S({addN_:BQ});function zQ(t,n=null,e=!1){let o={x:I(t,"x","all","bool")},s={axis:n,keepDims:e};return E.runKernel(Up,o,s)}var sd=S({all_:zQ});function VQ(t,n=null,e=!1){let o={x:I(t,"x","any","bool")},s={axis:n,keepDims:e};return E.runKernel(Gp,o,s)}var cc=S({any_:VQ});function UQ(t,n=0){let r={x:I(t,"x","argMax")},o={axis:n};return E.runKernel(Ba,r,o)}var As=S({argMax_:UQ});function GQ(t,n=0){let r={x:I(t,"x","argMin")},o={axis:n};return E.runKernel(za,r,o)}var Xx=S({argMin_:GQ});function WQ(t){let e={x:I(t,"x","asin")};return E.runKernel(ui,e)}var Yx=S({asin_:WQ});function jQ(t){let e={x:I(t,"x","asinh")};return E.runKernel(ci,e)}var Zx=S({asinh_:jQ});function HQ(t){let e={x:I(t,"x","atan")};return E.runKernel(pi,e)}var Qx=S({atan_:HQ});function qQ(t,n){let e=I(t,"a","atan2"),r=I(n,"b","atan2");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(di,o)}var Jx=S({atan2_:qQ});function KQ(t){let e={x:I(t,"x","atanh")};return E.runKernel(fi,e)}var eb=S({atanh_:KQ});function XQ(t,n,e,r,o="NHWC",s){let i=t[3],a=[...n,i],l=UF(o);return pc(t,a,e,s,r,null,null,l)}function uN(t,n,e,r,o,s,i="channelsLast"){let[a,l]=_m(n),u;if(i==="channelsLast")u=[a,l,t[3],t[3]];else if(i==="channelsFirst")u=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return pc(t,u,e,r,o,s,!1,i)}function YQ(t,n,e,r,o,s,i="NDHWC"){let[a,l,u]=lN(n),c,p;if(i==="NDHWC")p="channelsLast",c=[a,l,u,t[4],t[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return VF(t,c,e,r,o,!1,p,s)}function pc(t,n,e,r,o,s,i=!1,a="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p]=t;else if(a==="channelsFirst")[l,p,u,c]=t;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,,h]=n,[g,m]=_m(e),[y,x]=_m(r),v=id(f,y),w=id(d,x),{padInfo:T,outHeight:k,outWidth:A}=JQ(o,u,c,g,m,v,w,s,a),O=i?h*p:h,M;return a==="channelsFirst"?M=[l,O,k,A]:a==="channelsLast"&&(M=[l,k,A,O]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:p,outHeight:k,outWidth:A,outChannels:O,padInfo:T,strideHeight:g,strideWidth:m,filterHeight:f,filterWidth:d,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:x,inShape:t,outShape:M,filterShape:n}}function VF(t,n,e,r,o,s=!1,i="channelsLast",a){let[l,u,c,p,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p,f]=t;else if(i==="channelsFirst")[l,f,u,c,p]=t;else throw new Error(`Unknown dataFormat ${i}`);let[d,h,g,,m]=n,[y,x,v]=lN(e),[w,T,k]=lN(r),A=id(d,w),O=id(h,T),M=id(g,k),{padInfo:L,outDepth:V,outHeight:U,outWidth:G}=eJ(o,u,c,p,y,x,v,A,O,M,a),j=s?m*f:m,H;return i==="channelsFirst"?H=[l,j,V,U,G]:i==="channelsLast"&&(H=[l,V,U,G,j]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:p,inChannels:f,outDepth:V,outHeight:U,outWidth:G,outChannels:j,padInfo:L,strideDepth:y,strideHeight:x,strideWidth:v,filterDepth:d,filterHeight:h,filterWidth:g,effectiveFilterDepth:A,effectiveFilterHeight:O,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:T,dilationWidth:k,inShape:t,outShape:H,filterShape:n}}function ZQ(t,n,e,r,o){r==null&&(r=cN(t,n,e));let s=t[0],i=t[1],a=Om((s-n+2*r)/e+1,o),l=Om((i-n+2*r)/e+1,o);return[a,l]}function QQ(t,n,e,r,o,s){o==null&&(o=cN(t,n[0],r[0]));let i=[0,0,0,e];for(let a=0;a<3;a++)t[a]+2*o>=n[a]&&(i[a]=Om((t[a]-n[a]+2*o)/r[a]+1,s));return i}function cN(t,n,e,r=1){let o=id(n,r);return Math.floor((t[0]*(e-1)-e+o)/2)}function _m(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function lN(t){return typeof t=="number"?[t,t,t]:t}function id(t,n){return n<=1?t:t+(t-1)*(n-1)}function JQ(t,n,e,r,o,s,i,a,l){let u,c,p;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};let d=ZQ([n,e],s,r,t,a);c=d[0],p=d[1]}else if(t==="same"){c=Math.ceil(n/r),p=Math.ceil(e/o);let f=Math.max(0,(c-1)*r+s-n),d=Math.max(0,(p-1)*o+i-e),h=Math.floor(f/2),g=f-h,m=Math.floor(d/2),y=d-m;u={top:h,bottom:g,left:m,right:y,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-s+1)/r),p=Math.ceil((e-i+1)/o);else if(typeof t=="object"){let f=l==="channelsLast"?t[1][0]:t[2][0],d=l==="channelsLast"?t[1][1]:t[2][1],h=l==="channelsLast"?t[2][0]:t[3][0],g=l==="channelsLast"?t[2][1]:t[3][1];u={top:f,bottom:d,left:h,right:g,type:f===0&&d===0&&h===0&&g===0?"VALID":"EXPLICIT"},c=Om((n-s+f+d)/r+1,a),p=Om((e-i+h+g)/o+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:p}}function eJ(t,n,e,r,o,s,i,a,l,u,c){let p,f,d,h;if(t==="valid"&&(t=0),typeof t=="number"){p={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};let m=QQ([n,e,r,1],[a,l,u],1,[o,s,i],t,c);f=m[0],d=m[1],h=m[2]}else if(t==="same"){f=Math.ceil(n/o),d=Math.ceil(e/s),h=Math.ceil(r/i);let g=(f-1)*o+a-n,m=(d-1)*s+l-e,y=(h-1)*i+u-r,x=Math.floor(g/2),v=g-x,w=Math.floor(m/2),T=m-w,k=Math.floor(y/2),A=y-k;p={top:w,bottom:T,left:k,right:A,front:x,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:p,outDepth:f,outHeight:d,outWidth:h}}function Om(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function to(t){let[n,e,r]=_m(t);return n===1&&e===1&&r===1}function Rn(t,n){return to(t)||to(n)}function Rs(t){return _m(t).every(n=>n>0)}function UF(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function gt(t,n,e){if(e!=null){if(typeof n=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);if(typeof n=="number")D(ii(n),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);else if(typeof n=="object")n.forEach(r=>{r.forEach(o=>{D(ii(o),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${n}`)}}function tJ(t,n){let r={x:I(t,"x","reshape","string_or_numeric")},o={shape:n};return E.runKernel(yl,r,o)}var _=S({reshape_:tJ});function nJ(t,n,e,r,o){let s=I(t,"x","avgPool","float32"),i=1;D(Rn(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=_(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),gt("avgPool",r,o);let u={x:a},c={filterSize:n,strides:e,pad:r,dimRoundingMode:o},p=E.runKernel(Va,u,c);return p=K(p,s.dtype),l?_(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ml=S({avgPool_:nJ});function rJ(t,n,e,r,o,s="NDHWC"){let i=I(t,"x","avgPool3d","float32"),a=i,l=!1;i.rank===4&&(l=!0,a=_(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),D(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),gt("avgPool3d",r,o);let u={x:a},c={filterSize:n,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=E.runKernel(Ua,u,c);return p=K(p,a.dtype),l?_(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var tb=S({avgPool3d_:rJ});function oJ(t,n=0){D(t.length>=1,()=>"Pass at least one tensor to concat");let e=sc(t,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return ir(e[0]);let r=e,o={axis:n};return E.runKernel(Ha,r,o)}var Je=S({concat_:oJ});function sJ(t,n,e=!1,r=!1){let o=I(t,"a","matMul"),s=I(n,"b","matMul");[o,s]=ze(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:r};return E.runKernel(Ga,i,a)}var Fe=S({matMul_:sJ});function iJ(t){let e={x:I(t,"x","sigmoid","float32")};return E.runKernel(ji,e)}var _n=S({sigmoid_:iJ});function aJ(t,n,e){let r=I(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:n,size:e};return E.runKernel(Cl,o,s)}var ve=S({slice_:aJ});function lJ(t){let e={x:I(t,"x","tanh","float32")};return E.runKernel(Zi,e)}var Xo=S({tanh_:lJ});function uJ(t,n,e,r,o,s){let i=I(t,"forgetBias","basicLSTMCell"),a=I(n,"lstmKernel","basicLSTMCell"),l=I(e,"lstmBias","basicLSTMCell"),u=I(r,"data","basicLSTMCell"),c=I(o,"c","basicLSTMCell"),p=I(s,"h","basicLSTMCell"),f=Je([u,p],1),d=Fe(f,a),h=W(d,l),g=h.shape[0],m=h.shape[1]/4,y=[g,m],x=ve(h,[0,0],y),v=ve(h,[0,m],y),w=ve(h,[0,m*2],y),T=ve(h,[0,m*3],y),k=W(R(_n(x),Xo(v)),R(c,_n(W(i,w)))),A=R(Xo(k),_n(T));return[k,A]}var GF=S({basicLSTMCell_:uJ});function cJ(t,n,e){let r=I(t,"x","batchToSpaceND"),o=n.reduce((a,l)=>a*l);D(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),D(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),D(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${o}`);let s={x:r},i={blockShape:n,crops:e};return E.runKernel(Wa,s,i)}var $l=S({batchToSpaceND_:cJ});function WF(t){let n;return t.rank===0||t.rank===1?n=_(t,[1,1,1,t.size]):t.rank===2?n=_(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?n=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]):n=t,n}function pJ(t,n,e,r,o,s){s==null&&(s=.001);let i=I(t,"x","batchNorm"),a=I(n,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;r!=null&&(c=I(r,"offset","batchNorm")),D(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let f={x:WF(i),scale:u,offset:c,mean:a,variance:l},d={varianceEpsilon:s},h=E.runKernel(el,f,d);return _(h,i.shape)}var _s=S({batchNorm_:pJ});function fJ(t,n,e,r,o,s){let i=I(t,"x","batchNorm"),a=I(n,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),D(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),_s(i,a,l,c,u,s)}var nb=S({batchNorm2d_:fJ});function dJ(t,n,e,r,o,s){let i=I(t,"x","batchNorm"),a=I(n,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),D(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),_s(i,a,l,c,u,s)}var rb=S({batchNorm3d_:dJ});function hJ(t,n,e,r,o,s){let i=I(t,"x","batchNorm"),a=I(n,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),D(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),_s(i,a,l,c,u,s)}var ob=S({batchNorm4d_:hJ});function mJ(t,n,e){let r=I(t,"x","bincount"),o=I(n,"weights","bincount");D(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:e};return E.runKernel(Hp,s,i)}var sb=S({bincount_:mJ});function gJ(t,n){let e=I(t,"x","bitwiseAnd"),r=I(n,"y","bitwiseAnd");if(!_r(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if(e.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);let o={a:e,b:r};return E.runKernel(zu,o)}var jF=S({bitwiseAnd_:gJ});function yJ(t,n){let e=I(t,"s0","broadcastArgs","int32"),r=I(n,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:e,s1:r};return E.runKernel(qp,o)}var HF=S({broadcastArgs_:yJ});function xJ(t,n){let e=I(t,"broadcastTo","x"),r=e.shape;if(Mt(n),n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){let u=e.shape.slice();for(;u.length<n.length;)u.unshift(1);e=_(e,u)}let o=e.shape,s=Array.from(n);for(let u=n.length-1;u>=0;u--)if(o[u]===n[u])s[u]=1;else if(e.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return ir(e);let a={x:e},l={reps:s};return E.runKernel(Ns,a,l)}var Os=S({broadcastTo_:xJ});function bJ(t){let e={x:I(t,"x","ceil","float32")};return E.runKernel(hi,e)}var ib=S({ceil_:bJ});function Co(t,n,e){Mt(t),e=e||$a(n);let r={shape:t,value:n,dtype:e};return E.runKernel(uf,{},r)}function vJ(t,n,e){let r=I(t,"x","clipByValue");if(D(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),n===e)return Co(r.shape,n,r.dtype);let o={x:r},s={clipValueMin:n,clipValueMax:e};return E.runKernel(mi,o,s)}var vn=S({clipByValue_:vJ});function wJ(t){return Je(t,0)}var ab=S({concat1d_:wJ});function CJ(t,n){return Je(t,n)}var ad=S({concat2d_:CJ});function IJ(t,n){return Je(t,n)}var lb=S({concat3d_:IJ});function SJ(t,n){return Je(t,n)}var ub=S({concat4d_:SJ});function TJ(t,n,e,r,o="NHWC",s=[1,1],i){let a=I(t,"x","conv2d","float32"),l=I(n,"filter","conv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),gt("conv2d",r,i);let p=o==="NHWC"?u.shape[3]:u.shape[1];D(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),D(Rn(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),D(Rs(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Rs(e),()=>"Error in conv2D: Strides should be larger than 0.");let f={x:u,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=E.runKernel(qa,f,d);return c?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var vr=S({conv2d_:TJ});function NJ(t,n,e,r,o="NWC",s=1,i){let a=I(t,"x","conv1d"),l=I(n,"filter","conv1d"),u=a,c=!1;a.rank===2&&(c=!0,u=_(a,[1,a.shape[0],a.shape[1]])),D(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),D(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),gt("conv1d",r,i),D(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(Rn(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),D(Rs(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Rs(e),()=>"Error in conv1D: Stride should be larger than 0."),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=_(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=_(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=vr(f,p,[1,e],r,"NHWC",[1,s],i);return c?_(m,[m.shape[2],m.shape[3]]):_(m,[m.shape[0],m.shape[2],m.shape[3]])}var ld=S({conv1d_:NJ});function EJ(t,n,e,r,o,s="NHWC",i){D(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,u=!1;n.rank===3&&(u=!0,l=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),D(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),D(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?l.shape[3]:l.shape[1];D(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),D(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),gt("conv2dDerInput",o,i);let f={dy:l,filter:e},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},h=E.runKernel(Ka,f,d);return u?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ud=S({conv2DBackpropInput_:EJ});function DJ(t,n,e,r,o,s){let i=I(t,"x","conv2dTranspose"),a=I(n,"filter","conv2dTranspose");return ud(e,i,a,r,o,"NHWC",s)}var cd=S({conv2dTranspose_:DJ});function kJ(t,n,e,r,o="NDHWC",s=[1,1,1]){let i=I(t,"x","conv3d"),a=I(n,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=_(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),D(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),D(Rn(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),D(Rs(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Rs(e),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:a},p={strides:e,pad:r,dataFormat:o,dilations:s},f=E.runKernel(Xa,c,p);return u?_(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var cb=S({conv3d_:kJ});function AJ(t,n,e,r,o){D(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let s=t,i=n,a=!1;n.rank===4&&(a=!0,i=_(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);let l=s[4],u=i.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),D(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),D(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),D(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:r,inputShape:s},f=E.runKernel(Zp,c,p);return a?_(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var pb=S({conv3DBackpropInput_:AJ});function RJ(t,n,e,r,o){let s=I(t,"x","conv3dTranspose"),i=I(n,"filter","conv3dTranspose");return pb(e,s,i,r,o)}var fb=S({conv3dTranspose_:RJ});function _J(t){let e={x:I(t,"x","cos","float32")};return E.runKernel(gi,e)}var Pl=S({cos_:_J});function OJ(t){let e={x:I(t,"x","cosh","float32")};return E.runKernel(yi,e)}var pd=S({cosh_:OJ});function FJ(t,n=0,e=!1,r=!1){let s={x:I(t,"x","cumprod")},i={axis:n,exclusive:e,reverse:r};return E.runKernel(Qp,s,i)}var fc=S({cumprod_:FJ});function MJ(t,n=0,e=!1,r=!1){let s={x:I(t,"x","cumsum")},i={axis:n,exclusive:e,reverse:r};return E.runKernel(Ya,s,i)}var fd=S({cumsum_:MJ});function $J(t,n,e,r=!1){let o=I(t,"x","denseBincount"),s=I(n,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:r};return E.runKernel(ef,i,a)}var Fm=S({denseBincount_:$J});function PJ(t,n,e="NHWC"){let r=I(t,"x","depthToSpace","float32"),o=e==="NHWC"?r.shape[1]:r.shape[2],s=e==="NHWC"?r.shape[2]:r.shape[3],i=e==="NHWC"?r.shape[3]:r.shape[1];D(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),D(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${n}  for depthToSpace with input shape
    ${r.shape}`),D(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${n} for depthToSpace with input shape
        ${r.shape}`),D(i%(n*n)===0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},l={blockSize:n,dataFormat:e};return E.runKernel(tf,a,l)}var db=S({depthToSpace_:PJ});function LJ(t,n,e,r,o="NHWC",s=[1,1],i){let a=I(t,"x","depthwiseConv2d","float32"),l=I(n,"filter","depthwiseConv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p=o==="NHWC"?u.shape[3]:u.shape[1];D(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),gt("depthwiseConv2d",r,i);let f={x:u,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=E.runKernel(Za,f,d);return c?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Fs=S({depthwiseConv2d_:LJ});function BJ(t){let e={x:I(t,"x","diag")};return E.runKernel(of,e)}var qF=S({diag_:BJ});function zJ(t,n,e,r,o=[1,1],s="NHWC"){let i=I(t,"x","dilation2d"),a=I(n,"filter","dilation2d");D(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),D(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=_(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),D(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);let c={x:l,filter:a},p={strides:e,pad:r,dilations:o},f=E.runKernel(Qa,c,p);return u?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var hb=S({dilation2d_:zJ});var Mr={};ft(Mr,{assertAndGetBroadcastShape:()=>De,getBroadcastDims:()=>KF,getReductionAxes:()=>dt});function KF(t,n){let e=t.length,r=[];for(let o=0;o<e;o++){let s=e-1-o,i=t[s]||1;(n[n.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function dt(t,n){let e=[];for(let r=0;r<n.length;r++){let o=t[t.length-r-1],s=n.length-r-1,i=n[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function De(t,n){let e=Math.max(t.length,n.length),r=new Array(e);for(let o=0;o<e;o++){let s=t[t.length-o-1];s==null&&(s=1);let i=n[n.length-o-1];if(i==null&&(i=1),s===1)r[e-o-1]=i;else if(i===1)r[e-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${t} and ${n}.`;throw Error(a)}else r[e-o-1]=s}return r}function VJ(t,n){let e=I(t,"a","equal","string_or_numeric"),r=I(n,"b","equal","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Vu,o)}var Zn=S({equal_:VJ});function UJ(t,n,e){let r=I(n,"a","where"),o=I(e,"b","where"),s=I(t,"condition","where","bool"),i=De(De(s.shape,r.shape),o.shape),a=Os(s,i),l=Os(r,i),u=Os(o,i),c={condition:a,t:l,e:u};return E.runKernel(wl,c)}var yt=S({where_:UJ});function GJ(t){let e={x:I(t,"x","zerosLike")};return E.runKernel(kl,e)}var ye=S({zerosLike_:GJ});function WJ(t,n){let e=I(t,"a","div"),r=I(n,"b","div");[e,r]=ze(e,r);let o=ne(e,r),s=ye(o),i=Zn(r,s);return yt(i,s,o)}var mb=S({divNoNan_:WJ});function jJ(t,n){let e=I(t,"t1","dot"),r=I(n,"t2","dot");D((e.rank===1||e.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=r.rank===1?r.size:r.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&r.rank===1){let i=_(e,[1,-1]),a=_(r,[-1,1]),l=Fe(i,a);return _(l,[])}else if(e.rank===1&&r.rank===2){let i=_(e,[1,-1]),a=_(r,[r.shape[0],r.shape[1]]),l=Fe(i,a);return _(l,[l.size])}else if(e.rank===2&&r.rank===1){let i=_(r,[-1,1]),a=Fe(e,i);return _(a,[a.size])}else{let i=_(r,[r.shape[0],r.shape[1]]);return Fe(e,i)}}var gb=S({dot_:jJ});function HJ(t,...n){let e=n.map((o,s)=>I(o,`tensors${s}`,"einsum")),r={equation:t};return E.runKernel(sf,e,r)}var Ll=S({einsum_:HJ});function qJ(t){let e={x:I(t,"x","elu","float32")};return E.runKernel(bi,e)}var Ms=S({elu_:qJ});function KJ(t,n){let e=I(t,"x","ensureShape","string_or_numeric");if(!AT(e.shape,n))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${n}`);return t}var XF=S({ensureShape_:KJ});function XJ(t){let n=I(t,"x","erf");D(n.dtype==="int32"||n.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),n.dtype==="int32"&&(n=K(n,"float32"));let e={x:n};return E.runKernel(vi,e)}var dd=S({erf_:XJ});function pN(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function YF(t,n,e){let r=t.length+n.length,o=[],s=0,i=0;for(let a=0;a<r;a++)e.indexOf(a)===-1?o.push(t[s++]):o.push(n[i++]);return o}function fN(t,n){let e=[],r=t.length;for(let s=0;s<r;s++)n.indexOf(s)===-1&&e.push(t[s]);let o=n.map(s=>t[s]);return[e,o]}function Io(t,n){let e=n.map(r=>1);return YF(t,e,n)}function YJ(t,n,e){D(pN(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function dN(t,n){if(pN(t,n))return null;let e=[];for(let r=0;r<n;++r)t.indexOf(r)===-1&&e.push(r);return t.forEach(r=>e.push(r)),e}function Mm(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function ZJ(t,n){let e=[];for(let r=n-t;r<n;++r)e.push(r);return e}function QJ(t,n=null,e=!1){let o={x:I(t,"x","max")},s={reductionIndices:n,keepDims:e};return E.runKernel(ol,o,s)}var wn=S({max_:QJ});function JJ(t,n=null,e=!1){let o={x:I(t,"x","min")},s={axis:n,keepDims:e};return E.runKernel(ll,o,s)}var na=S({min_:JJ});function eee(t,n){let e=I(t,"base","pow"),r=I(n,"exp","pow");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(Mi,o)}var zn=S({pow_:eee});function se(t,n){if((Yn(t)&&n!=="string"||Array.isArray(t))&&n!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(n==="string"&&Yn(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return sr(t,[],[],n)}function tee(t){let e={x:I(t,"x","sqrt","float32")};return E.runKernel(qi,e)}var ct=S({sqrt_:tee});function nee(t){let n=I(t,"x","square"),e={};return E.runKernel("Square",{x:n},e)}var _e=S({square_:nee});function ree(t,n=null,e=!1){let r=I(t,"x","sum");r.dtype==="bool"&&(r=K(r,"int32"));let o={x:r},s={axis:n,keepDims:e};return E.runKernel(Il,o,s)}var ie=S({sum_:ree});function oee(t,n="euclidean",e=null,r=!1){t=I(t,"x","norm");let o=ZF(t,n,e),s=o.shape;if(r){let i=ln(e,t.shape);s=Io(o.shape,i)}return _(o,s)}function ZF(t,n,e=null){if(t.rank===0)return St(t);if(t.rank!==1&&e===null)return ZF(_(t,[-1]),n,e);if(t.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(n===1)return ie(St(t),e);if(n===1/0)return wn(St(t),e);if(n===-1/0)return na(St(t),e);if(n==="euclidean"||n===2)return ct(ie(zn(St(t),se(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&e.length===2){if(n===1)return wn(ie(St(t),e[0]),e[1]-1);if(n===1/0)return wn(ie(St(t),e[1]),e[0]);if(n===-1/0)return na(ie(St(t),e[1]),e[0]);if(n==="fro"||n==="euclidean")return ct(ie(_e(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var ra=S({norm_:oee});function see(t,n=null,e=!1){return ra(t,"euclidean",n,e)}var yb=S({euclideanNorm_:see});function iee(t){let e={x:I(t,"x","exp")};return E.runKernel(wi,e)}var Ht=S({exp_:iee});function aee(t,n=0){let e=I(t,"x","expandDims","string_or_numeric");D(n<=e.rank,()=>"Axis must be <= rank of the tensor");let r={input:e},o={dim:n};return E.runKernel(Ja,r,o)}var Pt=S({expandDims_:aee});function lee(t){let e={x:I(t,"x","expm1")};return E.runKernel(Ci,e)}var xb=S({expm1_:lee});function uee(t,n){let e=I(t,"x","tile","string_or_numeric");D(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`);let r={x:e},o={reps:n};return E.runKernel(Ns,r,o)}var On=S({tile_:uee});function cee(t,n,e,r="float32"){n==null&&(n=t);let o=he([t,n],r),s=t<=n?t:n;for(let a=0;a<s;++a)o.set(1,a,a);let i=_(o.toTensor(),[t,n]);if(e==null)return i;if(e.length===1)return On(Pt(i,0),[e[0],1,1]);if(e.length===2)return On(Pt(Pt(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return On(Pt(Pt(Pt(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var dc=S({eye_:cee});function pee(t){let e={x:I(t,"x","floor","float32")};return E.runKernel(Ii,e)}var $s=S({floor_:pee});function fee(t,n,e=0,r=0){let o=I(t,"x","gather"),s=I(n,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:r};return E.runKernel(tl,i,a)}var Ps=S({gather_:fee});function dee(t,n){let e=I(t,"a","greater","string_or_numeric"),r=I(n,"b","greater","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Uu,o)}var Lt=S({greater_:dee});function hee(t,n){let e=I(t,"a","greaterEqual","string_or_numeric"),r=I(n,"b","greaterEqual","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Ti,o)}var ar=S({greaterEqual_:hee});function mee(t){let e={input:I(t,"input","imag")};return E.runKernel(df,e)}var Bl=S({imag_:mee});function gee(t){let e={x:I(t,"x","isFinite")};return E.runKernel(Ni,e)}var bb=S({isFinite_:gee});function yee(t){let e={x:I(t,"x","isInf")};return E.runKernel(Ei,e)}var vb=S({isInf_:yee});function xee(t){let e={x:I(t,"x","isNaN")};return E.runKernel(Di,e)}var wb=S({isNaN_:xee});function bee(t,n=.2){let r={x:I(t,"x","leakyRelu")},o={alpha:n};return E.runKernel(nl,r,o)}var zl=S({leakyRelu_:bee});function vee(t,n){let e=I(t,"a","less","string_or_numeric"),r=I(n,"b","less","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Gu,o)}var oa=S({less_:vee});function wee(t,n){let e=I(t,"a","lessEqual","string_or_numeric"),r=I(n,"b","lessEqual","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Wu,o)}var $r=S({lessEqual_:wee});function QF(t,n,e){if(e<=0)throw new Error("The number of values should be positive.");let r={start:t,stop:n,num:e};return E.runKernel(hf,{},r)}function Cee(t,n=5,e=1,r=1,o=.5){let s=I(t,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(ii(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=_(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:n,bias:e,alpha:r,beta:o},c=E.runKernel(rl,l,u);return a?_(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Cb=S({localResponseNormalization_:Cee});function Iee(t){let e={x:I(t,"x","log","float32")};return E.runKernel(ki,e)}var Cn=S({log_:Iee});function See(t){let e={x:I(t,"x","log1p")};return E.runKernel(Ai,e)}var Vl=S({log1p_:See});function mN(t,n){D(Bp(t),()=>"The f passed in variableGrads(f) must be a function"),D(n==null||Array.isArray(n)&&n.every(u=>u instanceof Ji),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=n!=null;if(!e){n=[];for(let u in E.registeredVariables)n.push(E.registeredVariables[u])}let r=e?n.filter(u=>!u.trainable):null,o=n.length;n=n.filter(u=>u.trainable),D(n.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=E.gradients(t,n,null,s);D(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return n.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function wr(t){return E.customGrad(t)}function Tee(t){let e={x:I(t,"x","neg")};return E.runKernel(cl,e)}var $e=S({neg_:Tee});function Nee(t){let e={x:I(t,"x","softplus")};return E.runKernel(Hi,e)}var Yo=S({softplus_:Nee});function Eee(t){let n=I(t,"x","logSigmoid");return wr(r=>({value:$e(Yo($e(r))),gradFunc:i=>R(i,_n($e(r)))}))(n)}var Ib=S({logSigmoid_:Eee});function Dee(t,n){let e=I(t,"a","sub"),r=I(n,"b","sub");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(Xi,o)}var te=S({sub_:Dee});function kee(t,n=-1){let e=I(t,"logits","logSoftmax");if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return wr((o,s)=>{let a=wn(o,n,!0),l=te(o,a),u=te(K(l,"float32"),Cn(ie(Ht(l),n,!0)));return s([u]),{value:u,gradFunc:(p,f)=>{let[d]=f,h=!0,g=Ht(d);return te(p,R(ie(p,n,h),g))}}})(e)}var hd=S({logSoftmax_:kee});function Aee(t,n=null,e=!1){let r=I(t,"x","logSumExp"),o=ln(n,r.shape),s=wn(r,o,!0),i=te(r,s),a=Ht(i),l=ie(a,o),u=Cn(l),c=W(_(s,u.shape),u);if(e){let p=Io(c.shape,o);return _(c,p)}return c}var Ul=S({logSumExp_:Aee});function Ree(t,n){let e=I(t,"a","logicalAnd","bool"),r=I(n,"b","logicalAnd","bool");De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(ju,o)}var Vn=S({logicalAnd_:Ree});function _ee(t){let e={x:I(t,"x","logicalNot","bool")};return E.runKernel(Hu,e)}var Gl=S({logicalNot_:_ee});function Oee(t,n){let e=I(t,"a","logicalOr","bool"),r=I(n,"b","logicalOr","bool");De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(qu,o)}var md=S({logicalOr_:Oee});function Fee(t,n){let e=I(t,"a","logicalXor","bool"),r=I(n,"b","logicalXor","bool");return De(e.shape,r.shape),Vn(md(t,n),Gl(Vn(t,n)))}var Sb=S({logicalXor_:Fee});var Tb=2147483648;function Mee(t,n,e="left"){let r=I(t,"sortedSequence","searchSorted"),o=I(n,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=_(r,[-1,s]),l=_(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Le(l.shape)>=Tb)throw new Error(`values tensor size must less than ${Tb}`);if(a.shape[1]>=Tb)throw new Error(`trailing dim_size must less than ${Tb} for int32 output type, was ${a.shape[1]}`);let u={sortedSequence:a,values:l},c={side:e};return E.runKernel(_f,u,c)}var $m=S({searchSorted_:Mee});function JF(t,n){return $m(t,n,"left")}function $ee(t,n,e,r,o){let s=I(t,"x","maxPool"),i=1,a=s,l=!1;s.rank===3&&(l=!0,a=_(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),D(Rn(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),gt("maxPool",r,o);let u={x:a},c={filterSize:n,strides:e,pad:r,dimRoundingMode:o},p=E.runKernel(sl,u,c);return l?_(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Wl=S({maxPool_:$ee});function Pee(t,n=[1,1,1],e,r,o,s="NDHWC"){let i=I(t,"x","maxPool3d"),a=i,l=!1;i.rank===4&&(l=!0,a=_(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),gt("maxPool3d",r,o);let u={x:a},c={filterSize:n,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=E.runKernel(il,u,c);return l?_(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Nb=S({maxPool3d_:Pee});function Lee(t,n,e,r,o=!1){let i={x:I(t,"x","maxPoolWithArgmax")},a={filterSize:n,strides:e,pad:r,includeBatchInIndex:o},l=E.runKernel(xf,i,a);return{result:l[0],indexes:l[1]}}var eM=S({maxPoolWithArgmax_:Lee});function Bee(t,n){let e=I(t,"a","maximum"),r=I(n,"b","maximum");[e,r]=ze(e,r),e.dtype==="bool"&&(e=K(e,"int32"),r=K(r,"int32")),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Ri,o)}var Cr=S({maximum_:Bee});function zee(t,n=null,e=!1){let o={x:I(t,"x","mean")},s={axis:n,keepDims:e};return E.runKernel(al,o,s)}var xt=S({mean_:zee});function bt(t,n="float32"){if(Mt(t),n==="complex64"){let r=bt(t,"float32"),o=bt(t,"float32");return br(r,o)}let e=Vp(Le(t),n);return E.makeTensor(e,t,n)}function en(t,n="float32"){if(Mt(t),n==="complex64"){let r=en(t,"float32"),o=bt(t,"float32");return br(r,o)}let e=xm(Le(t),n);return E.makeTensor(e,t,n)}function tM(t,n,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=I(t,"x","meshgrid",t instanceof Pe?t.dtype:"float32");if(n===void 0)return[r];let o=I(n,"y","meshgrid",n instanceof Pe?n.dtype:"float32"),s=Le(r.shape),i=Le(o.shape);return e==="xy"?(r=_(r,[1,-1]),o=_(o,[-1,1]),[Fe(en([i,1],r.dtype),r),Fe(o,en([1,s],o.dtype))]):(r=_(r,[-1,1]),o=_(o,[1,-1]),[Fe(r,en([1,i],r.dtype)),Fe(en([s,1],o.dtype),o)])}function Vee(t,n){let e=I(t,"a","minimum"),r=I(n,"b","minimum");[e,r]=ze(e,r),e.dtype==="bool"&&(e=K(e,"int32"),r=K(r,"int32")),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(_i,o)}var ro=S({minimum_:Vee});function Uee(t,n,e){D(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let r=I(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<r.rank;a++)D(n[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(n[a][0]>=0&&n[a][0]<=r.shape[a]-o&&n[a][1]>=0&&n[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:n,mode:e},i={x:r};return E.runKernel(ul,i,s)}var Eb=S({mirrorPad_:Uee});function Gee(t,n){let e=I(t,"a","mod"),r=I(n,"b","mod");[e,r]=ze(e,r);let o={a:e,b:r};return E.runKernel(Oi,o)}var Db=S({mod_:Gee});function Wee(t,n=null,e=!1){t=I(t,"x","moments");let r=ln(n,t.shape),o=xt(t,r,e),s=o.shape;e||(s=Io(o.shape,r));let i=_e(te(K(t,"float32"),_(o,s))),a=xt(i,r,e);return{mean:o,variance:a}}var hc=S({moments_:Wee});function jee(t,n,e,r){let o=I(n,"data","multiRNNCell"),s=sc(e,"c","multiRNNCell"),i=sc(r,"h","multiRNNCell"),a=o,l=[];for(let p=0;p<t.length;p++){let f=t[p](a,s[p],i[p]);l.push(f[0]),l.push(f[1]),a=f[1]}let u=[],c=[];for(let p=0;p<l.length;p+=2)u.push(l[p]),c.push(l[p+1]);return[u,c]}var nM=S({multiRNNCell_:jee});function Hee(t,n,e,r=!1){let o=I(t,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let l={logits:i===1?_(o,[1,-1]):o},u={numSamples:n,seed:e,normalized:r},c=E.runKernel(bf,l,u);return i===1?_(c,[c.size]):c}var rM=S({multinomial_:Hee});function qee(t,n){let e=I(t,"a","notEqual","string_or_numeric"),r=I(n,"b","notEqual","string_or_numeric");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Ku,o)}var Zo=S({notEqual_:qee});function Kee(t,n,e=1,r=0,o="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);let i={indices:I(t,"indices","oneHot","int32")},a={dtype:o,depth:n,onValue:e,offValue:r};return E.runKernel(fl,i,a)}var mc=S({oneHot_:Kee});function Xee(t){let e={x:I(t,"x","onesLike")};return E.runKernel(pl,e)}var hn=S({onesLike_:Xee});function Yee(t,n){let e=I(t,"v1","outerProduct"),r=I(n,"v2","outerProduct");D(e.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);let o=_(e,[-1,1]),s=_(r,[1,-1]);return Fe(o,s)}var oM=S({outerProduct_:Yee});function Zee(t,n,e=0){let r=I(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:n,constantValue:e},s={x:r};return E.runKernel(hl,s,o)}var lr=S({pad_:Zee});function Qee(t,n,e=0){return D(n.length===2,()=>"Invalid number of paddings. Must be length of 2."),lr(t,[n],e)}var sM=S({pad1d_:Qee});function Jee(t,n,e=0){return D(n.length===2&&n[0].length===2&&n[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),lr(t,n,e)}var iM=S({pad2d_:Jee});function ete(t,n,e=0){return D(n.length===3&&n[0].length===2&&n[1].length===2&&n[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),lr(t,n,e)}var aM=S({pad3d_:ete});function tte(t,n,e=0){return D(n.length===4&&n[0].length===2&&n[1].length===2&&n[2].length===2&&n[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),lr(t,n,e)}var lM=S({pad4d_:tte});function nte(t,n,e){let r=I(t,"x","spaceToBatchND");D(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),D(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),D(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`);let o={x:r},s={blockShape:n,paddings:e};return E.runKernel(Sl,o,s)}var jl=S({spaceToBatchND_:nte});function rte(t,n,e,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=I(t,"x","maxPool"),l=a,u=!1;a.rank===3&&(u=!0,l=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(Rn(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=uN(l.shape,n,s,o,r),p=[c.dilationHeight,c.dilationWidth],f;r==="same"?f=ste([c.filterHeight,c.filterWidth],p):f=[[0,0],[0,0]];let d=p[0]===1&&p[1]===1,[h,g]=ote([c.inHeight,c.inWidth],p,f),m=d?r:"valid",y=d?l:jl(l,p,h),v=(e==="avg"?()=>Ml(y,n,s,m,i):()=>Wl(y,n,s,m,i))(),w=d?v:$l(v,p,g);return u?_(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function ote(t,n,e){let r=e.map(c=>c[0]),o=e.map(c=>c[1]),s=t.concat(r,o),i=n.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),l=n.map((c,p)=>[r[p],a[p]]),u=n.map((c,p)=>[0,i[p]]);return[l,u]}function ste(t,n){let r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var kb=S({pool_:rte});function ite(t,n){let e=I(t,"x","prelu"),r=I(n,"alpha","prelu"),o={x:e,alpha:r};return E.runKernel(ml,o)}var Hl=S({prelu_:ite});function ate(t,n=null,e=!1){let r=I(t,"x","prod");r.dtype==="bool"&&(r=K(r,"int32"));let o={x:r},s={axis:n,keepDims:e};return E.runKernel(gl,o,s)}var Ab=S({prod_:ate});function lte(t,n,e,r){let o=t.map((c,p)=>I(c,`tensors${p}`,"raggedGather","int32")),s=I(n,"paramsDenseValues","raggedGather"),i=I(e,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},u=E.runKernel(If,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var uM=S({raggedGather_:lte});function ute(t,n,e){let r=I(t,"starts","raggedRange"),o=I(n,"limits","raggedRange",r.dtype),s=I(e,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=E.runKernel(Sf,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var cM=S({raggedRange_:ute});function cte(t,n,e,r,o){let s=I(t,"shape","raggedTensorToTensor","int32"),i=I(n,"values","raggedTensorToTensor"),a=I(e,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((p,f)=>I(p,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:o};return E.runKernel(Tf,u,c)}var pM=S({raggedTensorToTensor_:cte});function pte(t,n,e){Mt(t);let r=Le(t),o=null;if(e==null||e==="float32")o=new Float32Array(r);else if(e==="int32")o=new Int32Array(r);else if(e==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<r;s++)o[s]=n();return E.makeTensor(o,t,e)}var fM=S({rand_:pte});var Fb=Sh(Pm());var yc=class{constructor(n,e,r,o,s){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Fb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let n,e,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return this.dtype==null||this.dtype==="float32"?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}},_b=class{constructor(n,e,r,o){this.alpha=n,this.beta=1/e,this.dtype=r;let s=o||Math.random();this.randu=Fb.alea(s.toString()),this.randn=new yc(0,1,r,!1,this.randu()),n<1?this.d=n+2/3:this.d=n-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let n,e,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,n=o*o,e=1-.331*n*n,r=.5*n+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(n){return this.dtype==="float32"?n:Math.round(n)}},Ob=class{constructor(n=0,e=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=n,this.range=e-n,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=Fb.alea(o)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function xte(t,n,e=1,r="float32",o){if(Mt(t),e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new _b(n,e,r,o),i=he(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var kM=S({randomGamma_:xte});function bte(t,n=0,e=1,r,o){if(Mt(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new yc(n,e,r,!1,o),i=he(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var xc=S({randomNormal_:bte});function vte(t,n,e){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);return xc(t,0,1,n,e)}var AM=S({randomStandardNormal_:vte});function wte(t,n=0,e=1,r="float32",o){Mt(t);let s=he(t,r),i=new Ob(n,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Pr=S({randomUniform_:wte});function Cte(t,n,e,r){return Pr(t,n,e,"int32",r)}var RM=S({randomUniformInt_:Cte});function Ls(t,n,e=1,r="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:t,stop:n,step:e,dtype:r};return E.runKernel(Nf,{},o)}function Ite(t){let e={input:I(t,"input","real")};return E.runKernel(Ef,e)}var sa=S({real_:Ite});function Ste(t){let e={x:I(t,"x","reciprocal")};return E.runKernel($i,e)}var Mb=S({reciprocal_:Ste});function Tte(t){let e={x:I(t,"x","relu")};return E.runKernel(Pi,e)}var Fn=S({relu_:Tte});function Nte(t){let e={x:I(t,"x","relu6")};return E.runKernel(Li,e)}var gd=S({relu6_:Nte});function Ete(t,n){let r={x:I(t,"x","reverse")},o={dims:n};return E.runKernel(vl,r,o)}var un=S({reverse_:Ete});function Dte(t){let n=I(t,"x","reverse");return D(n.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${n.rank}.`),un(n,0)}var _M=S({reverse1d_:Dte});function kte(t,n){let e=I(t,"x","reverse");return D(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),un(e,n)}var OM=S({reverse2d_:kte});function Ate(t,n){let e=I(t,"x","reverse");return D(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),un(e,n)}var FM=S({reverse3d_:Ate});function Rte(t,n){let e=I(t,"x","reverse");return D(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),un(e,n)}var MM=S({reverse4d_:Rte});function _te(t){let e={x:I(t,"x","round")};return E.runKernel(Bi,e)}var yd=S({round_:_te});function Ote(t){let e={x:I(t,"x","rsqrt","float32")};return E.runKernel(zi,e)}var xd=S({rsqrt_:Ote});function Fte(t){let e={x:I(t,"x","selu")};return E.runKernel(Vi,e)}var bd=S({selu_:Fte});function Mte(t,n,e,r,o,s=[1,1],i="NHWC"){let a=I(t,"x","separableConv2d"),l=I(n,"depthwiseFilter","separableConv2d"),u=I(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),D(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let f=l.shape[2],d=l.shape[3];D(u.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${u.shape[2]}.`);let h=Fs(c,l,r,o,i,s),m=vr(h,u,1,"valid",i);return p?_(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var vd=S({separableConv2d_:Mte});function $te(t,n){return z(this,null,function*(){let e=I(t,"x","setdiff1d"),r=I(n,"y","setdiff1d");D(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),D(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),D(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=yield e.data(),s=yield r.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let l=new tt([a],e.dtype),u=new tt([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(l.values[p]=o[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]})}var $M=$te;function Pte(t){let e={x:I(t,"x","sign")};return E.runKernel(Wi,e)}var $b=S({sign_:Pte});function Lte(t){let e={x:I(t,"x","sin","float32")};return E.runKernel(Ui,e)}var wd=S({sin_:Lte});function Bte(t){let e={x:I(t,"x","sinh")};return E.runKernel(Gi,e)}var Cd=S({sinh_:Bte});function zte(t,n,e){let r=I(t,"x","slice1d");return D(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ve(r,[n],[e])}var Id=S({slice1d_:zte});function Vte(t,n,e){let r=I(t,"x","slice2d");return D(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ve(r,n,e)}var Lm=S({slice2d_:Vte});function Ute(t,n,e){let r=I(t,"x","slice3d");return D(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ve(r,n,e)}var Sd=S({slice3d_:Ute});function Gte(t,n,e){let r=I(t,"x","slice4d");return D(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ve(r,n,e)}var bc=S({slice4d_:Gte});function Wte(t,n=-1){let e=I(t,"logits","softmax","float32");if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);let r={logits:e},o={dim:n};return E.runKernel(Nl,r,o)}var ql=S({softmax_:Wte});function jte(t){D(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);let n={input:t};return E.runKernel(lf,n)}var Kl=S({fft_:jte});function Hte(t){D(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);let n={input:t};return E.runKernel(ff,n)}var ia=S({ifft_:Hte});function qte(t){let n=t.shape[t.shape.length-1],e=t.size/n,r;if(n<=2){let o=_(t,[e,n]);r=ia(o)}else{let o=[e,2*(n-1)],s=_(sa(t),[e,n]),i=_(Bl(t),[e,n]),a=un(ve(s,[0,1],[e,n-2]),1),l=R(un(ve(i,[0,1],[e,n-2]),1),se(-1)),u=Je([s,a],1),c=Je([i,l],1),p=_(br(u,c),[o[0],o[1]]);r=ia(p)}if(r=sa(r),t.rank===3&&t.shape[0]!==0){let o=r,s=t.shape[0];r=_(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var Td=S({irfft_:qte});function Kte(t,n,e=0){let o={x:I(t,"x","split")},s={numOrSizeSplits:n,axis:e};return E.runKernel(Tl,o,s)}var cn=S({split_:Kte});function Xte(t,n){D(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1],r=t.size/e,o;if(n!=null&&n<e){let h=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=n,o=ve(t,h,g),e=n}else if(n!=null&&n>e){let h=t.shape.map(g=>g);h[t.shape.length-1]=n-e,o=Je([t,bt(h)],t.shape.length-1),e=n}else o=t;let s=ye(o),i=_(br(o,s),[r,e]),a=Kl(i),l=Math.floor(e/2)+1,u=sa(a),c=Bl(a),p=cn(u,[l,e-l],u.shape.length-1),f=cn(c,[l,e-l],c.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=l,_(br(p[0],f[0]),d)}var Xl=S({rfft_:Xte});function Yte(t,n){let e=I(t,"a","squaredDifference"),r=I(n,"b","squaredDifference");[e,r]=ze(e,r),De(e.shape,r.shape);let o={a:e,b:r},s={};return E.runKernel(Ki,o,s)}var Nd=S({squaredDifference_:Yte});function Zte(t,n){let e=I(t,"x","squeeze","string_or_numeric");return _(e,RT(e.shape,n).newShape)}var Qn=S({squeeze_:Zte});function Qte(t,n=0){let e=sc(t,"tensors","stack","string_or_numeric");D(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&D(n<=e[0].rank,()=>"Axis must be <= rank of the tensor");let r=e,o={axis:n};return E.runKernel(dl,r,o)}var Bt=S({stack_:Qte});function Jte(t,n=0){let r={x:I(t,"x","step")},o={alpha:n};return E.runKernel(Qi,r,o)}var So=S({step_:Jte});function ene(t,n,e,r,o=0,s=0,i=0,a=0,l=0){let c={x:I(t,"x","stridedSlice","string_or_numeric")},p={begin:n,end:e,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return E.runKernel(Bf,c,p)}var Pb=S({stridedSlice_:ene});function tne(t){let e={x:I(t,"x","tan","float32")};return E.runKernel(Yi,e)}var Lb=S({tan_:tne});function Tt(t,n){eo(t);let e=xr(t,n);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return sr(t,null,e,n)}function Qo(t,n,e){if(eo(t),n!=null&&n.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=xr(t,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return sr(t,n,r,e)}function Bb(t,n,e){if(eo(t),n!=null&&n.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=xr(t,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return sr(t,n,r,e)}function PM(t,n,e){if(eo(t),n!=null&&n.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=xr(t,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return sr(t,n,r,e)}function LM(t,n,e){if(eo(t),n!=null&&n.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=xr(t,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return sr(t,n,r,e)}function BM(t,n,e){if(eo(t),n!=null&&n.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=xr(t,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return n=n||r,sr(t,n,r,e)}function zM(t,n,e){let r=n.rank>1?n.shape[n.rank-1]:1,o=n.rank>1?n.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(t.length<r+(e.rank-o))throw new Error(s+` Output shape length < ${r+(e.rank-o)}`);if(e.rank!==o+t.length-r)throw new Error(s+` update.rank != ${o+t.length-r}`);for(let i=0;i<o;++i)if(e.shape[i]!==n.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==t[i+r])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${t[i+o]})`)}function Bm(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(n.size===0)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}zM(e,n,t)}function nne(t,n,e){let r=n.shape.length,o=r>1?n.shape[r-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,l=Le(n.shape)/a,u=[...Is(e.slice(0,o)),1],c=Le(e);return{sliceRank:o,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function rne(t,n,e){let r=I(t,"tensor","tensorScatterupdate"),o=I(n,"indices","tensorScatterupdate","int32"),s=I(e,"updates","tensorScatterupdate");if(Bm(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return E.runKernel(Rf,i,a)}var UM=S({tensorScatterUpdate_:rne});function one(t,n=1,e=!0){let r=I(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${n}`);let s={x:r},i={k:n,sorted:e},[a,l]=E.runKernel(Gf,s,i);return{values:a,indices:l}}var zb=S({topk_:one});function sne(t,n=0,e=1,r,o){if(Mt(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new yc(n,e,r,!0,o),i=he(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Ed=S({truncatedNormal_:sne});function ine(t,n=0){let e=I(t,"x","unique","string_or_numeric");D(e.rank>0,()=>"The input tensor must be at least 1D");let r={x:e},o={axis:n},[s,i]=E.runKernel(jf,r,o);return{values:s,indices:i}}var Vb=S({unique_:ine});function ane(t,n,e){let r=I(t,"x","unsortedSegmentSum"),o=I(n,"segmentIds","unsortedSegmentSum","int32");D(ii(e),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:e};return E.runKernel(Dl,s,i)}var Dd=S({unsortedSegmentSum_:ane});function lne(t,n=0){let e=I(t,"x","unstack","string_or_numeric");D(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`);let r={value:e},o={axis:n};return E.runKernel(El,r,o)}var pn=S({unstack_:lne});function GM(t,n){return $m(t,n,"right")}function Ub(t,n=!0,e,r){return E.makeVariable(t,n,e,r)}function Gb(t,n){let e=[];for(let s=0;s<n.length;s++)n[s]&&e.push(s);let r=he(t,"int32"),o=he([e.length,t.length],"int32");for(let s=0;s<e.length;s++){let i=r.indexToLoc(e[s]),a=s*t.length;o.values.set(i,a)}return o.toTensor()}function une(t){return z(this,null,function*(){let n=I(t,"condition","whereAsync","bool"),e=yield n.data(),r=Gb(n.shape,e);return t!==n&&n.dispose(),r})}var Wb=une;function cne(t,n,e){return z(this,null,function*(){let r=I(t,"tensor","boolMask"),o=I(n,"mask","boolMask","bool"),s=e??0,i=o.rank,a=r.shape;D(i>0,()=>"mask cannot be scalar"),Kt(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=s;g<s+i;g++)l*=a[g];let u=a.slice(0,s).concat([l],a.slice(s+i)),c=_(r,u),p=_(o,[-1]),f=yield Wb(p),d=Qn(f,[1]),h=Ps(c,d,s);return t!==r&&r.dispose(),n!==o&&o.dispose(),d.dispose(),c.dispose(),p.dispose(),f.dispose(),h})}var pne=cne;function fne(t,n,e){let r=I(t,"x","transpose");if(n==null&&(n=r.shape.map((i,a)=>a).reverse()),D(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{D(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:n};return r.dtype==="complex64"?B(()=>{let i=sa(r),a=Bl(r);return i=E.runKernel(Es,{x:i},s),a=E.runKernel(Es,{x:a},s),e&&(a=$e(a)),br(i,a)}):E.runKernel(Es,o,s)}var Me=S({transpose_:fne});function dne(t,n,e,r,o=!0){let s=I(t,"v","movingAverage"),i=I(n,"x","movingAverage"),a=I(e,"decay","movingAverage");pF(s,i),D(_r(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=se(1),u=te(l,a),c=R(te(i,s),u);if(o){D(r!=null,()=>"When using zeroDebias: true, step is required.");let p=I(r,"step","movingAverage");c=ne(c,te(l,zn(a,p)))}return W(s,c)}var hne=S({movingAverage_:dne});function mne(t,n,e){Mt(e);let r=I(t,"indices","scatterND","int32"),o=I(n,"updates","scatterND");Bm(o,r,e);let s={indices:r,updates:o},i={shape:e};return E.runKernel(Af,s,i)}var gne=S({scatterND_:mne});function WM(t,n,e,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);let o=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=n.size;if(!(n.rank===0||n.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${o}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function xne(t,n,e,r=0){Mt(e);let o=I(t,"sparseIndices","sparseToDense","int32"),s=I(n,"sparseValues","sparseToDense","string_or_numeric"),i=I(r,"defaultValue","sparseToDense",s.dtype);WM(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},l={outputShape:e};return E.runKernel(Pf,a,l)}var bne=S({sparseToDense_:xne});function vne(t,n){let e=I(n,"indices","gatherND","int32"),o={params:I(t,"x","gatherND","string_or_numeric"),indices:e};return E.runKernel(pf,o)}var wne=S({gatherND_:vne});function jM(t,n){if(n==null)return t.shape.slice();if(_r(t.shape,n))return n;if(t.shape.length===n.length){let e=[];for(let r=0;r<t.shape.length;r++)n[r]==null&&t.shape[r]!=null?e.push(t.shape[r]):e.push(n[r]);return e}return n}function Cne(t,n,e,r){let o=I(t,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),n===0)return t instanceof Pe?o.clone():o;let s=jM(o,e),i=1-n,a=ne($s(W(Pr(s,0,1,"float32",r),i)),i);return R(o,a)}var CN=S({dropout_:Cne});function IN(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function zm(t,n,e){let r=1-t%2,o=new Float32Array(t);for(let s=0;s<t;++s){let i=2*Math.PI*s/(t+r-1);o[s]=n-e*Math.cos(i)}return Tt(o,"float32")}function Ine(t,n,e=1){return z(this,null,function*(){let r=I(t,"predictions","inTopK"),o=I(n,"targets","inTopK");D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),Kt(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];D(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=yield r.data(),a=yield o.data(),[l,u]=[i.length/s,s],c=_T("bool",l);for(let p=0;p<l;p++){let f=p*u,d=i.subarray(f,f+u),h=[];for(let g=0;g<d.length;g++)h.push({value:d[g],index:g});h.sort((g,m)=>m.value-g.value),c[p]=0;for(let g=0;g<e;g++)if(h[g].index===a[p]){c[p]=1;break}}return t!==r&&r.dispose(),n!==o&&o.dispose(),xn(c,o.shape,"bool")})}var Sne=Ine;var Yl={};ft(Yl,{conv2d:()=>HM,depthwiseConv2d:()=>qM,matMul:()=>KM});function Tne(t,n,e,r,o,s="NHWC",i){let a=t;t.rank===3&&(a=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;l.rank===3&&(l=_(n,[1,n.shape[0],n.shape[1],n.shape[2]])),D(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),D(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];D(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),D(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),gt("conv2dDerFilter",o,i);let p={x:a,dy:l},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return E.runKernel(Xp,p,f)}var kd=S({conv2DBackpropFilter_:Tne});function vc(t,n,e){if(e==null||e==="linear")return t;if(e==="relu")return R(t,So(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function wc(t,n){let e=n,r=dt(t.shape,n.shape);return r.length>0&&(e=ie(e,r)),_(e,t.shape)}function Cc(t,n,e,r){if(n==="linear")return t;if(n==="relu")return Fn(t);if(n==="elu")return Ms(t);if(n==="relu6")return gd(t);if(n==="prelu")return Hl(t,e);if(n==="leakyrelu")return zl(t,r);if(n==="sigmoid")return _n(t);throw new Error(`Unknown fused activation ${n}.`)}var Ic=(t,n)=>!(t>0)||n==="linear";function Nne({x:t,filter:n,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Ic(E.state.gradientDepth,l)===!1){D(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=vr(t,n,e,r,o,s,i);return a!=null&&(k=W(k,a)),Cc(k,l,u,c)}let p=I(t,"x","conv2d","float32"),f=I(n,"filter","conv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=_(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),gt("fused conv2d",r,i);let g=o==="NHWC"?d.shape[3]:d.shape[1];D(f.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${f.shape[2]}.`),D(Rn(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m=pc(d.shape,f.shape,e,s,r,i),y;a!=null&&(y=I(a,"bias","fused conv2d"),[y]=ze(y,p),o==="NHWC"?De(m.outShape,y.shape):(D(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),D(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let x;if(u!=null){let k=u.shape;if(D(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)D(k[0]===1||k[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${m.outChannels}).`);else if(k.length===3)try{De(k,m.outShape)}catch{let O=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(O)}x=I(u,"prelu weights","fused conv2d")}let v=(k,A)=>{D(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[O,M,L,V]=A,U=vc(k,L,l);D(to(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let G=ud(M.shape,U,O,e,r),j=kd(M,U,O.shape,e,r),H=[G,j];if(V!=null){let Y=wc(V,U);H.push(Y)}return H},w={x:d,filter:f,bias:y,preluActivationWeights:x},T={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?wr((A,O,M)=>{let L=E.runKernel(Zu,w,T);return M([O,A,L]),h&&(L=_(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:v}})(d,f):wr((A,O,M,L)=>{let V=E.runKernel(Zu,w,T);return L([O,A,V,M]),h&&(V=_(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:v}})(d,f,y)}var HM=S({fusedConv2d_:Nne});function Ene(t,n,e,r,o,s=[1,1],i){let a=t;t.rank===3&&(a=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;l.rank===3&&(l=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u={x:a,dy:l},c={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return E.runKernel(nf,u,c)}var jb=S({depthwiseConv2dNativeBackpropFilter_:Ene});function Dne(t,n,e,r,o,s=[1,1],i){let a=n,l=!1;n.rank===3&&(l=!0,a=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u={dy:a,filter:e},c={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:t},p=E.runKernel(rf,u,c);return l?_(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Hb=S({depthwiseConv2dNativeBackpropInput_:Dne});function kne({x:t,filter:n,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Ic(E.state.gradientDepth,l)===!1){let T=Fs(t,n,e,r,o,s,i);return a!=null&&(T=W(T,a)),Cc(T,l,u,c)}let p=I(t,"x","depthwiseConv2d","float32"),f=I(n,"filter","depthwiseConv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=_(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),D(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),D(Rn(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),gt("fused depthwiseConv2d",r,i);let g=pc(d.shape,f.shape,e,s,r,i,!0),m;a!=null&&(m=I(a,"bias","fused conv2d"),[m]=ze(m,p),De(g.outShape,m.shape));let y;u!=null&&(y=I(u,"prelu weights","fused depthwiseConv2d"));let x=(T,k)=>{D(to(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[A,O,M,L]=k,V=vc(T,M,l),U=Hb(O.shape,V,A,e,r,s,i),G=jb(O,V,A.shape,e,r,s,i);if(L!=null){let j=wc(m,V);return[U,G,j]}return[U,G]},v={x:d,filter:f,bias:m,preluActivationWeights:y},w={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?wr((k,A,O)=>{let M=E.runKernel(Qu,v,w);return O([A,k,M]),h&&(M=_(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:x}})(d,f):wr((k,A,O,M)=>{let L=E.runKernel(Qu,v,w);return M([A,k,L,O]),h&&(L=_(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:x}})(d,f,m)}var qM=S({fusedDepthwiseConv2d_:kne});function Ane({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Ic(E.state.gradientDepth,s)===!1){let V=Fe(t,n,e,r);return o!=null&&(V=W(V,o)),Cc(V,s,i,a)}let l=I(t,"a","fused matMul"),u=I(n,"b","fused matMul");[l,u]=ze(l,u);let c=e?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=e?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=Le(h),y=Le(g);D(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);let v=De(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,d]),w=e?_(l,[m,c,f]):_(l,[m,f,c]),T=r?_(u,[y,d,p]):_(u,[y,p,d]),k;o!=null&&(k=I(o,"bias","fused matMul"),[k]=ze(k,l),De(v,k.shape));let A;i!=null&&(A=I(i,"prelu weights","fused matMul"));let O=(V,U)=>{let[G,j,H,Y]=U,Q=vc(_(V,H.shape),H,s),X,J;if(!e&&!r?(X=Fe(Q,j,!1,!0),J=Fe(G,Q,!0,!1)):!e&&r?(X=Fe(Q,j,!1,!1),J=Fe(Q,G,!0,!1)):e&&!r?(X=Fe(j,Q,!1,!0),J=Fe(G,Q,!1,!1)):(X=Fe(j,Q,!0,!0),J=Fe(Q,G,!0,!0)),o!=null){let re=wc(Y,Q);return[X,J,re]}else return[X,J]},M={a:w,b:T,bias:k,preluActivationWeights:A},L={transposeA:e,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?wr((U,G,j)=>{let H=E.runKernel(Yu,M,L);return j([U,G,H]),{value:_(H,v),gradFunc:O}})(w,T):wr((U,G,j,H)=>{let Y=E.runKernel(Yu,M,L);return H([U,G,Y,j]),{value:_(Y,v),gradFunc:O}})(w,T,k)}var KM=S({fusedMatMul_:Ane});function Rne(t){return zm(t,.54,.46)}var XM=S({hammingWindow_:Rne});function _ne(t){return zm(t,.5,.5)}var qb=S({hannWindow_:_ne});function One(t,n,e,r=!1,o=0){let s=0,i=[];for(;s+n<=t.size;)i.push(ve(t,s,n)),s+=e;if(r)for(;s<t.size;){let a=s+n-t.size,l=Je([ve(t,s,n-a),Co([a],o)]);i.push(l),s+=e}return i.length===0?Qo([],[0,n]):_(Je(i),[i.length,n])}var Kb=S({frame_:One});function Fne(t,n,e,r,o=qb){r==null&&(r=IN(n));let s=Kb(t,n,e),i=R(s,o(n));return Xl(i,r)}var YM=S({stft_:Fne});function Mne(t,n,e,r,o="bilinear",s=0){let i=I(t,"image","cropAndResize"),a=I(n,"boxes","cropAndResize","float32"),l=I(e,"boxInd","cropAndResize","int32"),u=a.shape[0];D(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),D(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),D(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:l},p={method:o,extrapolationValue:s,cropSize:r};return E.runKernel(Jp,c,p)}var ZM=S({cropAndResize_:Mne});function $ne(t){let n=I(t,"image","flipLeftRight","float32");D(n.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`);let e={image:n};return E.runKernel(cf,e,{})}var QM=S({flipLeftRight_:$ne});function Pne(t){let n=I(t,"image","grayscaleToRGB"),e=n.rank-1,r=n.shape[e];D(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),D(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(n.rank);return o.fill(1,0,e),o[e]=3,On(n,o)}var JM=S({grayscaleToRGB_:Pne});function Lne(t){let n=I(t,"image","RGBToGrayscale"),e=n.rank-1,r=n.shape[e];D(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),D(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=n.dtype,s=K(n,"float32"),i=Tt([.2989,.587,.114]),a;switch(n.rank){case 2:a=Ll("ij,j->i",s,i);break;case 3:a=Ll("ijk,k->ij",s,i);break;case 4:a=Ll("ijkl,l->ijk",s,i);break;case 5:a=Ll("ijklm,m->ijkl",s,i);break;case 6:a=Ll("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Pt(a,-1),K(a,o)}var e2=S({rgbToGrayscale_:Lne});function Bne(t,n,e=0,r=.5){let o=I(t,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:n,fillValue:e,center:r};return E.runKernel(Hf,s,i)}var t2=S({rotateWithOffset_:Bne});function To(t,n,e,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=t.shape[0];return e=Math.min(e,i),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),D(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),D(n.rank===1,()=>"scores must be a 1D tensor"),D(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}function zne(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY){let s=I(t,"boxes","nonMaxSuppression","float32"),i=I(n,"scores","nonMaxSuppression","float32"),a=To(s,i,e,r,o);e=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let l={maxOutputSize:e,iouThreshold:r,scoreThreshold:o};return E.runKernel(vf,{boxes:s,scores:i},l)}var n2=S({nonMaxSuppression_:zne});function r2(t,n,e){let r=Vne(t,n,e),o=r<0?-(r+1):r;t.splice(o,0,n)}function Vne(t,n,e){return Gne(t,n,e||Une)}function Une(t,n){return t>n?1:t<n?-1:0}function Gne(t,n,e){let r=0,o=t.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=e(n,t[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}function Xb(t,n,e,r,o){return SN(t,n,e,r,o,0)}function Yb(t,n,e,r,o,s){return SN(t,n,e,r,o,0,!1,s,!0)}function Zb(t,n,e,r,o,s){return SN(t,n,e,r,o,s,!0)}function SN(t,n,e,r,o,s,i=!1,a=!1,l=!1){let u=[];for(let m=0;m<n.length;m++)n[m]>o&&u.push({score:n[m],boxIndex:m,suppressBeginIndex:0});u.sort(o2);let c=s>0?-.5/s:0,p=[],f=[];for(;p.length<e&&u.length>0;){let m=u.pop(),{score:y,boxIndex:x,suppressBeginIndex:v}=m;if(y<o)break;let w=!1;for(let T=p.length-1;T>=v;--T){let k=Wne(t,x,p[T]);if(k>=r){w=!0;break}if(m.score=m.score*jne(r,c,k),m.score<=o)break}m.suppressBeginIndex=p.length,w||(m.score===y?(p.push(x),f.push(m.score)):m.score>o&&r2(u,m,o2))}let d=p.length,h=e-d;a&&h>0&&(p.push(...new Array(h).fill(0)),f.push(...new Array(h).fill(0)));let g={selectedIndices:p};return i&&(g.selectedScores=f),l&&(g.validOutputs=d),g}function Wne(t,n,e){let r=t.subarray(n*4,n*4+4),o=t.subarray(e*4,e*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),d=(a-s)*(l-i),h=(p-u)*(f-c);if(d<=0||h<=0)return 0;let g=Math.max(s,u),m=Math.max(i,c),y=Math.min(a,p),x=Math.min(l,f),v=Math.max(y-g,0)*Math.max(x-m,0);return v/(d+h-v)}function jne(t,n,e){let r=Math.exp(n*e*e);return e<=t?r:0}function o2(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function Hne(s,i,a){return z(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY){let l=I(t,"boxes","nonMaxSuppressionAsync"),u=I(n,"scores","nonMaxSuppressionAsync"),c=To(l,u,e,r,o);e=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold;let p=yield Promise.all([l.data(),u.data()]),f=p[0],d=p[1],{selectedIndices:h}=Xb(f,d,e,r,o);return l!==t&&l.dispose(),u!==n&&u.dispose(),Tt(h,"int32")})}var s2=Hne;function qne(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=I(t,"boxes","nonMaxSuppression"),a=I(n,"scores","nonMaxSuppression"),l=To(i,a,e,r,o,s);e=l.maxOutputSize,r=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=E.runKernel(Cf,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var i2=S({nonMaxSuppressionWithScore_:qne});function Kne(i,a,l){return z(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let u=I(t,"boxes","nonMaxSuppressionAsync"),c=I(n,"scores","nonMaxSuppressionAsync"),p=To(u,c,e,r,o,s);e=p.maxOutputSize,r=p.iouThreshold,o=p.scoreThreshold,s=p.softNmsSigma;let f=yield Promise.all([u.data(),c.data()]),d=f[0],h=f[1],{selectedIndices:g,selectedScores:m}=Zb(d,h,e,r,o,s);return u!==t&&u.dispose(),c!==n&&c.dispose(),{selectedIndices:Tt(g,"int32"),selectedScores:Tt(m)}})}var a2=Kne;function Xne(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=I(t,"boxes","nonMaxSuppression"),a=I(n,"scores","nonMaxSuppression"),l=To(i,a,e,r,o,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,f={boxes:i,scores:a},d={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},h=E.runKernel(wf,f,d);return{selectedIndices:h[0],validOutputs:h[1]}}var l2=S({nonMaxSuppressionPadded_:Xne});function Yne(i,a,l){return z(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let u=I(t,"boxes","nonMaxSuppressionAsync"),c=I(n,"scores","nonMaxSuppressionAsync"),p=To(u,c,e,r,o,null),f=p.maxOutputSize,d=p.iouThreshold,h=p.scoreThreshold,[g,m]=yield Promise.all([u.data(),c.data()]),{selectedIndices:y,validOutputs:x}=Yb(g,m,f,d,h,s);return u!==t&&u.dispose(),c!==n&&c.dispose(),{selectedIndices:Tt(y,"int32"),validOutputs:se(x,"int32")}})}var u2=Yne;function Zne(t,n,e=!1,r=!1){let o=I(t,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(n.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),D(r===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=_(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:n},u=E.runKernel(bl,a,l);return i?_(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Qb=S({resizeBilinear_:Zne});function Qne(t,n,e=!1,r=!1){let o=I(t,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(n.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(r===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=_(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:n},u=E.runKernel(xl,a,l);return i?_(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Jb=S({resizeNearestNeighbor_:Qne});function Jne(t,n="binary",e=!1,r=.5){let o=I(t,"image","threshold"),s=.2989,i=.587,a=.114,l=o.shape[0]*o.shape[1],u=R(Tt([r]),255),c,p,f,d;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(n==="otsu"||n==="binary",()=>`Method must be binary or otsu, but was ${n}`),o.shape[2]===3){[c,p,f]=cn(o,[1,1,1],-1);let m=R(c,s),y=R(p,i),x=R(f,a);d=W(W(m,y),x)}else d=t;if(n==="otsu"){let m=sb(K(yd(d),"int32"),xn([]),256);u=ere(m,l)}let h=e?$r(d,u):Lt(d,u);return K(R(h,255),"int32")}function ere(t,n){let e=Tt([-1]),r=Tt([0]),o=Tt([0]),s,i,a,l,u,c;for(let p=0;p<t.size-1;p++){s=ve(t,0,p+1),i=ve(t,p+1),u=ne(ie(s),n),c=ne(ie(i),n);let f=ie(R(s,Ls(0,s.size)));a=ne(f,ie(s));let d=Co(i.shape,s.size),h=W(Ls(0,i.size),d),g=R(i,h);l=ne(ie(g),ie(i));let m=te(a,l),y=te(a,l),x=R(u,c);o=R(R(x,m),y);let v=Lt(o,r);r=yt(v,o,r),e=yt(v,Tt([p]),e)}return e}var c2=S({threshold_:Jne});function tre(t,n,e="nearest",r="constant",o=0,s){let i=I(t,"image","transform","float32"),a=I(n,"transforms","transform","float32");D(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:a},u={interpolation:e,fillMode:r,fillValue:o,outputShape:s};return E.runKernel(Wf,l,u)}var p2=S({transform_:tre});function nre(t,n,e){let r=I(t,"a","bandPart");D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,l;typeof n=="number"?(D(n%1===0,()=>`bandPart(): numLower must be an integer, got ${n}.`),D(n<=s,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${s}).`),a=I(n<0?s:n,"numLower","bandPart")):(D(n.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=yt(oa(n,0),s,ro(n,s))),typeof e=="number"?(D(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),D(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=I(e<0?i:e,"numUpper","bandPart")):(D(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=yt(oa(e,0),i,ro(e,i)));let u=_(Ls(0,s,1,"int32"),[-1,1]),c=Ls(0,i,1,"int32"),p=te(u,c),f=Vn($r(p,a),ar(p,$e(l))),d=bt([s,i],r.dtype);return _(Bt(pn(_(r,[-1,s,i])).map(h=>yt(f,h,d))),o)}var f2=S({bandPart_:nre});function rre(t){let n;if(Array.isArray(t)){n=!1,D(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=t[0].shape[0];for(let s=1;s<t.length;++s)D(t[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[s].shape[0]} vs. ${o})`)}else n=!0,t=cn(t,t.shape[0],0).map(o=>Qn(o,[0]));D(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);let e=[],r=t;for(let o=0;o<t.length;++o)e.push(E.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=R(ie(R(e[i],s)),e[i]);s=te(s,a)}return ne(s,ra(s,"euclidean"))}));return n?Bt(e,0):e}var d2=S({gramSchmidt_:rre});function ore(t,n=!1){if(D(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return h2(t,n);{let e=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=pn(_(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],s=[];r.forEach(l=>{let[u,c]=h2(l,n);o.push(u),s.push(c)});let i=_(Bt(o,0),t.shape),a=_(Bt(s,0),t.shape);return[i,a]}}function h2(t,n=!1){return E.tidy(()=>{D(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);let e=t.shape[0],r=t.shape[1],o=dc(e),s=ir(t),i=Qo([[1]],[1,1]),a=ir(i),l=e>=r?r:e;for(let u=0;u<l;++u){let c=s,p=a,f=o;[a,s,o]=E.tidy(()=>{let d=ve(s,[u,u],[e-u,1]),h=ra(d),g=ve(s,[u,u],[1,1]),m=yt(Lt(g,0),Qo([[-1]]),Qo([[1]])),y=te(g,R(m,h)),x=ne(d,y);x.shape[0]===1?a=ir(i):a=Je([i,ve(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let v=$e(ne(Fe(m,y),h)),w=ve(s,[u,0],[e-u,r]),T=R(v,a),k=Me(a);if(u===0)s=te(w,Fe(T,Fe(k,w)));else{let M=te(w,Fe(T,Fe(k,w)));s=Je([ve(s,[0,0],[u,r]),M],0)}let A=Me(T),O=ve(o,[0,u],[e,o.shape[1]-u]);if(u===0)o=te(O,Fe(Fe(O,a),A));else{let M=te(O,Fe(Fe(O,a),A));o=Je([ve(o,[0,0],[e,u]),M],1)}return[a,s,o]}),Ne([c,p,f])}return!n&&e>r&&(o=ve(o,[0,0],[e,r]),s=ve(s,[0,0],[r,r])),[o,s]})}var m2=S({qr_:ore});var rn=function(t){return t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",t}(rn||{});function sre(t,n,e=rn.SUM_BY_NONZERO_WEIGHTS){let r=I(t,"losses","computeWeightedLoss"),o=null;n!=null&&(o=I(n,"weights","computeWeightedLoss"));let s=o==null?r:R(r,o);if(e===rn.NONE)return s;if(e===rn.SUM)return ie(s);if(e===rn.MEAN){if(o==null)return xt(s);{let i=r.size/o.size,a=ne(ie(s),ie(o));return i>1?ne(a,se(i)):a}}if(e===rn.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ne(ie(s),se(r.size));{let i=R(o,en(r.shape)),a=K(ie(Zo(i,se(0))),"float32");return ne(ie(s),a)}}throw Error(`Unknown reduction: ${e}`)}var Un=S({computeWeightedLoss_:sre});function ire(t,n,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(t,"labels","absoluteDifference"),s=I(n,"predictions","absoluteDifference"),i=null;e!=null&&(i=I(e,"weights","absoluteDifference")),Kt(o.shape,s.shape,"Error in absoluteDifference: ");let a=St(te(o,s));return Un(a,i,r)}var g2=S({absoluteDifference_:ire});function are(t,n,e,r,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(t,"labels","cosineDistance"),i=I(n,"predictions","cosineDistance"),a=null;r!=null&&(a=I(r,"weights","cosineDistance")),Kt(s.shape,i.shape,"Error in cosineDistance: ");let l=se(1),u=te(l,ie(R(s,i),e,!0));return Un(u,a,o)}var y2=S({cosineDistance_:are});function lre(t,n,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(t,"labels","hingeLoss"),s=I(n,"predictions","hingeLoss"),i=null;e!=null&&(i=I(e,"weights","hingeLoss")),Kt(o.shape,s.shape,"Error in hingeLoss: ");let a=se(1);o=te(R(se(2),o),a);let l=Fn(te(a,R(o,s)));return Un(l,i,r)}var x2=S({hingeLoss_:lre});function ure(t,n,e,r=1,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(t,"labels","huberLoss"),i=I(n,"predictions","huberLoss"),a=null;e!=null&&(a=I(e,"weights","huberLoss")),Kt(s.shape,i.shape,"Error in huberLoss: ");let l=se(r),u=St(te(i,s)),c=ro(u,l),p=te(u,c),f=W(R(se(.5),_e(c)),R(l,p));return Un(f,a,o)}var b2=S({huberLoss_:ure});function cre(t,n,e,r=1e-7,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(t,"labels","logLoss"),i=I(n,"predictions","logLoss"),a=null;e!=null&&(a=I(e,"weights","logLoss")),Kt(s.shape,i.shape,"Error in logLoss: ");let l=se(1),u=se(r),c=$e(R(s,Cn(W(i,u)))),p=R(te(l,s),Cn(W(te(l,i),u))),f=te(c,p);return Un(f,a,o)}var v2=S({logLoss_:cre});function pre(t,n,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(t,"labels","meanSquaredError"),s=I(n,"predictions","meanSquaredError"),i=null;e!=null&&(i=I(e,"weights","meanSquaredError")),Kt(o.shape,s.shape,"Error in meanSquaredError: ");let a=Nd(o,s);return Un(a,i,r)}var w2=S({meanSquaredError_:pre});function fre(t,n){let e=I(t,"labels","sigmoidCrossEntropyWithLogits"),r=I(n,"logits","sigmoidCrossEntropyWithLogits");Kt(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Fn(r),s=R(r,e),i=Vl(Ht($e(St(r))));return W(te(o,s),i)}function dre(t,n,e,r=0,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(t,"multiClassLabels","sigmoidCrossEntropy"),i=I(n,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=I(e,"weights","sigmoidCrossEntropy")),Kt(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=se(r),c=se(1),p=se(.5);s=W(R(s,te(c,u)),R(p,u))}let l=fre(s,i);return Un(l,a,o)}var C2=S({sigmoidCrossEntropy_:dre});function hre(t,n,e=-1){if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${e}`);return wr((o,s,i)=>{let l=Ul(s,[e],!0),u=te(K(s,"float32"),l);i([o,u]);let c=$e(R(u,o));return{value:ie(c,[e]),gradFunc:(d,h)=>{let[g,m]=h,y=Io(d.shape,[e]);return[R(_(d,y),te(K(g,"float32"),Ht(m))),R(_(d,y),te(Ht(m),K(g,"float32")))]}}})(t,n)}function mre(t,n,e,r=0,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(t,"onehotLabels","softmaxCrossEntropy"),i=I(n,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=I(e,"weights","softmaxCrossEntropy")),Kt(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=se(r),c=se(1),p=se(s.shape[1]);s=W(R(s,te(c,u)),ne(u,p))}let l=hre(s,i);return Un(l,a,o)}var I2=S({softmaxCrossEntropy_:mre});function gre(t,n,e,r){let o=I(t,"indices","sparseFillEmptyRows","int32"),s=I(n,"values","sparseFillEmptyRows"),i=I(e,"denseShape","sparseFillEmptyRows","int32"),a=I(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let l={indices:o,values:s,denseShape:i,defaultValue:a},u=E.runKernel(Of,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var S2=S({sparseFillEmptyRows_:gre});function yre(t,n,e){let r=I(t,"inputIndices","sparseReshape","int32"),o=I(n,"inputShape","sparseReshape","int32"),s=I(e,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=E.runKernel(Ff,i);return{outputIndices:a[0],outputShape:a[1]}}var T2=S({sparseReshape_:yre});function xre(t,n,e){let r=I(t,"data","sparseSegmentMean"),o=I(n,"indices","sparseSegmentMean","int32"),s=I(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return E.runKernel(Mf,i)}var N2=S({sparseSegmentMean_:xre});function bre(t,n,e){let r=I(t,"data","sparseSegmentSum"),o=I(n,"indices","sparseSegmentSum","int32"),s=I(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return E.runKernel($f,i)}var E2=S({sparseSegmentSum_:bre});function vre(t,n,e,r,o,s,i,a){let l=I(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=I(n,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:l,dataSplits:u},f=E.runKernel(zf,p,c);return{nGrams:f[0],nGramsSplits:f[1]}}var D2=S({stringNGrams_:vre});function wre(t,n,e=!0){let r=I(t,"input","stringSplit","string"),o=I(n,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:r,delimiter:o},a=E.runKernel(Vf,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var k2=S({stringSplit_:wre});function Cre(t,n){let e=I(t,"input","stringToHashBucketFast","string"),r={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return E.runKernel(Uf,o,r)}var A2=S({stringToHashBucketFast_:Cre});function Ire(t,n,e,r=!0){let o=I(t,"input","staticRegexReplace","string"),s={pattern:n,rewrite:e,replaceGlobal:r};return E.runKernel(Xu,{x:o},s)}var R2=S({staticRegexReplace_:Ire});var Sre={fft:Kl,ifft:ia,rfft:Xl,irfft:Td},Tre={hammingWindow:XM,hannWindow:qb,frame:Kb,stft:YM},In={flipLeftRight:QM,grayscaleToRGB:JM,resizeNearestNeighbor:Jb,resizeBilinear:Qb,rgbToGrayscale:e2,rotateWithOffset:t2,cropAndResize:ZM,nonMaxSuppression:n2,nonMaxSuppressionAsync:s2,nonMaxSuppressionWithScore:i2,nonMaxSuppressionWithScoreAsync:a2,nonMaxSuppressionPadded:l2,nonMaxSuppressionPaddedAsync:u2,threshold:c2,transform:p2},TN={bandPart:f2,gramSchmidt:d2,qr:m2},Nre={absoluteDifference:g2,computeWeightedLoss:Un,cosineDistance:y2,hingeLoss:x2,huberLoss:b2,logLoss:v2,meanSquaredError:w2,sigmoidCrossEntropy:C2,softmaxCrossEntropy:I2},Ere={sparseFillEmptyRows:S2,sparseReshape:T2,sparseSegmentMean:N2,sparseSegmentSum:E2},Dre={stringNGrams:D2,stringSplit:k2,stringToHashBucketFast:A2,staticRegexReplace:R2};var q={};ft(q,{Serializable:()=>Vm,SerializationMap:()=>ev,getRegisteredName:()=>Are,registerClass:()=>EN});var kre=new Map,NN=new Map,Vm=class{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}},ev=class t{constructor(){this.classNameMap={}}static getMap(){return t.instance==null&&(t.instance=new t),t.instance}static register(n){t.getMap().classNameMap[n.className]=[n,n.fromConfig]}};function EN(t,n,e){D(t.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),D(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof n>"u"&&(n="Custom"),typeof e>"u"&&(e=t.className);let r=e,o=n+">"+r;return ev.register(t),kre.set(o,t),NN.set(t,o),t}function Are(t){return NN.has(t)?NN.get(t):t.className}var Gn=class extends Vm{minimize(n,e=!1,r){let{value:o,grads:s}=this.computeGradients(n,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Ne(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return mN(n,e)}dispose(){this.iterations_!=null&&Ne(this.iterations_)}saveIterations(){return z(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:se(this.iterations_,"int32")}})}getWeights(){return z(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(n){return z(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(n){return z(this,null,function*(){return this.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})}};Object.defineProperty(Gn,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});var Ad=class extends Gn{static get className(){return"Adadelta"}constructor(n,e,r=null){super(),this.learningRate=n,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=E.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=E.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:B(()=>ye(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:B(()=>ye(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let l=this.accumulatedGrads[o].variable,u=this.accumulatedUpdates[o].variable;B(()=>{let c=W(R(l,this.rho),R(_e(a),1-this.rho)),p=R(ne(ct(W(u,this.epsilon)),ct(W(l,this.epsilon))),a),f=W(R(u,this.rho),R(_e(p),1-this.rho));l.assign(c),u.assign(f);let d=W(R(p,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ne(this.accumulatedGrads.map(n=>n.variable)),Ne(this.accumulatedUpdates.map(n=>n.variable)))}getWeights(){return z(this,null,function*(){let n=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return z(this,null,function*(){n=yield this.extractIterations(n);let e=n.length/2,r=!1;this.accumulatedGrads=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.rho,e.epsilon)}};var Rd=class extends Gn{static get className(){return"Adagrad"}constructor(n,e=.1){super(),this.learningRate=n,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=E.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:B(()=>Co(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(n)?n[o].tensor:n[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;B(()=>{let l=W(a,_e(i));a.assign(l);let u=W(R(ne(i,ct(W(l,E.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ne(this.accumulatedGrads.map(n=>n.variable))}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(n=>({name:n.originalName,tensor:n.variable})))})}setWeights(n){return z(this,null,function*(){n=yield this.extractIterations(n);let e=!1;this.accumulatedGrads=n.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,e){return new n(e.learningRate,e.initialAccumulatorValue)}};var _d=class extends Gn{static get className(){return"Adam"}constructor(n,e,r,o=null){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=se(e).variable(),this.accBeta2=se(r).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(n){let e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);B(()=>{let r=te(1,this.accBeta1),o=te(1,this.accBeta2);e.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:B(()=>ye(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:B(()=>ye(a).variable(l))});let u=Array.isArray(n)?n[i].tensor:n[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,f=W(R(c,this.beta1),R(u,1-this.beta1)),d=W(R(p,this.beta2),R(_e(u),1-this.beta2)),h=ne(f,r),g=ne(d,o);c.assign(f),p.assign(d);let m=W(R(ne(h,W(ct(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(R(this.accBeta1,this.beta1)),this.accBeta2.assign(R(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ne(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedSecondMoment!=null&&Ne(this.accumulatedSecondMoment.map(n=>n.variable))}getWeights(){return z(this,null,function*(){let n=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return z(this,null,function*(){n=yield this.extractIterations(n),B(()=>{this.accBeta1.assign(zn(this.beta1,this.iterations_+1)),this.accBeta2.assign(zn(this.beta2,this.iterations_+1))});let e=n.length/2,r=!1;this.accumulatedFirstMoment=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon)}};var Od=class extends Gn{static get className(){return"Adamax"}constructor(n,e,r,o=null,s=0){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=se(0).variable(),this.accBeta1=se(e).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(n){let e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);B(()=>{let r=te(1,this.accBeta1),o=ne(-this.learningRate,W(R(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:ye(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:ye(a).variable(l)});let u=Array.isArray(n)?n[i].tensor:n[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,f=W(R(c,this.beta1),R(u,1-this.beta1)),d=R(p,this.beta2),h=St(u),g=Cr(d,h);c.assign(f),p.assign(g);let m=W(R(ne(o,r),ne(f,W(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(W(this.iteration,1)),this.accBeta1.assign(R(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ne(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedWeightedInfNorm!=null&&Ne(this.accumulatedWeightedInfNorm.map(n=>n.variable))}getWeights(){return z(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(n){return z(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};var Zl=class extends Gn{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=Array.isArray(n)?n[o].tensor:n[r];if(s==null)return;let i=E.registeredVariables[r];B(()=>{let a=W(R(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,this.c!=null&&this.c.dispose(),this.c=kt(se(-n))}dispose(){this.c.dispose()}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()]})}setWeights(n){return z(this,null,function*(){if(n=yield this.extractIterations(n),n.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,e){return new n(e.learningRate)}};var Fd=class extends Zl{static get className(){return"Momentum"}constructor(n,e,r=!1){super(n),this.learningRate=n,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=se(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=E.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:B(()=>ye(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(n)?n[o].tensor:n[r];a!=null&&B(()=>{let l,u=W(R(this.m,i),a);this.useNesterov?l=W(R(this.c,W(a,R(u,this.m))),s):l=W(R(this.c,u),s),i.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ne(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(n=>({name:n.originalName,tensor:n.variable})))})}setWeights(n){return z(this,null,function*(){n=yield this.extractIterations(n);let e=!1;this.accumulations=n.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,e){return new n(e.learningRate,e.momentum,e.useNesterov)}};var Md=class extends Gn{static get className(){return"RMSProp"}constructor(n,e=.9,r=0,o=null,s=!1){if(super(),this.learningRate=n,this.decay=e,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=E.backend.epsilon()),n==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=E.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:B(()=>ye(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:B(()=>ye(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:B(()=>ye(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let l=this.accumulatedMeanSquares[o].variable,u=this.accumulatedMoments[o].variable;B(()=>{let c=W(R(l,this.decay),R(_e(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,f=W(R(p,this.decay),R(a,1-this.decay)),d=ne(R(a,this.learningRate),ct(te(c,W(_e(f),this.epsilon)))),h=W(R(u,this.momentum),d);l.assign(c),p.assign(f),u.assign(h);let g=te(s,h);s.assign(g)}else{let p=W(R(l,this.decay),R(_e(a),1-this.decay)),f=W(R(u,this.momentum),ne(R(a,this.learningRate),ct(W(p,this.epsilon))));l.assign(p),u.assign(f);let d=te(s,f);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ne(this.accumulatedMeanSquares.map(n=>n.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ne(this.accumulatedMeanGrads.map(n=>n.variable)),this.accumulatedMoments!=null&&Ne(this.accumulatedMoments.map(n=>n.variable))}getWeights(){return z(this,null,function*(){let n=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&n.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return z(this,null,function*(){n=yield this.extractIterations(n);let e=this.centered?n.length/3:n.length/2,r=!1;this.accumulatedMeanSquares=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=n.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,e){return new n(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};var Rre=[Ad,Rd,_d,Od,Fd,Md,Zl];function _2(){for(let t of Rre)EN(t)}var Jo={};ft(Jo,{CompositeArrayBuffer:()=>Bn,browserFiles:()=>F2,browserHTTPRequest:()=>B2,concatenateArrayBuffers:()=>wF,copyModel:()=>MF,decodeWeights:()=>zx,decodeWeightsStream:()=>Vx,encodeWeights:()=>yF,fromMemory:()=>z2,fromMemorySync:()=>FN,getLoadHandlers:()=>TF,getModelArtifactsForJSON:()=>ed,getModelArtifactsForJSONSync:()=>tN,getModelArtifactsInfoForJSON:()=>ks,getSaveHandlers:()=>SF,getWeightSpecs:()=>Rm,http:()=>nv,isHTTPScheme:()=>tv,listModels:()=>OF,loadWeights:()=>$2,moveModel:()=>$F,registerLoadRouter:()=>IF,registerSaveRouter:()=>CF,removeModel:()=>FF,weightsLoaderFactory:()=>_N,withSaveHandler:()=>V2,withSaveHandlerSync:()=>U2});var _re="model",Ore=".json",Fre=".weights.bin";function O2(t){return new Promise(n=>setTimeout(n)).then(t)}var DN=(()=>{class t{constructor(e){if(!$().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(e==null||e.length===0)&&(e=_re),this.modelJsonFileName=e+Ore,this.weightDataFileName=e+Fre}save(e){return z(this,null,function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=Bn.join(e.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=Ux(e,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=a,yield O2(()=>l.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=o,yield O2(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ks(e)}}})}}return t.URL_SCHEME="downloads://",t})();var kN=class{constructor(n){if(n==null||n.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${n}`);this.jsonFile=n[0],this.weightsFiles=n.slice(1)}load(){return z(this,null,function*(){return new Promise((n,e)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){n({modelTopology:i});return}let l=ed(s,u=>this.loadWeights(u));n(l)},r.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})})}loadWeights(n){let e=[],r=[];for(let i of n)e.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(n),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,i])}loadWeightsFile(n,e){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${n}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(n){let e=[],r=this.weightsFiles.map(s=>eN(s.name)),o={};for(let s of n)s.paths.forEach(i=>{let a=eN(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},Mre=t=>$().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(DN.URL_SCHEME)?$re(t.slice(DN.URL_SCHEME.length)):null;bn.registerSaveRouter(Mre);function $re(t="model"){return new DN(t)}function F2(t){return new kN(t)}function AN(t,n,e,r){i(t),e=e??0,r=r??1,a(e,r);let o=0,s=l=>(l.then(u=>{let c=e+ ++o/t.length*(r-e);return n(c),u}),l);function i(l){D(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),D(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(s))}function RN(t,n){return z(this,null,function*(){n==null&&(n={});let e=n.fetchFunc==null?$().platform.fetch:n.fetchFunc,r=t.map(p=>e(p,n.requestInit,{isBinary:!0})),a=(n.onProgress==null?yield Promise.all(r):yield AN(r,n.onProgress,0,.5)).map(p=>p.arrayBuffer());return n.onProgress==null?yield Promise.all(a):yield AN(a,n.onProgress,.5,1)})}function M2(t,n){var e;let r=n.fetchFunc==null?$().platform.fetch:n.fetchFunc,o=0,s;return(e=n.onProgress)===null||e===void 0||e.call(n,0),new ReadableStream({pull:i=>z(this,null,function*(){for(var a;o<t.length;){s||(s=(yield r(t[o],n.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=yield s.read();if(l){o++,s=void 0,(a=n.onProgress)===null||a===void 0||a.call(n,o/t.length);continue}i.enqueue(u);return}i.close()})})}function $2(t,n="",e,r){return z(this,null,function*(){return _N(i=>RN(i,{requestInit:r}))(t,n,e)})}function _N(t){return(n,e="",r)=>z(this,null,function*(){let o=n.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(n.forEach((d,h)=>{let g=0;d.weights.forEach(m=>{let y="quantization"in m?m.quantization.dtype:m.dtype,x=ea[y]*Le(m.shape),v=()=>{o[h]=!0,s[h]==null&&(s[h]=[]),s[h].push({manifestEntry:m,groupOffset:g,sizeBytes:x})};r!=null?r.forEach((w,T)=>{w===m.name&&(v(),i[T]=!0)}):v(),a.push(m.name),g+=x})}),!i.every(d=>d)){let d=r.filter((h,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let l=o.reduce((d,h,g)=>(h&&d.push(g),d),[]),u=[];l.forEach(d=>{n[d].paths.forEach(h=>{let g=e+(e.endsWith("/")?"":"/")+h;u.push(g)})});let c=yield t(u),p={},f=0;return l.forEach(d=>{let h=n[d].paths.length,g=new Bn(c.slice(f,f+h));s[d].forEach(y=>{let x=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),v=zx(x,[y.manifestEntry]);for(let w in v)p[w]=v[w]}),f+=h}),p})}var Pre="application/octet-stream",Lre="application/json",P2=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(D(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=$().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Ux(e,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:Lre}),"model.json"),e.weightData!=null){let a=Bn.join(e.weightData);r.body.append("model.weights.bin",new Blob([a],{type:Pre}),"model.weights.bin")}let i=yield this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:ks(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})}loadModelJSON(){return z(this,null,function*(){let e=yield this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r})}load(){return z(this,null,function*(){if(this.loadOptions.streamWeights)return this.loadStream();let e=yield this.loadModelJSON();return ed(e,r=>this.loadWeights(r))})}loadStream(){return z(this,null,function*(){let e=yield this.loadModelJSON(),r=yield this.getWeightUrls(e.weightsManifest),o=Rm(e.weightsManifest),s=()=>M2(r,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:o,getWeightStream:s})})}getWeightUrls(e){return z(this,null,function*(){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=Bre(r),i=this.weightPathPrefix||o,a=[],l=[];for(let u of e)for(let c of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(c)):a.push(i+c+s);return this.weightUrlConverter&&a.push(...yield Promise.all(l)),a})}loadWeights(e){return z(this,null,function*(){let r=yield this.getWeightUrls(e),o=Rm(e),s=yield RN(r,this.loadOptions);return[o,s]})}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function Bre(t){let n=t.lastIndexOf("/"),e=t.lastIndexOf("?"),r=t.substring(0,n),o=e>n?t.substring(e):"";return[r+"/",o]}function tv(t){return t.match(P2.URL_SCHEME_REGEX)!=null}var L2=(t,n)=>{if(typeof fetch>"u"&&(n==null||n.fetchFunc==null))return null;{let e=!0;if(Array.isArray(t)?e=t.every(r=>tv(r)):e=tv(t),e)return nv(t,n)}return null};bn.registerSaveRouter(L2);bn.registerLoadRouter(L2);function nv(t,n){return new P2(t,n)}function B2(t,n){return nv(t,n)}var Um=class{constructor(n){this.modelArtifacts=n}load(){return this.modelArtifacts}},rv=class{constructor(n){this.saveHandler=n}save(n){return this.saveHandler(n)}},ON=class{constructor(n){n.load&&(this.load=()=>Promise.resolve(n.load())),n.save&&(this.save=e=>Promise.resolve(n.save(e)))}};function z2(t,n,e,r){let o=arguments;return new ON(FN(...o))}function FN(t,n,e,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new Um(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Um({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Um({modelTopology:t,weightSpecs:n,weightData:e,trainingConfig:r}))}function V2(t){return new rv(t)}function U2(t){return new rv(t)}var Gm={};ft(Gm,{draw:()=>qre,fromPixels:()=>Kre,fromPixelsAsync:()=>Wre,toPixels:()=>Hre});var Sc,G2=!1;function W2(t,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,o=!1,s=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)s=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(qf(Sm,E.backendName)!=null){let h={pixels:t},g={numChannels:n};return E.runKernel(Sm,h,g)}let[u,c]=o?[t.videoWidth,t.videoHeight]:[t.width,t.height],p;if(i)p=t.getContext("2d").getImageData(0,0,u,c).data;else if(r||e)p=t.data;else if(s||o||a){if(Sc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Sc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Sc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Sc.canvas.width=u,Sc.canvas.height=c,Sc.drawImage(t,0,0,u,c),p=Sc.getImageData(0,0,u,c).data}let f;if(n===4)f=new Int32Array(p);else{let h=u*c;f=new Int32Array(h*n);for(let g=0;g<h;g++)for(let m=0;m<n;++m)f[g*n+m]=p[g*4+m]}return Bb(f,[c,u,n],"int32")}function zre(t){return t!=null&&t.data instanceof Uint8Array}function Vre(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Ure(t){return t!=null&&t.width!==0&&t.height!==0}function Gre(t){return Vre()&&!(t instanceof ImageBitmap)&&Ure(t)&&!zre(t)}function Wre(t,n=3){return z(this,null,function*(){let e=null;if($().getBool("WRAP_TO_IMAGEBITMAP")&&Gre(t)){let r;try{r=yield createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?e=r:e=t}else e=t;return W2(e,n)})}function j2(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let n=t.rank===2?1:t.shape[2];if(n>4||n===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${n}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}function jre(t){let n=t?.alpha||1;if(n>1||n<0)throw new Error(`Alpha value ${n} is suppoed to be in range [0 - 1].`)}function Hre(t,n){return z(this,null,function*(){let e=I(t,"img","toPixels");if(!(t instanceof Pe)){let u=e;e=K(u,"int32"),u.dispose()}j2(e);let[r,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2],i=yield e.data(),a=e.dtype==="float32"?255:1,l=new Uint8ClampedArray(o*r*4);for(let u=0;u<r*o;++u){let c=[0,0,0,255];for(let f=0;f<s;f++){let d=i[u*s+f];if(e.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(e.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(c[0]=d*a,c[1]=d*a,c[2]=d*a):c[f]=d*a}let p=u*4;l[p+0]=Math.round(c[0]),l[p+1]=Math.round(c[1]),l[p+2]=Math.round(c[2]),l[p+3]=Math.round(c[3])}if(n!=null){G2||qf(Im,E.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),G2=!0),n.width=o,n.height=r;let u=n.getContext("2d"),c=new ImageData(l,o,r);u.putImageData(c,0,0)}return e!==t&&e.dispose(),l})}function qre(t,n,e){let r=I(t,"img","draw");if(!(t instanceof Pe)){let i=r;r=K(i,"int32"),i.dispose()}j2(r),jre(e?.imageOptions);let o={image:r},s={canvas:n,options:e};E.runKernel(Im,o,s)}var Kre=S({fromPixels_:W2});function Xre(t,n){let e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(n.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(Le(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);let o=n.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=t.shape,l=o.slice();l.pop();let u=1;for(let p=s;p<e;++p)u*=a[p],l.push(a[p]);let c=[...Is(t.shape).map(p=>p/u),1].slice(0,s);return[l,i,u,c]}var Sn={};ft(Sn,{assertParamsValid:()=>Zre,computeFlatOffset:()=>noe,computeOutShape:()=>Jre,getNormalizedAxes:()=>eoe,isSliceContinous:()=>toe,maskToAxes:()=>Qre,parseSliceParams:()=>$N,sliceInfo:()=>roe,startForAxis:()=>J2,startIndicesWithElidedDims:()=>Y2,stopForAxis:()=>e$,stopIndicesWithElidedDims:()=>Z2,stridesForAxis:()=>Q2,stridesWithElidedDims:()=>q2});var MN=-2,Yre=-1;function Zre(t,n,e){let r=t.shape.length;D(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),D(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)D(n[o]+e[o]<=t.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${n[o]+e[o]}) would overflow input.shape[${o}] (${t.shape[o]})`)}function Qre(t){let n=[],e=0;for(;t>0;)t&1&&n.push(e),t/=2,e++;return n}function Jre(t,n,e){let r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((n[o]-t[o])/e[o]);return r}function q2(t,n,e,r){let o=[...t];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[n]=1:(o.splice(n,0,1),o.pop());return o}function K2(t,n,e){return e<=t?e:e-(n-1)}function X2(t,n){let e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function eoe(t,n,e,r,o,s,i,a,l){let u=t.length,c=new Array(u),p=new Array(u),f=new Array(u);if(n.length&&e>0){let d=n[0],h=e+1;c=Y2(i,d,h,r,t),p=Z2(a,d,h,o,t),f=q2(s,d,h,t)}else for(let d=0;d<u;d++)c[d]=J2(i,r,s,t,d,l),p[d]=e$(a,o,s,t,d,l),f[d]=Q2(s,d,l);return{begin:c,end:p,strides:f}}function Y2(t,n,e,r,o){let s=[...o],i=X2(e,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let l=K2(n,e,a),u=r[l];t&1<<l&&(u=0),s[a]=u}return s}function Z2(t,n,e,r,o){let s=[...o],i=X2(e,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let l=K2(n,e,a),u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){let l=o[a];s[a]<0&&(s[a]+=l),s[a]=$p(0,s[a],o[a])}return s}function Q2(t,n,e){let r=t[n];return(e&1<<n||r==null)&&(r=1),r}function J2(t,n,e,r,o,s){let i=n[o],a=e[o]||1;(t&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),i=$p(0,i,l-1),i}function e$(t,n,e,r,o,s){let i=n[o],a=e[o]||1;(t&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),a>0?i=$p(0,i,l):i=$p(-1,i,l-1),i}function toe(t,n,e){let r=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){r=o;break}for(let o=r+1;o<e.length;o++)if(n[o]>0||e[o]!==t[o])return!1;return!0}function noe(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function $N(t,n,e){let r,o=t.shape.length;typeof n=="number"?r=[n,...new Array(o-1).fill(0)]:n.length<o?r=n.concat(new Array(o-n.length).fill(0)):r=n.slice(),r.forEach(i=>{D(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(D(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,s]}function roe(t,n,e,r,o,s,i,a,l){let u;if(r==null?(u=new Array(n.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:u.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<p.dims;v++)c&&1<<v&a&&p.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};ooe(p,f);let d=!0,h=!0,g=!0,m=[],y=[];for(let v=0;v<t.length;++v){if(f.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);let w=!!(f.shrinkAxisMask&1<<v),T=t[v];if(T===-1){m.push(w?1:-1);continue}let k=[f.beginMask&1<<v,f.endMask&1<<v],A=[f.strides[v]>0?0:-1,f.strides[v]>0?T:T-1];if(w&&f.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&f.strides[v]===1;let O=!!(f.beginMask&1<<v&&f.endMask&1<<v);if(f.beginValid&&f.endValid){if(w){let U=f.begin[v]<0?T+f.begin[v]:f.begin[v];if(f.begin[v]=U,f.end[v]=f.begin[v]+1,U<0||U>=T)throw Error(`slice index ${f.begin[v]} of dimension ${v} out of bounds.`)}else f.begin[v]=H2(f.begin[v],0,f.strides[v],T,k,A),f.end[v]=H2(f.end[v],1,f.strides[v],T,k,A);let V=f.strides[v]===1&&f.begin[v]===0&&f.end[v]===T;d=d&&V,h=h&&(v===0&&f.strides[v]===1||V)}else d=d&&f.strides[v]===1&&O,h=h&&(v===0&&f.strides[v]===1||O);let M,L=!1;if(f.beginValid&&f.endValid?(M=f.end[v]-f.begin[v],L=!0):w?(M=1,L=!0):O&&T>=0&&(f.strides[v]<0?M=-T:M=T,L=!0),L){let V;M===0||M<0!=f.strides[v]<0?V=0:V=Math.trunc(M/f.strides[v])+(M%f.strides[v]!==0?1:0),m.push(V)}else m.push(-1)}for(let v=0;v<f.finalShapeGatherIndices.length;++v){let w=f.finalShapeGatherIndices[v];w>=0?y.push(m[w]):w===MN&&y.push(1)}return{finalShapeSparse:y.filter((v,w)=>f.finalShapeGatherIndices[w]!==MN),finalShape:y,isIdentity:d,sliceDim0:h,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function ooe(t,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let e=0;n.beginValid=t.begin!=null,n.endValid=t.end!=null,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){let o=Math.min(n.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<o;e++)n.begin[e]=0,n.end[e]=0,n.strides[e]=1,n.beginMask|=1<<e,n.endMask|=1<<e,n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&t.newAxisMask)n.finalShapeGatherIndices.push(MN),n.finalShapeGatherIndicesSparse.push(-1);else{if(e===n.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${n.dims} dims, ${n.begin.length}.`);t.begin!=null&&(n.begin[e]=t.begin[r]),t.end!=null&&(n.end[e]=t.end[r]),n.strides[e]=t.strides[r],t.beginMask&1<<r&&(n.beginMask|=1<<e),t.endMask&1<<r&&(n.endMask|=1<<e),t.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(Yre),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<e):(n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[e]=r,e++}}function H2(t,n,e,r,o,s){if(o[n])return e>0?s[n]:s[n+1&1];{let i=t<0?r+t:t;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var ov=class{static sgd(n){return new Zl(n)}static momentum(n,e,r=!1){return new Fd(n,e,r)}static rmsprop(n,e=.9,r=0,o=null,s=!1){return new Md(n,e,r,o,s)}static adam(n=.001,e=.9,r=.999,o=null){return new _d(n,e,r,o)}static adadelta(n=.001,e=.95,r=null){return new Ad(n,e,r)}static adamax(n=.002,e=.9,r=.999,o=null,s=0){return new Od(n,e,r,o,s)}static adagrad(n,e=.1){return new Rd(n,e)}};var Tc=ov;var soe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function Nc(){return new Promise(t=>soe(()=>t()))}var N={};ft(N,{ERF_A1:()=>voe,ERF_A2:()=>woe,ERF_A3:()=>Coe,ERF_A4:()=>Ioe,ERF_A5:()=>Soe,ERF_P:()=>boe,PARALLELIZE_THRESHOLD:()=>sv,RowPartitionType:()=>aa,SELU_SCALE:()=>LN,SELU_SCALEALPHA:()=>PN,applyActivation:()=>Cc,assertAndGetBroadcastShape:()=>De,assertAxesAreInnerMostDims:()=>YJ,assertParamsConsistent:()=>ioe,assignToTypedArray:()=>Aoe,axesAreInnerMostDims:()=>pN,calculateShapes:()=>nne,checkEinsumDimSizes:()=>$oe,checkPadOnDimRoundingMode:()=>gt,combineLocations:()=>YF,combineRaggedTensorToTensorShapes:()=>loe,complexWithEvenIndex:()=>Eoe,complexWithOddIndex:()=>Doe,computeConv2DInfo:()=>pc,computeConv3DInfo:()=>VF,computeDefaultPad:()=>cN,computeDilation2DInfo:()=>XQ,computeOptimalWindowSize:()=>foe,computeOutAndReduceShapes:()=>fN,computeOutShape:()=>aoe,computePool2DInfo:()=>uN,computePool3DInfo:()=>YQ,convertConv2DDataFormat:()=>UF,decodeEinsumEquation:()=>Foe,eitherStridesOrDilationsAreOne:()=>Rn,expandShapeToKeepDim:()=>Io,exponent:()=>_oe,exponents:()=>Roe,fromStringArrayToUint8:()=>rse,fromUint8ToStringArray:()=>nse,getAxesPermutation:()=>dN,getBroadcastDims:()=>KF,getComplexWithIndex:()=>koe,getEinsumComputePath:()=>Poe,getEinsumPermutation:()=>Moe,getFusedBiasGradient:()=>wc,getFusedDyActivation:()=>vc,getImageCenter:()=>doe,getInnerMostAxes:()=>ZJ,getPermuted:()=>moe,getRaggedRank:()=>coe,getReductionAxes:()=>dt,getReshaped:()=>hoe,getReshapedPermuted:()=>goe,getRowPartitionTypesHelper:()=>uoe,getSliceBeginCoords:()=>yoe,getSliceSize:()=>xoe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Voe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Uoe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Goe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Hoe,getSparseReshapeInputOutputMismatchErrorMessage:()=>Koe,getSparseReshapeInputOutputMultipleErrorMessage:()=>qoe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Woe,getSparseReshapeNegativeOutputDimErrorMessage:()=>joe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Qoe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Xoe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Yoe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Zoe,getUndoAxesPermutation:()=>Mm,isIdentityPermutation:()=>Loe,log:()=>z7,mergeRealAndImagArrays:()=>Toe,prepareAndValidate:()=>Xre,prepareSplitSize:()=>zoe,segment_util:()=>zN,shouldFuse:()=>Ic,slice_util:()=>Sn,splitRealAndImagArrays:()=>Noe,stridesOrDilationsArePositive:()=>Rs,tupleValuesAreOne:()=>to,upcastType:()=>nn,validateDefaultValueShape:()=>poe,validateInput:()=>Bm,validateUpdateShape:()=>zM,warn:()=>Ds});function ioe(t,n){let e=t[0].length;t.forEach((o,s)=>{D(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),D(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let r=t[0];t.forEach((o,s)=>{for(let i=0;i<e;i++)D(i===n||o[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function aoe(t,n){let e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}var aa=function(t){return t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS",t}(aa||{});function loe(t,n,e){let r=new Array;if(e==null&&n==null)return r;if(n==null)for(;r.length<t+e.length;)r.push(-1);else r=n.slice();if(e==null)return r;if(t+e.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${r.length}`);for(let o=1;o<e.length;++o){let s=e[o],i=r[r.length-e.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${o+t}] = ${s} but shape[${o+t}] = ${a}`)}else r[i]=s}return r}function uoe(t){let n={FIRST_DIM_SIZE:aa.FIRST_DIM_SIZE,VALUE_ROWIDS:aa.VALUE_ROWIDS,ROW_LENGTHS:aa.ROW_LENGTHS,ROW_SPLITS:aa.ROW_SPLITS,ROW_LIMITS:aa.ROW_LIMITS,ROW_STARTS:aa.ROW_STARTS},e=[];for(let r of t)if(r in n)e.push(n[r]);else break;return e}function coe(t){return t.length===0?0:t[0]===aa.FIRST_DIM_SIZE?t.length-1:t.length}function poe(t,n){if(t==null||n==null)return;let e=t.length,r=n.length;if(e>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(e,r-1);++o){let s=t[o],i=n[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${o-t.length}] = ${s} but ragged tensor input.flatValues.shape[${o-t.length}] = ${i}`)}}var sv=30;function foe(t){return t<=sv?t:zp(t,Math.floor(Math.sqrt(t)))}function doe(t,n,e){let r=e*(typeof t=="number"?t:t[0]),o=n*(typeof t=="number"?t:t[1]);return[r,o]}function hoe(t,n,e,r=!0){let o=[];if(r)o=o.concat(n.slice(0)),o.push(t[0]/e),o=o.concat(t.slice(1));else{o=o.concat(t[0]);let s=n.length;for(let i=0;i<s;++i)o=o.concat([t[i+1]/n[i],n[i]]);o=o.concat(t.slice(s+1))}return o}function moe(t,n,e=!0){let r=[];if(e){r.push(n);for(let o=n+1;o<t;++o)o<=2*n?(r.push(o),r.push(o-(n+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<t;++i)i>=n*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function goe(t,n,e,r=!0){let o=[];r?o.push(t[0]/e):o.push(t[0]*e);for(let s=1;s<t.length;++s)s<=n.length?r?o.push(n[s-1]*t[s]):o.push(t[s]/n[s-1]):o.push(t[s]);return o}function yoe(t,n){let e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function xoe(t,n,e){let r=t.slice(0,1);for(let o=0;o<e;++o)r.push(t[o+1]-n[o][0]-n[o][1]);return r}var PN=1.7580993408473768,LN=1.0507009873554805;var boe=.3275911,voe=.254829592,woe=-.284496736,Coe=1.421413741,Ioe=-1.453152027,Soe=1.061405429;function Toe(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);let e=new Float32Array(t.length*2);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function Noe(t){let n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function Eoe(t){let n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let o=0;o<t.length;o+=4)e[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:e,imag:r}}function Doe(t){let n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let o=2;o<t.length;o+=4)e[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:e,imag:r}}function koe(t,n){let e=t[n*2],r=t[n*2+1];return{real:e,imag:r}}function Aoe(t,n,e,r){t[r*2]=n,t[r*2+1]=e}function Roe(t,n){let e=new Float32Array(t/2),r=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){let s=(n?2:-2)*Math.PI*(o/t);e[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:e,imag:r}}function _oe(t,n,e){let r=(e?2:-2)*Math.PI*(t/n),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var BN="->",Ooe=/->/g,t$=",",n$="...";function Foe(t,n){t=t.replace(/\s/g,"");let e=(t.length-t.replace(Ooe,"").length)/BN.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${BN}").`);let[r,o]=t.split(BN);D(r.indexOf(n$)===-1,()=>`The ellipsis notation ("${n$}") is not supported yet.`);let s=r.split(t$),i=s.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let f=0;f<o.length;++f){let d=o[f];if(!s.some(h=>h.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){let d=r[f];a.indexOf(d)===-1&&d!==t$&&a.push(d)}let l=new Array(s.length);for(let f=0;f<i;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<s[f].length;++d)l[f].push(a.indexOf(s[f][d]))}let u=a.length,c=o.length,p=[];for(let f=c;f<u;++f)p.push(f);return{allDims:a,summedDims:p,idDims:l}}function Moe(t,n){let e=new Array(t);e.fill(-1);for(let o=0;o<n.length;++o)e[n[o]]=o;let r=[];for(let o=0;o<t;++o)e[o]===-1&&r.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:r}}function $oe(t,n,e){let r=new Array(t);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<n[o].length;++i)r[n[o][i]]===void 0?r[n[o][i]]=s[i]:D(r[n[o][i]]===s[i],()=>`Expected dimension ${r[n[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function Poe(t,n){let e=t,r=[],o=0;t.length===0&&e.push(-1),o=t.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],l=Boe(n,a);for(let u of l)s.indexOf(u)===-1&&(r[i].push(u),s.push(u))}return{path:e,steps:r}}function Loe(t){return t.every((n,e)=>n===e)}function Boe(t,n){let e=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(n)!==-1||n===-1)&&e.push(r);return e}function zoe(t,n,e=0){let r=[];if(typeof n=="number")D(t.shape[e]%n===0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{let o=n.reduce((i,a)=>(a===-1&&(i+=1),i),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=n.indexOf(-1);if(s!==-1){let i=n.reduce((a,l)=>l>0?a+l:a);n[s]=t.shape[e]-i}D(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function Voe(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function Uoe(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function Goe(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}function Woe(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function joe(t,n){return`size ${t} must be non-negative, not ${n}`}function Hoe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function qoe(t,n){let e=Le(t),r=Le(n);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${n}`}function Koe(t,n){let e=Le(t),r=Le(n);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${n}`}function Xoe(){return"segment ids must be >= 0"}function Yoe(){return"segment ids are not increasing"}function Zoe(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function Qoe(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}var zN={};ft(zN,{collectGatherOpShapeInfo:()=>tse,computeOutShape:()=>ese,segOpComputeOptimalWindowSize:()=>Joe});function Joe(t,n){let e=!1,r;for(t<=sv?(r=t,e=!0):r=zp(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=zp(t,r+1);return r}function ese(t,n,e){let r=[],o=t.length;for(let s=0;s<o;s++)s!==n?r.push(t[s]):r.push(e);return r}function tse(t,n,e,r){let o=n.shape.length,s=t.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let p=0;p<r;++p)if(t.shape[p]!==n.shape[p])throw new Error(`x.shape[${p}]: ${t.shape[p]} should be equal to indices.shape[${p}]: ${n.shape[p]}.`);let i=t.shape[e],a=[],l=1,u=1,c=1;for(let p=0;p<r;++p)a.push(t.shape[p]),l*=t.shape[p];for(let p=r;p<e;p++)a.push(t.shape[p]),u*=t.shape[p];for(let p=r;p<o;p++)a.push(n.shape[p]);for(let p=e+1;p<s;p++)a.push(t.shape[p]),c*=t.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function nse(t){try{return t.map(n=>Qf(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function rse(t){return t.map(n=>Zf(n))}var Wn={};ft(Wn,{nonMaxSuppressionV3Impl:()=>Xb,nonMaxSuppressionV4Impl:()=>Yb,nonMaxSuppressionV5Impl:()=>Zb,whereImpl:()=>Gb});_2();var ose=$();ose.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Lr=function(t){return t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF",t}(Lr||{}),r$;(function(t){let n;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(r$||(r$={}));var ise={};function iv(t){return ise[t]}function C(t,n,e,r,o){let s=n.inputParams[t];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,u=a<0?n.inputNames.length+a:a;if(s.type==="tensor")return on(n.inputNames[u],e,r,o);if(s.type==="tensors"){let f=n.inputs.slice(a,l);return n.inputNames.slice(a,l).filter((h,g)=>{var m;return((m=f[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(h=>on(h,e,r,o))}let c=on(n.inputNames[u],e,r,o),p=c.dataSync();return s.type==="number"?p[0]:b.toNestedArray(c.shape,p)}let i=n.attrParams[t];return i&&i.value}function on(t,n,e,r){let[o,s]=ur(t,e);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!n[av(o,a)]);return i!==void 0?n[av(o,i)][s]:void 0}function VN(t,n,e){return n[av(t,e.currentContextId)]}function es(t,n){let[e,r,o]=ur(t,n);return[av(e,n&&n.currentContextId),r,o]}function av(t,n){return n?`${t}-${n}`:t}function ur(t,n){if(t==="")return["",0,void 0];let e=n!=null&&n.parseNodeNameCache!=null;if(e){let s=n.parseNodeNameCache.get(t);if(s!=null)return s}let r=t.split(":"),o;if(r.length===1)o=[t,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return e&&n.parseNodeNameCache.set(t,o),o}function Wm(t,n,e){let r=C("pad",t,n,e);if(r==="explicit"){r=C("explicitPaddings",t,n,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function ts(t){return t.kept?t:ir(t)}var UN={};ft(UN,{json:()=>ase});var ase=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var GN={};ft(GN,{json:()=>lse});var lse=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var WN={};ft(WN,{json:()=>use});var use=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var jN={};ft(jN,{json:()=>cse});var cse=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var HN={};ft(HN,{json:()=>pse});var pse=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var qN={};ft(qN,{json:()=>fse});var fse=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var KN={};ft(KN,{json:()=>dse});var dse=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var XN={};ft(XN,{json:()=>hse});var hse=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var YN={};ft(YN,{json:()=>mse});var mse=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var ZN={};ft(ZN,{json:()=>gse});var gse=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var QN={};ft(QN,{json:()=>yse});var yse=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var JN={};ft(JN,{json:()=>xse});var xse=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var eE={};ft(eE,{json:()=>bse});var bse=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var tE={};ft(tE,{json:()=>vse});var vse=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var nE={};ft(nE,{json:()=>wse});var wse=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var rE={};ft(rE,{json:()=>Cse});var Cse=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var oE={};ft(oE,{json:()=>Ise});var Ise=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var sE={};ft(sE,{json:()=>Sse});var Sse=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var iE={};ft(iE,{json:()=>Tse});var Tse=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var jm=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let n=[UN,GN,WN,jN,HN,qN,KN,XN,YN,ZN,QN,JN,eE,tE,nE,rE,oE,sE,iE],e=[].concat(...n.map(r=>r.json));this.opMappers=e.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(n,e={}){let r=n.node,o=[],s=[],i=[],a=r.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?o.push(g[m.name]):m.op==="Const"?s.push(g[m.name]):(m.input==null||m.input.length===0)&&i.push(g[m.name]),g),{}),l=[],u=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let f=Object.keys(a);f.forEach(g=>{let m=a[g];m.inputNames.forEach((y,x)=>{let[v,,w]=es(y),T=a[v];if(T.outputs!=null){let k=T.outputs.indexOf(w);if(k!==-1){let A=`${v}:${k}`;m.inputNames[x]=A}}m.inputs.push(T),T.children.push(m)})}),Object.keys(p).length===0?f.forEach(g=>{let m=a[g];m.children.length===0&&u.push(m)}):Object.keys(p).forEach(g=>{let[m]=es(g),y=a[m];y!=null&&(y.signatureKey=p[g],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{let[m]=es(g),y=a[m];y&&(y.signatureKey=c[g],l.push(y))}):l=o;let d={};n.library!=null&&n.library.function!=null&&(d=n.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));let h={nodes:a,inputs:l,outputs:u,weights:s,placeholders:o,signature:e,functions:d};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(n){return Object.keys(n||{}).reduce((e,r)=>(e[n[r].name]=r,e),{})}mapNode(n){let e=iv(n.op)||this.opMappers[n.op]||{};n.attr==null&&(n.attr={});let r={name:n.name,op:n.op,category:e.category,inputNames:(n.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr,outputs:e.outputs};return e.inputs!=null&&(r.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(r.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=lv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=lv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=mv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=mv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=cv(n.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=cv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=hv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=hv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=uv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=uv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=yv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=yv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=dv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=dv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=gv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=gv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=pv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=pv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=fv(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=fv(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=o$(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=o$(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${n.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(n){let e=n.nodeDef,r=[],o=[],s={};e!=null&&(s=e.reduce((p,f)=>(p[f.name]=this.mapNode(f),f.op==="Const"&&o.push(p[f.name]),p),{}));let i=[],a=[];n.signature.inputArg.forEach(p=>{let[f]=es(p.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:aE(p.type),type:"dtype"}},children:[]};d.signatureKey=p.name,i.push(d),s[f]=d}),Object.keys(s).forEach(p=>{let f=s[p];f.inputNames.forEach((d,h)=>{let[g,,m]=es(d),y=s[g];if(y.outputs!=null){let x=y.outputs.indexOf(m);if(x!==-1){let v=`${g}:${x}`;f.inputNames[h]=v}}f.inputs.push(y),y.children.push(f)})});let u=n.ret;n.signature.outputArg.forEach(p=>{let[f,d]=es(u[p.name]),h=s[f];h!=null&&(h.defaultOutput=d,a.push(h))});let c=this.mapArgsToSignature(n);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:c}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:n.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,n.ret),e),{})}}mapArgToTensorInfo(n,e){let r=n.name;return e!=null&&(r=e[r]),{name:r,dtype:n.type}}};function Nse(t){let n=$().global;if(typeof n.atob<"u")return n.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function s$(t,n){let e=Array.isArray(t)?String.fromCharCode.apply(null,t):Nse(t);return n?e:e.toLowerCase()}function lv(t,n,e,r=!1){let o=t[n];return o!=null?s$(o.s,r):e}function uv(t,n,e){let r=t[n];return r?r.b:e}function cv(t,n,e){let r=t[n]||{},o=r.i!=null?r.i:r.f!=null?r.f:e;return typeof o=="number"?o:parseInt(o,10)}function aE(t){switch(typeof t=="string"&&(t=Lr[t]),t){case Lr.DT_FLOAT:case Lr.DT_HALF:return"float32";case Lr.DT_INT32:case Lr.DT_INT64:case Lr.DT_INT8:case Lr.DT_UINT8:return"int32";case Lr.DT_BOOL:return"bool";case Lr.DT_DOUBLE:return"float32";case Lr.DT_STRING:return"string";case Lr.DT_COMPLEX64:case Lr.DT_COMPLEX128:return"complex64";default:return null}}function o$(t,n,e){let r=t[n];return r&&r.func?r.func.name:e}function pv(t,n,e){let r=t[n];return r&&r.type?aE(r.type):e}function fv(t,n,e){let r=t[n];return r&&r.list&&r.list.type?r.list.type.map(o=>aE(o)):e}function i$(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(n=>typeof n.size=="number"?n.size:parseInt(n.size,10)):[]}function dv(t,n,e){let r=t[n];return r&&r.shape?i$(r.shape):e}function hv(t,n,e){let r=t[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function mv(t,n,e,r=!1){let o=t[n];return o&&o.list&&o.list.s?o.list.s.map(s=>s$(s,r)):e}function gv(t,n,e){let r=t[n];return r&&r.list&&r.list.shape?r.list.shape.map(o=>i$(o)):e}function yv(t,n,e){let r=t[n];return r&&r.list&&r.list.b?r.list.b:e}var xv=class{constructor(n,e,r){this.node=n,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(o=>this.getInput(o)),n.rawAttrs!=null&&(this.attrs=Object.keys(n.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(n){return on(n,this.tensorMap,this.context)}getAttr(n,e){let r=this.node.rawAttrs[n];if(r.tensor!=null)return on(n,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return cv(this.node.rawAttrs,n,e);if(r.s!=null)return lv(this.node.rawAttrs,n,e);if(r.b!=null)return uv(this.node.rawAttrs,n,e);if(r.shape!=null)return dv(this.node.rawAttrs,n,e);if(r.type!=null)return pv(this.node.rawAttrs,n,e);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return hv(this.node.rawAttrs,n,e);if(r.list.s!=null)return mv(this.node.rawAttrs,n,e);if(r.list.shape!=null)return gv(this.node.rawAttrs,n,e);if(r.list.b!=null)return yv(this.node.rawAttrs,n,e);if(r.list.type!=null)return fv(this.node.rawAttrs,n,e)}return e}};var et={};ft(et,{OP_SCOPE_SUFFIX:()=>QT,abs:()=>St,acos:()=>qx,acosh:()=>Kx,add:()=>W,addN:()=>zF,all:()=>sd,any:()=>cc,argMax:()=>As,argMin:()=>Xx,asin:()=>Yx,asinh:()=>Zx,atan:()=>Qx,atan2:()=>Jx,atanh:()=>eb,avgPool:()=>Ml,avgPool3d:()=>tb,basicLSTMCell:()=>GF,batchNorm:()=>_s,batchNorm2d:()=>nb,batchNorm3d:()=>rb,batchNorm4d:()=>ob,batchToSpaceND:()=>$l,bincount:()=>sb,bitwiseAnd:()=>jF,booleanMaskAsync:()=>pne,broadcastArgs:()=>HF,broadcastTo:()=>Os,buffer:()=>he,cast:()=>K,ceil:()=>ib,clipByValue:()=>vn,clone:()=>ir,complex:()=>br,concat:()=>Je,concat1d:()=>ab,concat2d:()=>ad,concat3d:()=>lb,concat4d:()=>ub,conv1d:()=>ld,conv2d:()=>vr,conv2dTranspose:()=>cd,conv3d:()=>cb,conv3dTranspose:()=>fb,cos:()=>Pl,cosh:()=>pd,cosineWindow:()=>zm,cumprod:()=>fc,cumsum:()=>fd,denseBincount:()=>Fm,depthToSpace:()=>db,depthwiseConv2d:()=>Fs,diag:()=>qF,dilation2d:()=>hb,div:()=>ne,divNoNan:()=>mb,dot:()=>gb,dropout:()=>CN,einsum:()=>Ll,elu:()=>Ms,enclosingPowerOfTwo:()=>IN,ensureShape:()=>XF,equal:()=>Zn,erf:()=>dd,euclideanNorm:()=>yb,exp:()=>Ht,expandDims:()=>Pt,expm1:()=>xb,eye:()=>dc,fft:()=>Kl,fill:()=>Co,floor:()=>$s,floorDiv:()=>od,fused:()=>Yl,gather:()=>Ps,gatherND:()=>wne,greater:()=>Lt,greaterEqual:()=>ar,ifft:()=>ia,imag:()=>Bl,image:()=>In,inTopKAsync:()=>Sne,irfft:()=>Td,isFinite:()=>bb,isInf:()=>vb,isNaN:()=>wb,leakyRelu:()=>zl,less:()=>oa,lessEqual:()=>$r,linalg:()=>TN,linspace:()=>QF,localResponseNormalization:()=>Cb,log:()=>Cn,log1p:()=>Vl,logSigmoid:()=>Ib,logSoftmax:()=>hd,logSumExp:()=>Ul,logicalAnd:()=>Vn,logicalNot:()=>Gl,logicalOr:()=>md,logicalXor:()=>Sb,losses:()=>Nre,lowerBound:()=>JF,matMul:()=>Fe,max:()=>wn,maxPool:()=>Wl,maxPool3d:()=>Nb,maxPoolWithArgmax:()=>eM,maximum:()=>Cr,mean:()=>xt,meshgrid:()=>tM,min:()=>na,minimum:()=>ro,mirrorPad:()=>Eb,mod:()=>Db,moments:()=>hc,movingAverage:()=>hne,mul:()=>R,multiRNNCell:()=>nM,multinomial:()=>rM,neg:()=>$e,norm:()=>ra,notEqual:()=>Zo,oneHot:()=>mc,ones:()=>en,onesLike:()=>hn,op:()=>S,outerProduct:()=>oM,pad:()=>lr,pad1d:()=>sM,pad2d:()=>iM,pad3d:()=>aM,pad4d:()=>lM,pool:()=>kb,pow:()=>zn,prelu:()=>Hl,print:()=>Hx,prod:()=>Ab,raggedGather:()=>uM,raggedRange:()=>cM,raggedTensorToTensor:()=>pM,rand:()=>fM,randomGamma:()=>kM,randomNormal:()=>xc,randomStandardNormal:()=>AM,randomUniform:()=>Pr,randomUniformInt:()=>RM,range:()=>Ls,real:()=>sa,reciprocal:()=>Mb,relu:()=>Fn,relu6:()=>gd,reshape:()=>_,reverse:()=>un,reverse1d:()=>_M,reverse2d:()=>OM,reverse3d:()=>FM,reverse4d:()=>MM,rfft:()=>Xl,round:()=>yd,rsqrt:()=>xd,scalar:()=>se,scatterND:()=>gne,searchSorted:()=>$m,selu:()=>bd,separableConv2d:()=>vd,setdiff1dAsync:()=>$M,sigmoid:()=>_n,sign:()=>$b,signal:()=>Tre,sin:()=>wd,sinh:()=>Cd,slice:()=>ve,slice1d:()=>Id,slice2d:()=>Lm,slice3d:()=>Sd,slice4d:()=>bc,softmax:()=>ql,softplus:()=>Yo,spaceToBatchND:()=>jl,sparse:()=>Ere,sparseToDense:()=>bne,spectral:()=>Sre,split:()=>cn,sqrt:()=>ct,square:()=>_e,squaredDifference:()=>Nd,squeeze:()=>Qn,stack:()=>Bt,step:()=>So,stridedSlice:()=>Pb,string:()=>Dre,sub:()=>te,sum:()=>ie,tan:()=>Lb,tanh:()=>Xo,tensor:()=>xn,tensor1d:()=>Tt,tensor2d:()=>Qo,tensor3d:()=>Bb,tensor4d:()=>PM,tensor5d:()=>LM,tensor6d:()=>BM,tensorScatterUpdate:()=>UM,tile:()=>On,topk:()=>zb,transpose:()=>Me,truncatedNormal:()=>Ed,unique:()=>Vb,unsortedSegmentSum:()=>Dd,unstack:()=>pn,upperBound:()=>GM,variable:()=>Ub,where:()=>yt,whereAsync:()=>Wb,zeros:()=>bt,zerosLike:()=>ye});var a$=(t,n,e,r=et)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(C("a",t,n,e),C("b",t,n,e))];case"AddN":return[r.addN(C("tensors",t,n,e))];case"FloorMod":case"Mod":return[r.mod(C("a",t,n,e),C("b",t,n,e))];case"Mul":return[r.mul(C("a",t,n,e),C("b",t,n,e))];case"RealDiv":case"Div":return[r.div(C("a",t,n,e),C("b",t,n,e))];case"DivNoNan":return[r.divNoNan(C("a",t,n,e),C("b",t,n,e))];case"FloorDiv":return[r.floorDiv(C("a",t,n,e),C("b",t,n,e))];case"Sub":return[r.sub(C("a",t,n,e),C("b",t,n,e))];case"Minimum":return[r.minimum(C("a",t,n,e),C("b",t,n,e))];case"Maximum":return[r.maximum(C("a",t,n,e),C("b",t,n,e))];case"Pow":return[r.pow(C("a",t,n,e),C("b",t,n,e))];case"SquaredDifference":return[r.squaredDifference(C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var l$=(t,n,e,r=et)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(C("x",t,n,e))];case"Acos":return[r.acos(C("x",t,n,e))];case"Acosh":return[r.acosh(C("x",t,n,e))];case"Asin":return[r.asin(C("x",t,n,e))];case"Asinh":return[r.asinh(C("x",t,n,e))];case"Atan":return[r.atan(C("x",t,n,e))];case"Atan2":return[r.atan2(C("x",t,n,e),C("y",t,n,e))];case"Atanh":return[r.atanh(C("x",t,n,e))];case"Ceil":return[r.ceil(C("x",t,n,e))];case"Complex":return[r.complex(C("real",t,n,e),C("imag",t,n,e))];case"Cos":return[r.cos(C("x",t,n,e))];case"Cosh":return[r.cosh(C("x",t,n,e))];case"Elu":return[r.elu(C("x",t,n,e))];case"Erf":return[r.erf(C("x",t,n,e))];case"Exp":return[r.exp(C("x",t,n,e))];case"Expm1":return[r.expm1(C("x",t,n,e))];case"Floor":return[r.floor(C("x",t,n,e))];case"Log":return[r.log(C("x",t,n,e))];case"Log1p":return[r.log1p(C("x",t,n,e))];case"Imag":return[r.imag(C("x",t,n,e))];case"Neg":return[r.neg(C("x",t,n,e))];case"Reciprocal":return[r.reciprocal(C("x",t,n,e))];case"Real":return[r.real(C("x",t,n,e))];case"Relu":return[r.relu(C("x",t,n,e))];case"Round":return[r.round(C("x",t,n,e))];case"Selu":return[r.selu(C("x",t,n,e))];case"Sigmoid":return[r.sigmoid(C("x",t,n,e))];case"Sin":return[r.sin(C("x",t,n,e))];case"Sign":return[r.sign(C("x",t,n,e))];case"Sinh":return[r.sinh(C("x",t,n,e))];case"Softplus":return[r.softplus(C("x",t,n,e))];case"Sqrt":return[r.sqrt(C("x",t,n,e))];case"Square":return[r.square(C("x",t,n,e))];case"Tanh":return[r.tanh(C("x",t,n,e))];case"Tan":return[r.tan(C("x",t,n,e))];case"ClipByValue":return[r.clipByValue(C("x",t,n,e),C("clipValueMin",t,n,e),C("clipValueMax",t,n,e))];case"Relu6":return[r.relu6(C("x",t,n,e))];case"Rsqrt":return[r.rsqrt(on(t.inputNames[0],n,e))];case"LeakyRelu":return[r.leakyRelu(C("x",t,n,e),C("alpha",t,n,e))];case"Prelu":return[r.prelu(C("x",t,n,e),C("alpha",t,n,e))];case"IsNan":return[r.isNaN(on(t.inputNames[0],n,e))];case"IsInf":return[r.isInf(on(t.inputNames[0],n,e))];case"IsFinite":return[r.isFinite(on(t.inputNames[0],n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Br(t,n,e=""){if(!(typeof t=="number"||typeof n=="number")){b.assert(t.length===n.length,()=>e+` Shapes ${t} and ${n} must match`);for(let r=0;r<t.length;r++){let o=t[r],s=n[r];b.assert(o<0||s<0||o===s,()=>e+` Shapes ${t} and ${n} must match`)}}}function u$(t){return!(typeof t=="number"||t.some(n=>n<0))}function $d(t,n,e){let r=bv(t,e),o=!u$(r);if(o&&n.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&n.forEach(s=>{r=bv(s.shape,r)}),!u$(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function bv(t,n){if(typeof t=="number")return n;if(typeof n=="number")return t;if(t.length!==n.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${n}`);let e=[];for(let r=0;r<t.length;++r){let o=t[r],s=n[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${n}`);e[r]=o>=0?o:s}return e}var vv=class{constructor(n,e,r,o,s,i,a){this.name=n,this.dtype=e,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=se(0),kt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(e=>{(n==null||!n.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);let e=this.tensors[n];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(n){return n.map(e=>this.read(e))}write(n,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[n]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Br(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=e,kt(e),r.written=!0,this.tensors[n]=r}writeMany(n,e){if(n.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${e.length}.`);n.forEach((r,o)=>this.write(r,e[o]))}gather(n,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(n)n=n.slice(0,this.size());else{n=[];for(let o=0;o<this.size();o++)n.push(o)}if(n.length===0)return xn([],[0].concat(this.elementShape));let r=this.readMany(n);return Br(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Bt(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(this.size()===0)return xn([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let r=this.readMany(e);return Br(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Je(r,0)}scatter(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);let r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,pn(e,0))}split(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0,o=n.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:e.size/r,i=[];B(()=>{e=_(e,[1,r,s]);for(let l=0;l<n.length;++l){let c=[0,l===0?0:o[l-1],0],p=[1,n[l],s];i[l]=_(ve(e,c,p),this.elementShape)}return i});let a=[];for(let l=0;l<n.length;l++)a[l]=l;this.writeMany(a,i)}};var Pd=class t{get id(){return this.idTensor.id}constructor(n,e,r,o=-1){this.tensors=n,this.elementShape=e,this.elementDtype=r,n?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);Br(e,s.shape,"TensorList shape mismatch: "),kt(s)}),this.idTensor=se(0),this.maxNumElements=o,kt(this.idTensor)}copy(){return new t([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(e=>{(n==null||!n.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Br(n,this.elementShape,"TensorList shape mismatch: ");let o=$d(this.elementShape,this.tensors,n);return B(()=>{let s=this.tensors.map(i=>_(i,o));return Bt(s,0)})}popBack(n,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=$d(this.elementShape,this.tensors,n),o=this.tensors.pop();return o.kept=!1,Br(o.shape,n,"TensorList shape mismatch: "),_(o,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(Br(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");kt(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(this.maxNumElements!==-1&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);let e=new t([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=n;for(let r=0;r<Math.min(this.tensors.length,n);++r)e.tensors[r]=this.tensors[r];return e}getItem(n,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(this.tensors[n]==null)throw new Error(`element at index ${n} is null.`);Br(this.tensors[n].shape,e,"TensorList shape mismatch: ");let o=$d(this.elementShape,this.tensors,e);return _(this.tensors[n],o)}setItem(n,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(n<0||this.maxNumElements!==-1&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);Br(this.elementShape,e.shape,"TensorList shape mismatch: "),kt(e),this.tensors[n]!=null&&(this.tensors[n].kept=!1),this.tensors[n]=e}gather(n,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Br(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());let o=$d(this.elementShape,this.tensors,r);return n.length===0?xn([],[0].concat(o)):B(()=>{let s=n.map(i=>_(this.tensors[i],o));return Bt(s,0)})}concat(n,e){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);Br(this.elementShape,e,"TensorList shape mismatch: ");let r=$d(this.elementShape,this.tensors,e);return this.size()===0?xn([],[0].concat(r)):B(()=>{let o=this.tensors.map(s=>_(s,r));return Je(o,0)})}};function c$(t,n,e){let r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==e)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${e}`);let o=t.shape.slice(1);Br(o,n,"TensorList shape mismatch: ");let s=pn(t);return new Pd(s,n,r)}function p$(t,n,e,r){return new Pd([],t,n,r)}function f$(t,n,e,r){if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);let o=Math.max(...n);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new Pd([],e,t.dtype,r),i=pn(t,0);return n.forEach((a,l)=>{s.setItem(a,i[l])}),s}function d$(t,n,e){let r=0,o=n.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);let s=t.shape.slice(1),i=bv(s,e),a=r===0?0:t.size/r,l=B(()=>{let c=[];t=_(t,[1,r,a]);for(let p=0;p<n.length;++p){let d=[0,p===0?0:o[p-1],0],h=[1,n[p],a];c[p]=_(ve(t,d,h),i)}return t.dispose(),c}),u=new Pd([],e,t.dtype,n.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var h$=(t,n,e)=>z(void 0,null,function*(){switch(t.op){case"If":case"StatelessIf":{let r=C("thenBranch",t,n,e),o=C("elseBranch",t,n,e),s=C("cond",t,n,e),i=C("args",t,n,e);return(yield s.data())[0]?e.functionMap[r].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let r=C("body",t,n,e),o=C("cond",t,n,e),s=C("args",t,n,e),i=yield e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),l=yield i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){let c=u;u=yield e.functionMap[r].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap);let p=u.map(d=>d.id);c.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()});let f=yield e.functionMap[o].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap);l=yield f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()})}return u}case"LoopCond":{let r=C("pred",t,n,e);return[ts(r)]}case"Switch":{let r=C("pred",t,n,e),o=C("data",t,n,e);return o.kept||(o=ts(o)),(yield r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=t.inputNames.find(o=>on(o,n,e)!==void 0);if(r){let o=on(r,n,e);return[ts(o)]}return}case"Enter":{let r=C("frameName",t,n,e),o=C("tensor",t,n,e);return e.enterFrame(r),[ts(o)]}case"Exit":{let r=C("tensor",t,n,e);return e.exitFrame(),[ts(r)]}case"NextIteration":{let r=C("tensor",t,n,e);return e.nextIteration(),[ts(r)]}case"TensorArrayV3":{let r=C("size",t,n,e),o=C("dtype",t,n,e),s=C("elementShape",t,n,e),i=C("dynamicSize",t,n,e),a=C("clearAfterRead",t,n,e),l=C("identicalElementShapes",t,n,e),u=C("name",t,n,e),c=new vv(u,o,r,s,l,i,a);return e.addTensorArray(c),[c.idTensor,se(1)]}case"TensorArrayWriteV3":{let r=C("tensorArrayId",t,n,e),o=C("index",t,n,e),s=C("tensor",t,n,e),i=e.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=C("tensorArrayId",t,n,e),o=C("index",t,n,e);return[e.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=C("tensorArrayId",t,n,e),o=C("indices",t,n,e),s=C("dtype",t,n,e);return[e.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=C("tensorArrayId",t,n,e),o=C("indices",t,n,e),s=C("tensor",t,n,e),i=e.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=C("tensorArrayId",t,n,e),o=e.getTensorArray(r.id),s=C("dtype",t,n,e);return[o.concat(s)]}case"TensorArraySplitV3":{let r=C("tensorArrayId",t,n,e),o=C("tensor",t,n,e),s=C("lengths",t,n,e),i=e.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=C("tensorArrayId",t,n,e),o=e.getTensorArray(r.id);return[se(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=C("tensorArrayId",t,n,e),o=e.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=C("tensorListId",t,n,e),o=C("index",t,n,e),s=C("tensor",t,n,e),i=e.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=C("tensorListId",t,n,e),o=C("index",t,n,e),s=C("elementShape",t,n,e),i=C("elementDType",t,n,e);return[e.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=C("indices",t,n,e),o=C("tensor",t,n,e),s=C("elementShape",t,n,e),i=C("numElements",t,n,e),a=f$(o,r,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=C("elementShape",t,n,e),o=C("elementDType",t,n,e),s;t.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=C(s,t,n,e),a=t.op==="TensorListReserve"?-1:i,l=p$(r,o,i,a);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=C("tensorListId",t,n,e),o=C("indices",t,n,e),s=C("elementShape",t,n,e),i=C("elementDType",t,n,e);return[e.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=C("tensorListId",t,n,e),o=C("elementShape",t,n,e),s=C("elementDType",t,n,e),i=C("numElements",t,n,e);return[e.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=C("tensor",t,n,e),o=C("elementShape",t,n,e),s=C("elementDType",t,n,e),i=c$(r,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=C("tensorListId",t,n,e),o=e.getTensorList(r.id),s=C("dtype",t,n,e),i=C("elementShape",t,n,e);return[o.concat(s,i)]}case"TensorListPushBack":{let r=C("tensorListId",t,n,e),o=C("tensor",t,n,e),s=e.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=C("tensorListId",t,n,e),o=C("elementShape",t,n,e),s=C("elementDType",t,n,e);return[e.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=C("tensor",t,n,e),o=C("elementShape",t,n,e),s=C("lengths",t,n,e),i=d$(r,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=C("tensorListId",t,n,e),o=e.getTensorList(r.id);return[se(o.size(),"int32")]}case"TensorListResize":{let r=C("tensorListId",t,n,e),o=C("size",t,n,e),i=e.getTensorList(r.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});function m$(t,n,e){let[r,o]=C("fusedOps",t,n,e),s=r==="biasadd",i=!s,a=o==="prelu",l=r==="fusedbatchnorm",u=C("numArgs",t,n,e);if(s){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=C("strides",t,n,e),p=Wm(t,n,e),f=C("dataFormat",t,n,e).toUpperCase(),d=C("dilations",t,n,e),[h,g]=C("args",t,n,e);i&&(g=h,h=void 0);let m=C("leakyreluAlpha",t,n,e);return{stride:c,pad:p,dataFormat:f,dilations:d,biasArg:h,preluArg:g,activationFunc:o,leakyreluAlpha:m}}var g$=(t,n,e,r=et)=>{switch(t.op){case"Conv1D":{let o=C("stride",t,n,e),s=C("pad",t,n,e),i=C("dataFormat",t,n,e).toUpperCase(),a=C("dilation",t,n,e);return[r.conv1d(C("x",t,n,e),C("filter",t,n,e),o,s,i,a)]}case"Conv2D":{let o=C("strides",t,n,e),s=Wm(t,n,e),i=C("dataFormat",t,n,e).toUpperCase(),a=C("dilations",t,n,e);return[r.conv2d(C("x",t,n,e),C("filter",t,n,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:p}=m$(t,n,e);return[r.fused.conv2d({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:p}=m$(t,n,e);return[r.fused.depthwiseConv2d({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=C("outputShape",t,n,e),s=C("strides",t,n,e),i=Wm(t,n,e);return[r.conv2dTranspose(C("x",t,n,e),C("filter",t,n,e),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=C("strides",t,n,e),s=Wm(t,n,e),i=C("dilations",t,n,e),a=C("dataFormat",t,n,e).toUpperCase();return[r.depthwiseConv2d(C("input",t,n,e),C("filter",t,n,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("dataFormat",t,n,e).toUpperCase(),a=C("dilations",t,n,e);return[r.conv3d(C("x",t,n,e),C("filter",t,n,e),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("kernelSize",t,n,e);return[r.avgPool(C("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("kernelSize",t,n,e);return[r.maxPool(C("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("kernelSize",t,n,e),a=C("includeBatchInIndex",t,n,e),{result:l,indexes:u}=r.maxPoolWithArgmax(C("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s,a);return[l,u]}case"AvgPool3D":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("kernelSize",t,n,e);return[r.avgPool3d(C("x",t,n,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("kernelSize",t,n,e);return[r.maxPool3d(C("x",t,n,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=C("strides",t,n,e),s=C("pad",t,n,e),i=C("dilations",t,n,e),a=o[1],l=o[2],u=i[1],c=i[2];return[r.dilation2d(C("x",t,n,e),C("filter",t,n,e),[a,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var y$=(t,n,e,r=et)=>{switch(t.op){case"Fill":{let o=C("shape",t,n,e),s=C("dtype",t,n,e),i=C("value",t,n,e);return[r.fill(o,i,s)]}case"LinSpace":{let o=C("start",t,n,e),s=C("stop",t,n,e),i=C("num",t,n,e);return[r.linspace(o,s,i)]}case"Multinomial":{let o=C("logits",t,n,e),s=C("numSamples",t,n,e),i=C("seed",t,n,e);return[r.multinomial(o,s,i)]}case"OneHot":{let o=C("indices",t,n,e),s=C("depth",t,n,e),i=C("onValue",t,n,e),a=C("offValue",t,n,e),l=C("dtype",t,n,e);return[r.oneHot(o,s,i,a,l)]}case"Ones":return[r.ones(C("shape",t,n,e),C("dtype",t,n,e))];case"OnesLike":return[r.onesLike(C("x",t,n,e))];case"RandomStandardNormal":return[r.randomStandardNormal(C("shape",t,n,e),C("dtype",t,n,e),C("seed",t,n,e))];case"RandomUniform":return[r.randomUniform(C("shape",t,n,e),C("minval",t,n,e),C("maxval",t,n,e),C("dtype",t,n,e))];case"RandomUniformInt":return[r.randomUniformInt(C("shape",t,n,e),C("minval",t,n,e),C("maxval",t,n,e),C("seed",t,n,e))];case"Range":{let o=C("start",t,n,e),s=C("stop",t,n,e),i=C("step",t,n,e);return[r.range(o,s,i,C("dtype",t,n,e))]}case"TruncatedNormal":{let o=C("shape",t,n,e),s=C("mean",t,n,e),i=C("stdDev",t,n,e),a=C("seed",t,n,e);return[r.truncatedNormal(o,s,i,C("dtype",t,n,e),a)]}case"Zeros":return[r.zeros(C("shape",t,n,e),C("dtype",t,n,e))];case"ZerosLike":return[r.zerosLike(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function lE(t,n,e){let r=C("boxes",t,n,e),o=C("scores",t,n,e),s=C("maxOutputSize",t,n,e),i=C("iouThreshold",t,n,e),a=C("scoreThreshold",t,n,e),l=C("softNmsSigma",t,n,e);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}var x$=(s,i,a,l,...u)=>z(void 0,[s,i,a,l,...u],function*(t,n,e,r,o=et){switch(t.op){case"NonMaxSuppressionV5":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h,softNmsSigma:g}=lE(t,n,e),m=yield o.image.nonMaxSuppressionWithScoreAsync(c,p,f,d,h,g);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=lE(t,n,e),g=C("padToMaxOutputSize",t,n,e),m=yield o.image.nonMaxSuppressionPaddedAsync(c,p,f,d,h,g);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=lE(t,n,e);return[yield o.image.nonMaxSuppressionAsync(c,p,f,d,h)]}case"Where":{let c=o.cast(C("condition",t,n,e),"bool"),p=[yield o.whereAsync(c)];return c.dispose(),p}case"ListDiff":return o.setdiff1dAsync(C("x",t,n,e),C("y",t,n,e));default:throw TypeError(`Node type ${t.op} is not implemented`)}});var b$=(t,n,e,r=et)=>{switch(t.op){case"LowerBound":{let o=C("sortedSequence",t,n,e),s=C("values",t,n,e);return[r.lowerBound(o,s)]}case"TopKV2":{let o=C("x",t,n,e),s=C("k",t,n,e),i=C("sorted",t,n,e),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=C("sortedSequence",t,n,e),s=C("values",t,n,e);return[r.upperBound(o,s)]}case"Unique":{let o=C("x",t,n,e),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=C("x",t,n,e),s=C("axis",t,n,e),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var v$=(t,n,e,r=et)=>{switch(t.op){case"Const":return n[t.name];case"PlaceholderWithDefault":let o=C("default",t,n,e);return[on(t.name,n,e)||o];case"Placeholder":return[on(t.name,n,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=C("x",t,n,e);return[ts(c)]}case"IdentityN":return C("x",t,n,e).map(c=>ts(c));case"Snapshot":let s=C("x",t,n,e);return[ts(s)];case"Shape":return[r.tensor1d(C("x",t,n,e).shape,"int32")];case"ShapeN":return C("x",t,n,e).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(C("x",t,n,e).size,"int32")];case"Rank":return[r.scalar(C("x",t,n,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=C("x",t,n,e),a=C("data",t,n,e),l=C("message",t,n,e),u=C("summarize",t,n,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var wv=class{get id(){return this.handle.id}constructor(n,e){this.keyDType=n,this.valueDType=e,this.handle=se(0),this.tensorMap=new Map,kt(this.handle)}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return se(this.size(),"int32")}import(n,e){return z(this,null,function*(){this.checkKeyAndValueTensor(n,e);let r=yield n.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),B(()=>{let o=pn(e),s=r.length,i=o.length;b.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let l=r[a],u=o[a];kt(u),this.tensorMap.set(l,u)}return this.handle})})}find(n,e){return z(this,null,function*(){this.checkKeyAndValueTensor(n,e);let r=yield n.data();return B(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,e);o.push(a)}return Bt(o)})})}findWithDefault(n,e){let r=this.tensorMap.get(n);return r??e}checkKeyAndValueTensor(n,e){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var w$=(t,n,e,r)=>z(void 0,null,function*(){switch(t.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(t.name);if(o!=null)return[o];{let s=C("keyDType",t,n,e),i=C("valueDType",t,n,e),a=new wv(s,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=C("tableHandle",t,n,e,r),s=C("keys",t,n,e),i=C("values",t,n,e);return[yield r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=C("tableHandle",t,n,e,r),s=C("keys",t,n,e),i=C("defaultValue",t,n,e);return[yield r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=C("tableHandle",t,n,e,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});var C$=(t,n,e,r=et)=>{switch(t.op){case"ResizeBilinear":{let o=C("images",t,n,e),s=C("size",t,n,e),i=C("alignCorners",t,n,e),a=C("halfPixelCenters",t,n,e);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=C("images",t,n,e),s=C("size",t,n,e),i=C("alignCorners",t,n,e),a=C("halfPixelCenters",t,n,e);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=C("image",t,n,e),s=C("boxes",t,n,e),i=C("boxInd",t,n,e),a=C("cropSize",t,n,e),l=C("method",t,n,e),u=C("extrapolationValue",t,n,e);return[r.image.cropAndResize(o,s,i,a,l,u)]}case"ImageProjectiveTransformV3":{let o=C("images",t,n,e),s=C("transforms",t,n,e),i=C("outputShape",t,n,e),a=C("fillValue",t,n,e),l=C("interpolation",t,n,e),u=C("fillMode",t,n,e);return[r.image.transform(o,s,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var I$=(t,n,e,r=et)=>{switch(t.op){case"Equal":return[r.equal(C("a",t,n,e),C("b",t,n,e))];case"NotEqual":return[r.notEqual(C("a",t,n,e),C("b",t,n,e))];case"Greater":return[r.greater(C("a",t,n,e),C("b",t,n,e))];case"GreaterEqual":return[r.greaterEqual(C("a",t,n,e),C("b",t,n,e))];case"Less":return[r.less(C("a",t,n,e),C("b",t,n,e))];case"LessEqual":return[r.lessEqual(C("a",t,n,e),C("b",t,n,e))];case"LogicalAnd":return[r.logicalAnd(C("a",t,n,e),C("b",t,n,e))];case"LogicalNot":return[r.logicalNot(C("a",t,n,e))];case"LogicalOr":return[r.logicalOr(C("a",t,n,e),C("b",t,n,e))];case"Select":case"SelectV2":return[r.where(C("condition",t,n,e),C("a",t,n,e),C("b",t,n,e))];case"BitwiseAnd":return[r.bitwiseAnd(C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var S$=(t,n,e,r=et)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(C("a",t,n,e),C("b",t,n,e),C("transposeA",t,n,e),C("transposeB",t,n,e))];case"Einsum":return[r.einsum(C("equation",t,n,e),...C("tensors",t,n,e))];case"Transpose":return[r.transpose(C("x",t,n,e),C("perm",t,n,e))];case"_FusedMatMul":let[o,s]=C("fusedOps",t,n,e),i=o==="biasadd",a=s==="prelu",l=C("numArgs",t,n,e),u=C("leakyreluAlpha",t,n,e);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,p]=C("args",t,n,e);return[r.fused.matMul({a:C("a",t,n,e),b:C("b",t,n,e),transposeA:C("transposeA",t,n,e),transposeB:C("transposeB",t,n,e),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(C("a",t,n,e),C("numLower",t,n,e),C("numUpper",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var T$=(t,n,e,r=et)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(C("x",t,n,e),C("axis",t,n,e),C("keepDims",t,n,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(C("x",t,n,e),C("mean",t,n,e),C("variance",t,n,e),C("offset",t,n,e),C("scale",t,n,e),C("epsilon",t,n,e))];case"FusedBatchNormV3":return[r.batchNorm(C("x",t,n,e),C("mean",t,n,e),C("variance",t,n,e),C("offset",t,n,e),C("scale",t,n,e),C("epsilon",t,n,e))];case"LRN":return[r.localResponseNormalization(C("x",t,n,e),C("radius",t,n,e),C("bias",t,n,e),C("alpha",t,n,e),C("beta",t,n,e))];case"Softmax":return[r.softmax(C("x",t,n,e))];case"LogSoftmax":return[r.logSoftmax(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var N$=(t,n,e,r=et)=>{switch(t.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(C("paramsNestedSplits",t,n,e),C("paramsDenseValues",t,n,e),C("indices",t,n,e),C("outputRaggedRank",t,n,e));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(C("starts",t,n,e),C("limits",t,n,e),C("splits",t,n,e));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(C("shape",t,n,e),C("values",t,n,e),C("defaultValue",t,n,e),C("rowPartitionTensors",t,n,e),C("rowPartitionTypes",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var E$=(t,n,e,r=et)=>{switch(t.op){case"Max":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.max(C("x",t,n,e),a,l)]}case"Mean":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.mean(C("x",t,n,e),a,l)]}case"Min":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.min(C("x",t,n,e),a,l)]}case"Sum":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.sum(C("x",t,n,e),a,l)]}case"All":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.all(C("x",t,n,e),a,l)]}case"Any":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.any(C("x",t,n,e),a,l)]}case"ArgMax":{let a=C("axis",t,n,e);return[r.argMax(C("x",t,n,e),a)]}case"ArgMin":{let a=C("axis",t,n,e);return[r.argMin(C("x",t,n,e),a)]}case"Prod":{let a=C("axis",t,n,e),l=C("keepDims",t,n,e);return[r.prod(C("x",t,n,e),a,l)]}case"Cumprod":{let a=C("axis",t,n,e),l=C("exclusive",t,n,e),u=C("reverse",t,n,e);return[r.cumprod(C("x",t,n,e),a,l,u)]}case"Cumsum":{let a=C("axis",t,n,e),l=C("exclusive",t,n,e),u=C("reverse",t,n,e);return[r.cumsum(C("x",t,n,e),a,l,u)]}case"Bincount":let o=C("x",t,n,e),s=C("weights",t,n,e),i=C("size",t,n,e);return[r.bincount(o,s,i)];case"DenseBincount":{let a=C("x",t,n,e),l=C("weights",t,n,e),u=C("size",t,n,e),c=C("binaryOutput",t,n,e);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var D$=(t,n,e,r=et)=>{switch(t.op){case"ConcatV2":case"Concat":{let o=C("n",t,n,e),s=C("axis",t,n,e),i=C("tensors",t,n,e);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=C("x",t,n,e),s=C("indices",t,n,e);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=C("axis",t,n,e),s=C("batchDims",t,n,e),i=C("x",t,n,e),a=C("indices",t,n,e);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=C("dims",t,n,e),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=C("x",t,n,e);return[r.reverse(i,s)]}case"ReverseV2":{let o=C("axis",t,n,e),s=C("x",t,n,e);return[r.reverse(s,o)]}case"Slice":{let o=C("begin",t,n,e),s=C("size",t,n,e);return[r.slice(C("x",t,n,e),o,s)]}case"StridedSlice":{let o=C("begin",t,n,e),s=C("end",t,n,e),i=C("strides",t,n,e),a=C("beginMask",t,n,e),l=C("endMask",t,n,e),u=C("ellipsisMask",t,n,e),c=C("newAxisMask",t,n,e),p=C("shrinkAxisMask",t,n,e),f=C("x",t,n,e);return[r.stridedSlice(f,o,s,i,a,l,u,c,p)]}case"Pack":return B(()=>{let o=C("axis",t,n,e),s=C("tensors",t,n,e),i=s[0].shape,a=r.squeeze(s[0]).shape,l=s.map(u=>{let c=b.arraysEqual(u.shape,i);if(!c&&!b.arraysEqual(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,o)]});case"Unpack":{let o=C("axis",t,n,e),s=C("tensor",t,n,e);return r.unstack(s,o)}case"Tile":{let o=C("reps",t,n,e);return[r.tile(C("x",t,n,e),o)]}case"Split":case"SplitV":{let o=C("axis",t,n,e),s=C("numOrSizeSplits",t,n,e),i=C("x",t,n,e);return r.split(i,s,o)}case"ScatterNd":{let o=C("indices",t,n,e),s=C("values",t,n,e),i=C("shape",t,n,e);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=C("x",t,n,e),s=C("indices",t,n,e);return[r.gatherND(o,s)]}case"SparseToDense":{let o=C("sparseIndices",t,n,e),s=C("outputShape",t,n,e),i=C("sparseValues",t,n,e),a=C("defaultValue",t,n,e);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=C("indices",t,n,e),s=C("values",t,n,e),i=C("tensor",t,n,e);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var k$=(t,n,e,r=et)=>{switch(t.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(C("indices",t,n,e),C("values",t,n,e),C("denseShape",t,n,e),C("defaultValue",t,n,e));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(C("inputIndices",t,n,e),C("inputShape",t,n,e),C("newShape",t,n,e));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(C("data",t,n,e),C("indices",t,n,e),C("segmentIds",t,n,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(C("data",t,n,e),C("indices",t,n,e),C("segmentIds",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var A$=(t,n,e,r=et)=>{switch(t.op){case"FFT":return[r.fft(C("x",t,n,e))];case"IFFT":return[r.ifft(C("x",t,n,e))];case"RFFT":return[r.rfft(C("x",t,n,e))];case"IRFFT":return[r.irfft(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var R$=(t,n,e,r=et)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(C("input",t,n,e),C("pattern",t,n,e),C("rewrite",t,n,e),C("replaceGlobal",t,n,e))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(C("data",t,n,e),C("dataSplits",t,n,e),C("separator",t,n,e),C("nGramWidths",t,n,e),C("leftPad",t,n,e),C("rightPad",t,n,e),C("padWidth",t,n,e),C("preserveShortSequences",t,n,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(C("input",t,n,e),C("delimiter",t,n,e),C("skipEmpty",t,n,e));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(C("input",t,n,e),C("numBuckets",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var _$=(t,n,e,r=et)=>{switch(t.op){case"Cast":return[r.cast(C("x",t,n,e),C("dtype",t,n,e))];case"ExpandDims":{let o=C("axis",t,n,e);return[r.expandDims(C("x",t,n,e),o)]}case"Squeeze":{let o=C("axis",t,n,e);return[r.squeeze(C("x",t,n,e),o)]}case"Reshape":return[r.reshape(C("x",t,n,e),C("shape",t,n,e))];case"EnsureShape":return[r.ensureShape(C("x",t,n,e),C("shape",t,n,e))];case"MirrorPad":return[r.mirrorPad(C("x",t,n,e),C("padding",t,n,e),C("mode",t,n,e))];case"PadV2":case"Pad":return[r.pad(C("x",t,n,e),C("padding",t,n,e),C("constantValue",t,n,e))];case"SpaceToBatchND":{let o=C("blockShape",t,n,e),s=C("paddings",t,n,e);return[r.spaceToBatchND(C("x",t,n,e),o,s)]}case"BatchToSpaceND":{let o=C("blockShape",t,n,e),s=C("crops",t,n,e);return[r.batchToSpaceND(C("x",t,n,e),o,s)]}case"DepthToSpace":{let o=C("blockSize",t,n,e),s=C("dataFormat",t,n,e).toUpperCase();return[r.depthToSpace(C("x",t,n,e),o,s)]}case"BroadcastTo":return[r.broadcastTo(C("x",t,n,e),C("shape",t,n,e))];case"BroadcastArgs":return[r.broadcastArgs(C("s0",t,n,e),C("s1",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function uE(t,n,e,r,o=B){let s=((i,a,l)=>{switch(i.category){case"arithmetic":return o(()=>a$(i,a,l));case"basic_math":return o(()=>l$(i,a,l));case"control":return h$(i,a,l);case"convolution":return o(()=>g$(i,a,l));case"creation":return o(()=>y$(i,a,l));case"dynamic":return x$(i,a,l);case"evaluation":return o(()=>b$(i,a,l));case"image":return o(()=>C$(i,a,l));case"graph":return o(()=>v$(i,a,l));case"logical":return o(()=>I$(i,a,l));case"matrices":return o(()=>S$(i,a,l));case"normalization":return o(()=>T$(i,a,l));case"ragged":return o(()=>N$(i,a,l));case"reduction":return o(()=>E$(i,a,l));case"slice_join":return o(()=>D$(i,a,l));case"sparse":return o(()=>k$(i,a,l));case"spectral":return o(()=>A$(i,a,l));case"string":return o(()=>R$(i,a,l));case"transformation":return o(()=>_$(i,a,l));case"hash_table":return w$(i,a,l,r);case"custom":let u=iv(i.op);if(u&&u.customExecutor)return u.customExecutor(new xv(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,n,e);return b.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var Hm=class{constructor(n={},e={},r={},o={},s){this.weightMap=n,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,e){return{id:n,frameName:e,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let n=[];for(let e=0;e<this.contexts.length-1;e++){let r=this.contexts.slice(0,this.contexts.length-e);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(n);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(n)}};function cE(t,n,e,r){let o=new Set,s=[],i=null,a=null,l=new Set,u=new Set(Object.keys(t).map(f=>ur(f)[0]));r=r||[];let c=new Set(r.map(f=>ur(f.name)[0])),p=[...n];for(;p.length>0;){let f=p.pop();if((Ql(f)||Qse(f)||Jse(f))&&i==null&&(i=f,a=i.children.map(d=>d.name).filter(d=>o.has(d))),o.add(f.name),e[f.name]==null&&!u.has(f.name)&&!c.has(f.name)){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),p.push(d))})}}return{inputs:t,outputs:n,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function O$(t,n){let{usedNodes:e,inputs:r}=n,o=Object.keys(r).map(m=>ur(m)[0]).map(m=>t.nodes[m]),s=t.initNodes||[],i=m=>e.has(typeof m=="string"?m:m.name);function a(m){return[...new Map(m.map(y=>[y.name,y])).values()]}let l=a([...o,...t.weights,...s]).filter(i),u=a([...l,...Object.values(t.nodes)]).filter(i),c=new Map(u.map(m=>[m.name,m])),p={};for(let m of u){p[m.name]=p[m.name]||0;for(let y of m.children)i(y)||(p[y.name]=Number.POSITIVE_INFINITY),p[y.name]=(p[y.name]||0)+1}let f=Object.entries(p).filter(([,m])=>m===0).map(([m])=>m),d=[...f];for(;f.length>0;){let m=f.pop(),y=c.get(m);for(let x of y.children.filter(i))--p[x.name]===0&&(d.push(x.name),f.push(x.name))}let h=d.map(m=>c.get(m)),g=qse(h,l);return Kse(g,l),g}function qse(t,n){let e=new Map(t.map(i=>[i.name,i])),r=n.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=e.get(i);for(let l of a.children)!e.has(l.name)||o.has(l.name)||(o.add(l.name),r.push(l.name))}return t.filter(i=>o.has(i.name))}var Ld=class extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}};function Kse(t,n){let e=new Map(t.map((a,l)=>[a.name,l])),r=new Set(n.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(t.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of t){for(let l of a.children.filter(i)){if(!e.has(l.name))throw new Ld(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new Ld(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!o(a))for(let l of a.inputs){if(!e.has(l.name))throw new Ld(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new Ld(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function F$(t){let n=new Map(t.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>Ql(a)?e:l),o=a=>{let l=r[n.get(a.name)];return l??-1},s=t.map((a,l)=>a.children.map(o).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let a=0;a<t.length;++a){let l=s[a];if(l===e)continue;let u=t[a],c=t[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}var Xse=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Yse=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Zse=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ql(t){return Xse.has(t.op)}function Qse(t){return Yse.has(t.op)}function Jse(t){return Zse.has(t.op)}var qm=class t{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){let e=Object.keys(n).map(r=>n[r].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{let e=n.signatureKey||n.name;return n.defaultOutput?`${e}:${n.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((n,e)=>(n[e]=this._functions[e].signature,n),{})}constructor(n,e){this.graph=n,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,n.functions!=null&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new t(n.functions[r],this)})}getCompilationKey(n,e){let r=n.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(n,e){let r=cE(n,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let u=e.map(p=>p.name),c=Object.keys(n);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${o}]`)}let a=O$(this.graph,r),l=F$(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(n){if(n==null)return null;let e=n.clone();return kt(e),e}cloneTensorList(n){return n?n.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(n){return Object.fromEntries(Object.entries(n).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(n,e){this.disposeIntermediateTensors(),n=this.mapInputs(n);let r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e);let o=r.map(f=>this.graph.nodes[ur(f)[0]]),s=e.map(f=>ur(f)[0]),i=new Set(s),a=s.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);let l=this.getCompilationKey(o,a),u=this.compiledMap.get(l);u==null&&(u=this.compile(n,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}let c={},p={};return B(()=>{let f=new Hm(this.weightMap,c,p,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(n).forEach(y=>{let[x,v]=ur(y,f),w=[];w[v]=n[y],d[x]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(w))});let h=this.getFrozenTensorIds(d),{orderedNodes:g,nodeLiveUntilMap:m}=u;for(let y of g){if(d[y.name])continue;let x=uE(y,d,f,this._resourceManager);if(b.isPromise(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,h,i,m.get(y.name))}return this.parent==null&&f.dispose(h),e.map(y=>on(y,d,f))})}getFrozenTensorIds(n){let e=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(n,e,r,o,s,i,a){if(!(Ql(e)||i.has(n))){for(let l of r[n])l!=null&&(a[l.id]=(a[l.id]||0)+e.children.length);for(let l of e.inputs){if(Ql(l))continue;let u=VN(l.name,r,o);if(u!=null)for(let c of u){if(!c||c.kept||s.has(c.id))continue;let p=a[c.id];p===1?(c.dispose(),delete a[c.id]):p!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(n,e,r,o,s,i){function a(l){return Ql(l)||s.has(l.name)}if(!(Ql(n)||i==null))for(let l of i){if(a(l))continue;let u=VN(l.name,e,r);for(let c of u)!c||c.kept||o.has(c.id)||c.dispose()}}executeAsync(n,e){return z(this,null,function*(){return this._executeAsync(n,e)})}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(n=>{for(let e of n)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(i,a){return z(this,arguments,function*(n,e,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(n=this.mapInputs(n),this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let l=new Hm(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let u=yield this.executeWithControlFlow(n,l,e,r),c=e.map(h=>on(h,u,l)),p=c.map(h=>h.id),f=Object.keys(n).map(h=>n[h].id),d=new Set([...p,...f,...this.weightIds]);return Object.values(u).forEach(h=>{h.forEach(g=>{g&&!g.isDisposed&&!d.has(g.id)&&g.dispose()})}),this.parent==null&&l.dispose(d),c})}executeFunctionAsync(n,e,r){return z(this,null,function*(){let o=n.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,r)})}executeWithControlFlow(n,e,r,o){return z(this,null,function*(){let s=Object.keys(n),i=s.map(w=>this.graph.nodes[ur(w)[0]]),a=r.map(w=>ur(w)[0]),l=new Set(a),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:p,dynamicNode:f,syncInputs:d}=cE(n,u,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),g=Object.assign({},this.weightMap);Object.keys(n).forEach(w=>{let[T,k]=ur(w),A=[];A[k]=n[w],g[T]=A});let m={},y=this.getFrozenTensorIds(g),x={};for(;h.length>0;){let w=this.processStack(i,h,e,g,x,y,l,m,c);yield Promise.all(w)}f==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let v=u.filter(w=>!Ql(w)&&!on(w.name,g,e)).map(w=>w.name);if(v.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${w}`)}return g})}processStack(n,e,r,o,s,i,a,l,u){let c=[];for(;e.length>0;){let p=e.pop();r.currentContext=p.contexts;let f="";if(p.node.op==="Enter"&&C("isConstant",p.node,o,r)&&([f]=es(p.node.name,r)),o[p.node.name]==null){let d=uE(p.node,o,r,this._resourceManager);f||([f]=es(p.node.name,r));let h=r.currentContext;b.isPromise(d)?c.push(d.then(g=>(o[f]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(g)),r.currentContext=h,this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,u),g))):(o[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,u))}else this.processChildNodes(p.node,e,r,o,s,u)}return c}processChildNodes(n,e,r,o,s,i){n.children.forEach(a=>{let[l]=es(a.name,r);s[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!on(u,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!on(u,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(e=>e.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(e=>{let r=n[e],[o]=ur(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);b.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){var e,r;let o={};for(let s in n){let i=(r=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=n[s]:o[s]=n[s]}return o}checkInputs(n){let e=Object.keys(n).filter(r=>{let[o]=ur(r);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(n){return n.map(e=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[e];return s!=null?s.name:e},{})}checkOutputs(n){n.forEach(e=>{let[r]=ur(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}};var Cv=class{constructor(n={},e={}){this.hashTableNameToHandle=n,this.hashTableMap=e}addHashTable(n,e){this.hashTableNameToHandle[n]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(let n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(let n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}};var eie="?tfjs-format=file",tie="model.json",Iv=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(n,e={},r=Jo){this.modelUrl=n,this.loadOptions=e,this.version="n/a",this.io=r,e==null&&(this.loadOptions={}),this.resourceManager=new Cv}findIOHandler(){let n=this.modelUrl;if(n.load!=null)this.handler=n;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(n,this.loadOptions);else{let e=this.io.getLoadHandlers(n,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(n,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[n]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=this.handler.load();return b.isPromise(n)?n.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(n)}loadSync(n){let e=this.io.decodeWeights(n.weightData,n.weightSpecs);return this.loadWithWeightMap(n,e)}loadStreaming(n){return z(this,null,function*(){if(n.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let e=yield Vx(n.getWeightStream(),n.weightSpecs);return this.loadWithWeightMap(n,e)})}loadWithWeightMap(n,e){this.artifacts=n;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new qm(jm.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,n.modelInitializer!=null&&n.modelInitializer.node!=null){let s=jm.Instance.transformGraph(n.modelInitializer);this.initializer=new qm(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=n.initializerSignature}return!0}save(n,e){return z(this,null,function*(){if(typeof n=="string"){let r=this.io.getSaveHandlers(n);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${n}'`);n=r[0]}if(n.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(this.artifacts)})}addStructuredOutputNames(n){if(this.structuredOutputKeys){let e=n instanceof Pe?[n]:n,r={};return e.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return n}predict(n,e){let r=this.execute(n,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(n,e){return z(this,null,function*(){let r=yield this.executeAsync(n,this.outputNodes);return this.addStructuredOutputNames(r)})}normalizeInputs(n){var e;if(!(n instanceof Pe)&&!Array.isArray(n)){let s=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(n[i]=this.resourceIdToCapturedInput[a.resourceId])}return n}n=Array.isArray(n)?n:[n];let r=Object.keys(this.resourceIdToCapturedInput).length;if(n.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${n.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,l,u;let c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?s[i]=this.resourceIdToCapturedInput[c]:s[i]=n[o++],s},{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){return z(this,null,function*(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))})}setResourceIdToCapturedInput(n){if(this.resourceIdToCapturedInput={},this.initializerSignature){let e=this.initializerSignature.outputs,r=Object.keys(e);for(let o=0;o<r.length;o++){let s=r[o],i=e[s];this.resourceIdToCapturedInput[i.resourceId]=n[o]}}}execute(n,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),n=this.normalizeInputs(n),e=this.normalizeOutputs(e);let r=this.executor.execute(n,e);return r.length>1?r:r[0]}executeAsync(n,e){return z(this,null,function*(){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(yield this.executeInitializerGraphAsync()),n=this.normalizeInputs(n),e=this.normalizeOutputs(e);let r=yield this.executor.executeAsync(n,e);return r.length>1?r:r[0]})}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((e,r)=>(e[r]=[n[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ne(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};function Sv(r){return z(this,arguments,function*(t,n={},e=Jo){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");n==null&&(n={}),n.fromTFHub&&typeof t=="string"&&(t=nie(t));let o=new Iv(t,n,e);return yield o.load(),o})}function nie(t){return t.endsWith("/")||(t=t+"/"),`${t}${tie}${eie}`}function Jl(t,n,e,r){return new(e||(e=Promise))(function(o,s){function i(u){try{l(r.next(u))}catch(c){s(c)}}function a(u){try{l(r.throw(u))}catch(c){s(c)}}function l(u){var c;u.done?o(u.value):(c=u.value,c instanceof e?c:new e(function(p){p(c)})).then(i,a)}l((r=r.apply(t,n||[])).next())})}function eu(t,n){var e,r,o,s,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(u){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;s&&(s=0,c[0]&&(i=0)),i;)try{if(e=1,r&&(o=2&c[0]?r.return:c[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,c[1])).done)return o;switch(r=0,o&&(c=[2&c[0],o.value]),c[0]){case 0:case 1:o=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(o=i.trys,!((o=o.length>0&&o[o.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!o||c[1]>o[0]&&c[1]<o[3])){i.label=c[1];break}if(c[0]===6&&i.label<o[1]){i.label=o[1],o=c;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(c);break}o[2]&&i.ops.pop(),i.trys.pop();continue}c=n.call(t,i)}catch(p){c=[6,p],r=0}finally{e=o=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}function Bd(t,n,e){if(e||arguments.length===2)for(var r,o=0,s=n.length;o<s;o++)!r&&o in n||(r||(r=Array.prototype.slice.call(n,0,o)),r[o]=n[o]);return t.concat(r||Array.prototype.slice.call(n))}function fE(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function Tv(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function M$(t,n){n===void 0&&(n=1.5);var e=Tv(t),r=fE(t),o=[n*r[0]/2,n*r[1]/2];return{startPoint:[e[0]-o[0],e[1]-o[1]],endPoint:[e[0]+o[0],e[1]+o[1]],palmLandmarks:t.palmLandmarks}}function $$(t){var n=Tv(t),e=fE(t),r=Math.max.apply(Math,e)/2;return{startPoint:[n[0]-r,n[1]-r],endPoint:[n[0]+r,n[1]+r],palmLandmarks:t.palmLandmarks}}function P$(t,n){var e=[t.endPoint[0]-t.startPoint[0],t.endPoint[1]-t.startPoint[1]],r=[e[0]*n[0],e[1]*n[1]];return{startPoint:[t.startPoint[0]+r[0],t.startPoint[1]+r[1]],endPoint:[t.endPoint[0]+r[0],t.endPoint[1]+r[1]],palmLandmarks:t.palmLandmarks}}var oie=function(){function t(n,e,r,o,s,i){this.model=n,this.width=e,this.height=r,this.iouThreshold=s,this.scoreThreshold=i,this.anchors=o.map(function(a){return[a.x_center,a.y_center]}),this.anchorsTensor=Qo(this.anchors),this.inputSizeTensor=Tt([e,r]),this.doubleInputSizeTensor=Tt([2*e,2*r])}return t.prototype.normalizeBoxes=function(n){var e=this;return B(function(){var r=ve(n,[0,0],[-1,2]),o=ve(n,[0,2],[-1,2]),s=W(ne(r,e.inputSizeTensor),e.anchorsTensor),i=ne(o,e.doubleInputSizeTensor),a=R(te(s,i),e.inputSizeTensor),l=R(W(s,i),e.inputSizeTensor);return ad([a,l],1)})},t.prototype.normalizeLandmarks=function(n,e){var r=this;return B(function(){var o=W(ne(_(n,[-1,7,2]),r.inputSizeTensor),r.anchors[e]);return R(o,r.inputSizeTensor)})},t.prototype.getBoundingBoxes=function(n){return Jl(this,void 0,void 0,function(){var e,r,o,s,i,a,l,u,c,p,f,d,h,g,m,y=this;return eu(this,function(x){switch(x.label){case 0:return e=B(function(){return R(te(n,.5),2)}),Am()==="webgl"?(o=$().get("WEBGL_PACK_DEPTHWISECONV"),$().set("WEBGL_PACK_DEPTHWISECONV",!0),r=this.model.predict(e),$().set("WEBGL_PACK_DEPTHWISECONV",o)):r=this.model.predict(e),s=Qn(r),i=B(function(){return Qn(_n(ve(s,[0,0],[-1,1])))}),a=ve(s,[0,1],[-1,4]),l=this.normalizeBoxes(a),u=console.warn,console.warn=function(){},c=In.nonMaxSuppression(l,i,1,this.iouThreshold,this.scoreThreshold),console.warn=u,[4,c.array()];case 1:return p=x.sent(),f=[e,r,c,s,l,a,i],p.length===0?(f.forEach(function(v){return v.dispose()}),[2,null]):(d=p[0],h=ve(l,[d,0],[1,-1]),g=ve(s,[d,5],[1,14]),m=B(function(){return _(y.normalizeLandmarks(g,d),[-1,2])}),f.push(g),f.forEach(function(v){return v.dispose()}),[2,{boxes:h,palmLandmarks:m}])}})})},t.prototype.estimateHandBounds=function(n){return Jl(this,void 0,void 0,function(){var e,r,o,s,i,a,l,u,c=this;return eu(this,function(p){switch(p.label){case 0:return e=n.shape[1],r=n.shape[2],o=B(function(){return ne(In.resizeBilinear(n,[c.width,c.height]),255)}),[4,this.getBoundingBoxes(o)];case 1:return(s=p.sent())===null?(o.dispose(),[2,null]):(i=s.boxes.arraySync(),a=i[0].slice(0,2),l=i[0].slice(2,4),u=s.palmLandmarks.arraySync(),o.dispose(),s.boxes.dispose(),s.palmLandmarks.dispose(),[2,(f={startPoint:a,endPoint:l,palmLandmarks:u},d=[r/this.width,e/this.height],{startPoint:[f.startPoint[0]*d[0],f.startPoint[1]*d[1]],endPoint:[f.endPoint[0]*d[0],f.endPoint[1]*d[1]],palmLandmarks:f.palmLandmarks.map(function(h){return[h[0]*d[0],h[1]*d[1]]})})])}var f,d})})},t}(),pE={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};function sie(t,n){var e,r=Math.PI/2-Math.atan2(-(n[1]-t[1]),n[0]-t[0]);return(e=r)-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}var L$=function(t,n){return[[1,0,t],[0,1,n],[0,0,1]]};function Ec(t,n){for(var e=0,r=0;r<t.length;r++)e+=t[r]*n[r];return e}function iie(t,n){for(var e=[],r=0;r<t.length;r++)e.push(t[r][n]);return e}function B$(t,n){for(var e=[],r=t.length,o=0;o<r;o++){e.push([]);for(var s=0;s<r;s++)e[o].push(Ec(t[o],iie(n,s)))}return e}function z$(t,n){var e=Math.cos(t),r=Math.sin(t),o=[[e,-r,0],[r,e,0],[0,0,1]],s=B$(L$(n[0],n[1]),o);return B$(s,L$(-n[0],-n[1]))}function V$(t,n){return[Ec(t,n[0]),Ec(t,n[1])]}var aie=[0,-.4],lie=[0,-.1],U$=[0,5,9,13,17,1,2],uie=function(){function t(n,e,r,o,s,i){this.boundingBoxDetector=n,this.meshDetector=e,this.meshWidth=r,this.meshHeight=o,this.maxContinuousChecks=s,this.detectionConfidence=i,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return t.prototype.getBoxForPalmLandmarks=function(n,e){var r=n.map(function(o){return V$(Bd(Bd([],o,!0),[1],!1),e)});return M$($$(P$(this.calculateLandmarksBoundingBox(r),aie)),3)},t.prototype.getBoxForHandLandmarks=function(n){for(var e=M$($$(P$(this.calculateLandmarksBoundingBox(n),lie)),1.65),r=[],o=0;o<U$.length;o++)r.push(n[U$[o]].slice(0,2));return e.palmLandmarks=r,e},t.prototype.transformRawCoords=function(n,e,r,o){var s,i,a,l,u=this,c=fE(e),p=[c[0]/this.meshWidth,c[1]/this.meshHeight],f=n.map(function(x){return[p[0]*(x[0]-u.meshWidth/2),p[1]*(x[1]-u.meshHeight/2),x[2]]}),d=z$(r,[0,0]),h=f.map(function(x){return Bd(Bd([],V$(x,d),!0),[x[2]],!1)}),g=(i=[[(s=o)[0][0],s[1][0]],[s[0][1],s[1][1]]],a=[s[0][2],s[1][2]],l=[-Ec(i[0],a),-Ec(i[1],a)],[i[0].concat(l[0]),i[1].concat(l[1]),[0,0,1]]),m=Bd(Bd([],Tv(e),!0),[1],!1),y=[Ec(m,g[0]),Ec(m,g[1])];return h.map(function(x){return[x[0]+y[0],x[1]+y[1],x[2]]})},t.prototype.estimateHand=function(n){return Jl(this,void 0,void 0,function(){var e,r,o,s,i,a,l,u,c,p,f,d,h,g,m,y,x,v,w,T;return eu(this,function(k){switch(k.label){case 0:return(e=this.shouldUpdateRegionsOfInterest())!==!0?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(n)];case 1:return(r=k.sent())===null?(n.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(r,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,k.label=3;case 3:return o=this.regionsOfInterest[0],s=sie(o.palmLandmarks[0],o.palmLandmarks[2]),i=Tv(o),a=[i[0]/n.shape[2],i[1]/n.shape[1]],l=In.rotateWithOffset(n,s,0,a),u=z$(-s,i),c=e===!0?this.getBoxForPalmLandmarks(o.palmLandmarks,u):o,p=function(A,O,M){var L=O.shape[1],V=O.shape[2],U=[[A.startPoint[1]/L,A.startPoint[0]/V,A.endPoint[1]/L,A.endPoint[0]/V]];return In.cropAndResize(O,U,[0],M)}(c,l,[this.meshWidth,this.meshHeight]),f=ne(p,255),p.dispose(),l.dispose(),Am()==="webgl"?(h=$().get("WEBGL_PACK_DEPTHWISECONV"),$().set("WEBGL_PACK_DEPTHWISECONV",!0),d=this.meshDetector.predict(f),$().set("WEBGL_PACK_DEPTHWISECONV",h)):d=this.meshDetector.predict(f),g=d[0],m=d[1],f.dispose(),y=g.dataSync()[0],g.dispose(),y<this.detectionConfidence?(m.dispose(),this.regionsOfInterest=[],[2,null]):(x=_(m,[-1,3]),v=x.arraySync(),m.dispose(),x.dispose(),w=this.transformRawCoords(v,c,s,u),T=this.getBoxForHandLandmarks(w),this.updateRegionsOfInterest(T,!1),[2,{landmarks:w,handInViewConfidence:y,boundingBox:{topLeft:T.startPoint,bottomRight:T.endPoint}}])}})})},t.prototype.calculateLandmarksBoundingBox=function(n){var e=n.map(function(o){return o[0]}),r=n.map(function(o){return o[1]});return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,r)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,r)]}},t.prototype.updateRegionsOfInterest=function(n,e){if(e)this.regionsOfInterest=[n];else{var r=this.regionsOfInterest[0],o=0;if(r!=null&&r.startPoint!=null){var s=n.startPoint,i=s[0],a=s[1],l=n.endPoint,u=l[0],c=l[1],p=r.startPoint,f=p[0],d=p[1],h=r.endPoint,g=h[0],m=h[1],y=Math.max(i,f),x=Math.max(a,d),v=(Math.min(u,g)-y)*(Math.min(c,m)-x);o=v/((u-i)*(c-a)+(g-f)*(m-a)-v)}this.regionsOfInterest[0]=o>.8?r:n}},t.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},t}();function cie(){return Jl(this,void 0,void 0,function(){return eu(this,function(t){return[2,Sv("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]})})}function pie(){return Jl(this,void 0,void 0,function(){return eu(this,function(t){return[2,Sv("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]})})}function fie(){return Jl(this,void 0,void 0,function(){return eu(this,function(t){return[2,b.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then(function(n){return n.json()})]})})}function G$(t){var n=t===void 0?{}:t,e=n.maxContinuousChecks,r=e===void 0?1/0:e,o=n.detectionConfidence,s=o===void 0?.8:o,i=n.iouThreshold,a=i===void 0?.3:i,l=n.scoreThreshold,u=l===void 0?.5:l;return Jl(this,void 0,void 0,function(){var c,p,f,d,h,g;return eu(this,function(m){switch(m.label){case 0:return[4,Promise.all([fie(),cie(),pie()])];case 1:return c=m.sent(),p=c[0],f=c[1],d=c[2],h=new oie(f,256,256,p,a,u),g=new uie(h,d,256,256,r,s),[2,new die(g)]}})})}var die=function(){function t(n){this.pipeline=n}return t.getAnnotations=function(){return pE},t.prototype.estimateHands=function(n,e){return e===void 0&&(e=!1),Jl(this,void 0,void 0,function(){var r,o,s,i,a,l,u,c,p;return eu(this,function(f){switch(f.label){case 0:return r=function(d){return d instanceof Pe?[d.shape[0],d.shape[1]]:[d.height,d.width]}(n),o=r[1],s=B(function(){return n instanceof Pe||(n=Gm.fromPixels(n)),Pt(K(n,"float32"))}),[4,this.pipeline.estimateHand(s)];case 1:if(i=f.sent(),s.dispose(),i===null)return[2,[]];for(a=i,e===!0&&(a=function(d,h){var g=d.handInViewConfidence,m=d.landmarks,y=d.boundingBox;return{handInViewConfidence:g,landmarks:m.map(function(x){return[h-1-x[0],x[1],x[2]]}),boundingBox:{topLeft:[h-1-y.topLeft[0],y.topLeft[1]],bottomRight:[h-1-y.bottomRight[0],y.bottomRight[1]]}}}(i,o)),l={},u=0,c=Object.keys(pE);u<c.length;u++)p=c[u],l[p]=pE[p].map(function(d){return a.landmarks[d]});return[2,[{handInViewConfidence:a.handInViewConfidence,boundingBox:a.boundingBox,landmarks:a.landmarks,annotations:l}]]}})})},t}();var Dc={},Nv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function W$(t,n){Dc[t]=n}function zr(t,n){if(!(t in Dc)||n!=null){let r=gie(t,n);if(r!==null)Dc[t]=r;else return console.log("Could not get context for WebGL version",t),null}let e=Dc[t];return e==null||e.isContextLost()?(delete Dc[t],zr(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Dc[t])}function mie(t){if(!$().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function gie(t,n){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=n??mie(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Dc[t]},!1),$().getBool("SOFTWARE_WEBGL_ENABLED")&&(Nv.failIfMajorPerformanceCaveat=!1),t===1?e.getContext("webgl",Nv)||e.getContext("experimental-webgl",Nv):e.getContext("webgl2",Nv)}var kc=function(t){return t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",t}(kc||{}),Jn=function(t){return t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",t}(Jn||{}),jn=function(t){return t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",t}(jn||{});function Ac(t,n){return[n,t]}function j$(t,n){return t*n}function Km(t){let n=b.sizeFromShape(t),e=Math.ceil(n/4);return b.sizeToSquarishShape(e)}function Bs(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function H$(t,n){let[e,r]=Bs(t,n);return e*r*4}function Xm(t,n){let e=t,r,o,s,i,a,l,u,c,p,f;return $().getNumber("WEBGL_VERSION")===2?(r=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,p=e.HALF_FLOAT,f=e.FLOAT,l=e.RGBA8):(r=t.RGBA,o=t.RGBA,s=t.RGBA,i=e.RGBA,a=t.RGBA,u=4,c=4,p=n!=null?n.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:f}}function de(t,n){let e=n();return $().getBool("DEBUG")&&yie(t),e}function yie(t){let n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+vie(t,n))}var xie=596e-10,bie=65504;function q$(t){return!!($().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||xie<Math.abs(t)&&Math.abs(t)<bie)}function vie(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function Ym(t,n){return la(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}function K$(t,n){let e=la(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(de(t,()=>t.shaderSource(e,n)),de(t,()=>t.compileShader(e)),t.getShaderParameter(e,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function X$(t,n){let e=la(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(de(t,()=>t.shaderSource(e,n)),de(t,()=>t.compileShader(e)),$().get("ENGINE_COMPILE_ONLY"))return e;if(t.getShaderParameter(e,t.COMPILE_STATUS)===!1)throw yE(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var wie=/ERROR: [0-9]+:([0-9]+):/g;function yE(t,n){let e=wie.exec(n);if(e==null){console.log(`Couldn't parse line number in error: ${n}`),console.log(t);return}let r=+e[1],o=t.split(`
`),s=o.length.toString().length+2,i=o.map((p,f)=>b.rightPad((f+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(n.split(`
`)[0]),console.log(`%c ${b.rightPad(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function Y$(t){return la(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Z$(t,n){if(de(t,()=>t.linkProgram(n)),!$().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(n,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Dv(t,n){if(de(t,()=>t.validateProgram(n)),t.getProgramParameter(n,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function Q$(t,n){let e=la(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return de(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),de(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}function J$(t,n){let e=la(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return de(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),de(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}function eP(t){return la(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function tP(t,n){let e=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0){let r=`[${t}x${n}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>e||n>e){let r=`[${t}x${n}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function nP(t){return la(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function xE(t,n,e,r,o,s,i){let a=t.getAttribLocation(n,e);return a===-1?!1:(de(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),de(t,()=>t.vertexAttribPointer(a,o,t.FLOAT,!1,s,i)),de(t,()=>t.enableVertexAttribArray(a)),!0)}function Cie(t,n,e){Sie(t,e),de(t,()=>t.activeTexture(t.TEXTURE0+e)),de(t,()=>t.bindTexture(t.TEXTURE_2D,n))}function rP(t,n,e){return la(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}function oP(t,n,e){return t.getUniformLocation(n,e)}function sP(t,n,e,r){de(t,()=>Cie(t,n,r)),de(t,()=>t.uniform1i(e,r))}function kv(t,n,e){de(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),de(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function bE(t,n){de(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),de(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Zm(t){let n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Iie(t,n))}function Iie(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function la(t,n,e){let r=de(t,()=>n());if(r==null)throw new Error(e);return r}function Sie(t,n){let e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function tu(t,n=2){return b.sizeFromShape(t.slice(0,t.length-n))}function nu(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Qm(t){let n=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(n=[tu(t),...nu(t)]),n}function iP(t,n=!1){let e=$().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=$().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&$().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e=e*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?b.nearestLargerEven(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=b.squeezeShape(t).newShape);let o=b.sizeFromShape(t),s=null;t.length<=1&&o<=e?s=[1,o]:t.length===2&&t[0]<=e&&t[1]<=e?s=t:t.length===3&&t[0]*t[1]<=e&&t[2]<=e?s=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=e&&t[1]*t[2]<=e?s=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=e&&t[3]<=e?s=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(s=[t[0],t[1]*t[2]*t[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(n?2:1)&&Math.min(...s)>0;if(s==null||i)if(n){let a=tu(t),l=2,u=2;t.length&&([l,u]=nu(t)),o=a*(l/2)*(u/2),s=b.sizeToSquarishShape(o).map(c=>c*2)}else s=b.sizeToSquarishShape(o);return s}function Ev(t){return t%2===0}function Rc(t,n){if(t=t.slice(-2),n=n.slice(-2),b.arraysEqual(t,n)||!t.length||!n.length||t[0]===0||t[1]===0||n[0]===0||n[1]===0)return!0;if(t.length!==n.length){let e=t[t.length-1],r=n[n.length-1];if(e===r||Ev(e)&&Ev(r)&&(t[0]===1||n[0]===1))return!0}return t[1]===n[1]&&Ev(t[0])&&Ev(n[0])}var hE,mE;function aP(t){if(hE==null){let n=zr(t);hE=n.getParameter(n.MAX_TEXTURE_SIZE)}return hE}function lP(t){if(mE==null){let n=zr(t);mE=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,mE)}function uP(t){if(t===0)return 0;let n,e=zr(t);return oo(e,"EXT_disjoint_timer_query_webgl2")&&t===2?n=2:oo(e,"EXT_disjoint_timer_query")?n=1:n=0,n}function oo(t,n){return t.getExtension(n)!=null}function vE(t){try{if(zr(t)!=null)return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function cP(t){if(t===0)return!1;let n=zr(t);if(t===1){if(!oo(n,"OES_texture_float"))return!1}else if(!oo(n,"EXT_color_buffer_float"))return!1;return gE(n)}function pP(t){if(t===0)return!1;let n=zr(t);if(t===1){if(!oo(n,"OES_texture_float")||!oo(n,"WEBGL_color_buffer_float"))return!1}else{if(oo(n,"EXT_color_buffer_float"))return gE(n);let r="EXT_color_buffer_half_float";if(oo(n,r)){let o=n.getExtension(r);return Tie(n,o)}return!1}return gE(n)}function gE(t){let n=Xm(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);let s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);let i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(s),i}function Tie(t,n){let e=Xm(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);let a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function fP(t){return t!==2?!1:zr(t).fenceSync!=null}function zs(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}var be=$();be.registerFlag("HAS_WEBGL",()=>be.getNumber("WEBGL_VERSION")>0);be.registerFlag("WEBGL_VERSION",()=>vE(2)?2:vE(1)?1:0);be.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);be.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>be.get("WEBGL_VERSION")===2);be.registerFlag("WEBGL_CPU_FORWARD",()=>!0);be.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);be.registerFlag("WEBGL_PACK",()=>be.getBool("HAS_WEBGL"));be.registerFlag("WEBGL_PACK_NORMALIZATION",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_CLIP",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_REDUCE",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_LAZILY_UNPACK",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_CONV_IM2COL",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>aP(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>lP(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let t=be.getNumber("WEBGL_VERSION");return t===0?0:uP(t)});be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>be.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!_l.isMobile());be.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>cP(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>be.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:be.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));be.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>pP(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_FENCE_API_ENABLED",()=>fP(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>be.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);be.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});be.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>_l.isMobile()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});be.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);be.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);be.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);be.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);be.registerFlag("WEBGL_EXP_CONV",()=>!1);be.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>be.getBool("IS_TEST"));be.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);be.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);be.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);be.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function zt(){let t,n,e,r,o,s,i,a,l,u;return $().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",n="in",e="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=$().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",n="attribute",e="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function ns(t,n,e="index"){let r=b.computeStrides(n);return r.map((o,s)=>{let i=`int ${t[s]} = ${e} / ${o}`,a=s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${o}`:`index -= ${t[s]} * ${o}`;return`${i}; ${a};`}).join("")}function _c(t,n,e="index"){let r=b.computeStrides(n);return r.map((o,s)=>{let i=`int ${t[s]} = ${e} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Nie(t,n){let e=t.length,r=t.map(s=>`${n}[${s}]`),o=new Array(e-1);o[e-2]=r[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function dP(t,n,e="index"){let r=t.map((s,i)=>i),o=Nie(r,n);return o.map((s,i)=>{let a=`int ${t[i]} = ${e} / ${o[i]}`,l=i===o.length-1?`int ${t[i+1]} = ${e} - ${t[i]} * ${o[i]}`:`index -= ${t[i]} * ${o[i]}`;return`${a}; ${l};`}).join("")}function zd(t){let n=b.computeStrides(t).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;
  }
`}function Vd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Rv=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:hP}=N;function mP(t,n,e){let r=[];if(t.forEach(d=>{let h=b.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),e.enableShapeUniforms){let{uniformShape:g}=_v(e.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=r.join(`
`),s=t.map(d=>Eie(d,n,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=n.texShape,a=zt(),l=Aie(a),u,c,p=Oie(a);return n.isPacked?(u=Die(n.logicalShape,i,e.enableShapeUniforms),c=_ie(a)):(u=kie(n.logicalShape,i,e.enableShapeUniforms),c=Rie(a)),e.packedInputs&&(p+=Pie),[p,l,c,o,u,s,e.userCode].join(`
`)}function Gd(t,n=!1){let e=t.shapeInfo.logicalShape;switch(e.length){case 0:return Xie(t,n);case 1:return Zie(t,n);case 2:return Jie(t,n);case 3:return tae(t,n);case 4:return rae(t,n);case 5:return oae(t);case 6:return sae(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function gP(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return Kie(t);case 1:return Yie(t,n);case 2:return Qie(t,n);case 3:return eae(t,n);default:return nae(t,n)}}function Eie(t,n,e=!1,r){let o="";e?o+=gP(t,r):o+=Gd(t,r);let s=t.shapeInfo.logicalShape,i=n.logicalShape;return s.length<=i.length&&(e?o+=iae(t,n):o+=aae(t,n)),o}function Die(t,n,e){switch(t.length){case 0:return yP();case 1:return Lie(t,n,e);case 2:return Hie(t,n,e);case 3:return zie(t,n,e);default:return Uie(t,n,e)}}function kie(t,n,e){switch(t.length){case 0:return yP();case 1:return Bie(t,n,e);case 2:return qie(t,n,e);case 3:return Vie(t,n,e);case 4:return Gie(t,n,e);case 5:return Wie(t,n);case 6:return jie(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Aie(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Rie(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function _ie(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function Oie(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Fie}
    ${Mie}
    ${$ie}
  `}var Fie=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Mie=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$ie=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Pie=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function yP(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Lie(t,n,e){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return r[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Bie(t,n,e){return n[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return resTexRC.x * ${n[1]} + resTexRC.y;
    }
  `}function zie(t,n,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(t[2]/2),s=o*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Vie(t,n,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${_c(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;let r=ns(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Uie(t,n,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(t[t.length-1]/2),s=o*Math.ceil(t[t.length-2]/2),i=s,a="",l="b, r, c";for(let u=2;u<t.length-1;u++)i*=t[t.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${t.length}(${l});
    }
  `}function Gie(t,n,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${_c(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;let r=ns(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Wie(t,n){let e=ns(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},
                             ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function jie(t,n){let e=ns(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Hie(t,n,e){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(b.arraysEqual(t,n))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(t[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function qie(t,n,e){return b.arraysEqual(t,n)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `:t[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Oc(t){return`offset${t}`}function Kie(t){let n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1),r=zt();return`
    vec4 ${e}() {
      return ${r.texture2D}(${n}, halfCR);
    }
  `}function Xie(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;let[o,s]=t.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Oc(e);if(n)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function Yie(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t.shapeInfo.texShape,s=zt();if(n)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function Zie(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Wd(t)}
      }
    `;let o=t.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Oc(e);return i===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:n?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function Qie(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,i=s[0],a=s[1],l=zt();if(s!=null&&b.arraysEqual(e,s))return n?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(n)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Jie(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(s!=null&&b.arraysEqual(e,s)){if(n)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let f=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=b.squeezeShape(e),l=i;if(l.length<e.length){let f=jd(t,l),d=["row","col"];return`
      ${Gd(f,n)}
      float ${o}(int row, int col) {
        return ${o}(${Hd(d,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Wd(t)}
      }
    `;let u=s[0],c=s[1],p=Oc(r);return c===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:n?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function eae(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let f=e.slice(1),d=[1,2],h=jd(t,f),g=["b","row","col"];return`
        ${gP(h,n)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Hd(g,d)});
        }
      `}let a=zt();if(n)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function tae(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=b.squeezeShape(e),u=a;if(u.length<e.length){let g=jd(t,u),m=["row","col","depth"];return`
        ${Gd(g,n)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Hd(m,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Wd(t)}
      }
    `;let c=t.shapeInfo.texShape,p=c[0],f=c[1],d=t.shapeInfo.flatOffset;if(f===s&&d==null)return n?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===i&&d==null)return n?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let h=Oc(r);return n?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function nae(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=zt();if(n)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=t.shapeInfo.logicalShape,i=s.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],p=Math.ceil(s[i-1]/2),f=p*Math.ceil(s[i-2]/2),d="int b, int row, int col",h=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let g=2;g<i-1;g++)d=`int b${g}, `+d,f*=s[i-g-1],h=`b${g} * ${f} + `+h;return`
    vec4 ${r}(${d}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${o.texture2D}(${e}, uv);
    }
  `}function rae(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:l,keptDims:u}=b.squeezeShape(e);if(l.length<e.length){let x=jd(t,l),v=["row","col","depth","depth2"];return`
      ${Gd(x,n)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Hd(v,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Wd(t)}
      }
    `;let c=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1],h=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&c==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${h}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===s&&c==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Oc(r);return n?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function oae(t){let n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=n[4],s=n[3]*o,i=n[2]*s,a=n[1]*i,{newShape:l,keptDims:u}=b.squeezeShape(n);if(l.length<n.length){let g=jd(t,l),m=["row","col","depth","depth2","depth3"];return`
      ${Gd(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Hd(m,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${Wd(t)}
      }
    `;let c=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1];if(d===a&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]},
               ${n[2]*n[3]}, ${n[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Oc(e);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function sae(t){let n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(n);if(o.length<n.length){let m=jd(t,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Gd(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Hd(y,s)});
      }
    `}let i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Wd(t)}
      }
    `;let p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],h=f[1];if(h===c&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]*n[4]},
               ${n[2]*n[3]*n[4]},
               ${n[3]*n[4]},
               ${n[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let g=Oc(e);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Wd(t){let n=t.name,e=b.sizeFromShape(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${n}[i];
      }
    }
  `}function iae(t,n){let e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=hP(t.shapeInfo.logicalShape,n.logicalShape),l=ke(i),u=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(x=>`coords.${p[x+u]} = 0;`).join(`
`);let f="";i<2&&s>0?f="coords":f=t.shapeInfo.logicalShape.map((x,v)=>`coords.${p[v+u]}`).join(", ");let d="return outputValue;",g=b.sizeFromShape(t.shapeInfo.logicalShape)===1,y=b.sizeFromShape(n.logicalShape)===1;if(s===1&&!g&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){let x=s-2,v=s-1;a.indexOf(x)>-1&&a.indexOf(v)>-1?d="return vec4(outputValue.x);":a.indexOf(x)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function aae(t,n){let e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=n.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&b.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let u=ke(l),c=hP(t.shapeInfo.logicalShape,n.logicalShape),p=l-a,f,d=["x","y","z","w","u","v"];a===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(g=>`coords.${d[g+p]} = 0;`).join(`
`);let h="";return l<2&&a>0?h="coords":h=t.shapeInfo.logicalShape.map((g,m)=>`coords.${d[m+p]}`).join(", "),`
    float ${o}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${r}(${h});
    }
  `}function ke(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function _v(t,n,e){let{newShape:r,keptDims:o}=b.squeezeShape(n),s=n.length,i=t&&s===3&&n[0]===1,a=i?n.slice(1):r,l=!t&&s>1&&!b.arraysEqual(n,e)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?a:n,keptDims:o}}function jd(t,n){let e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Hd(t,n){return n.map(e=>t[e]).join(", ")}function bP(t,n,e,r){let o=e.map((c,p)=>{let f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:f}}),s=o.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=mP(o,i,n),l=X$(t.gl,a),u=t.createProgram(l);return $().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(u),Object.assign({program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},wE(t,n,u)))}function wE(t,n,e){let r=[],o=[],s,i,a,l=null,u=null;u=t.getUniformLocation(e,"NAN",!1),$().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(e,"INFINITY",!1));let c=!1;for(let p of n.variableNames){let f={name:p,uniform:t.getUniformLocation(e,p,c),offset:t.getUniformLocation(e,`offset${p}`,c)};n.enableShapeUniforms&&(f.shape=t.getUniformLocation(e,`${p}Shape`,c),f.texShape=t.getUniformLocation(e,`${p}TexShape`,c)),r.push(f)}if(n.enableShapeUniforms&&(s=t.getUniformLocation(e,"outShape",c),a=t.getUniformLocation(e,"outShapeStrides",c),i=t.getUniformLocation(e,"outTexShape",c)),n.customUniforms)for(let p of n.customUniforms)o.push(t.getUniformLocation(e,p.name,c));return{variablesLocations:r,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function xP(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{let o=e.logicalShape,s=n[r],i=s.shape;if(!b.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function vP(t,n,e,r,o){n.program.enableShapeUniforms||(xP(n.inShapeInfos,e),xP([n.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):t.setOutputMatrixTexture(s.texture,i[0],i[1]),t.setProgram(n.webGLProgram),t.bindVertexArray(n.webGLProgram.vao),$().getNumber("WEBGL_VERSION")===1&&n.infLoc!==null&&t.gl.uniform1f(n.infLoc,1/0),n.nanLoc!==null&&t.gl.uniform1f(n.nanLoc,NaN);for(let l=0;l<e.length;++l){let u=e[l],{uniform:c,offset:p,shape:f,texShape:d}=n.variablesLocations[l];if(f){let{uniformShape:h}=_v(n.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:t.gl.uniform1iv(f,new Int32Array(h));break;case 2:t.gl.uniform2iv(f,new Int32Array(h));break;case 3:t.gl.uniform3iv(f,new Int32Array(h));break;case 4:t.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&t.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(b.sizeFromShape(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),t.gl.uniform1fv(c,h)}continue}u.texData.slice!=null&&p!=null&&t.gl.uniform1i(p,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(n.outShapeStridesLocation){let l=b.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&o)for(let l=0;l<n.program.customUniforms.length;++l){let u=n.program.customUniforms[l],c=n.customUniformLocations[l],p=o[l];if(u.type==="float")t.gl.uniform1fv(c,p);else if(u.type==="vec2")t.gl.uniform2fv(c,p);else if(u.type==="vec3")t.gl.uniform3fv(c,p);else if(u.type==="vec4")t.gl.uniform4fv(c,p);else if(u.type==="int")t.gl.uniform1iv(c,p);else if(u.type==="ivec2")t.gl.uniform2iv(c,p);else if(u.type==="ivec3")t.gl.uniform3iv(c,p);else if(u.type==="ivec4")t.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}t.executeProgram()}function wP(t,n,e){let r="";n.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=_v(t.packedInputs,i.shape,l),f="",d="",h="";if(c.length===1&&t.packedInputs){let T=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${T[0]>1}_${T[1]>1}`}else if(c.length===2&&!t.packedInputs)d=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){let T=b.computeStrides(c);h=`${T[0]===l[1]}_${T[T.length-1]===l[1]}`}let g=i.shape.length,m=c.length===2&&b.arraysEqual(i.shape,l),y=b.sizeFromShape(i.shape)===1,x=N.getBroadcastDims(i.shape,e.shape),v=!t.packedInputs&&g===e.shape.length&&b.arraysEqual(l,e.texData.texShape),w=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${v}_${u?p:""}_${c.length}_${y}_${x}_${m}_${f}_${d}_${h}_${w}_${a}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});let o=t.userCode,s=t.constructor.name;return s+="_"+r+"_"+o+`${$().getNumber("WEBGL_VERSION")}`,s}function ut(t){return $().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}var Ov=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=kc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=zt();this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_c(["r","c","d"],n):ns(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var Fv=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=kc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=zt();this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_c(["r","c","d"],n):ns(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var Mv=class{constructor(n){this.variableNames=["A"],this.outTexUsage=Jn.DOWNLOAD;let e=zt();this.outputShape=n,this.userCode=`
      ${Rv}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var $v=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Jn.DOWNLOAD;let e=zt();this.outputShape=n,this.userCode=`
      ${Rv}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var cae={R:0,G:1,B:2,A:3},Jm=class{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=zt();this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${cae[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Vd():zd(n)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Pv=class{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=zt();this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let l=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Vd():zd(n)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};function CP(t){let n=zt(),e=`${n.version}
    precision highp float;
    ${n.attribute} vec3 clipSpacePos;
    ${n.attribute} vec2 uv;
    ${n.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return K$(t,e)}function IP(t){let n=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Q$(t,n)}function SP(t){let n=new Uint16Array([0,1,2,2,1,3]);return J$(t,n)}function eg(t,n,e,r,o,s){tP(n,e);let i=eP(t),a=t.TEXTURE_2D;return de(t,()=>t.bindTexture(a,i)),de(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),de(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),de(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),de(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),$().getNumber("WEBGL_VERSION")===1?de(t,()=>t.texImage2D(a,0,r,n,e,0,o,s,null)):de(t,()=>t.texStorage2D(a,1,r,n,e)),de(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[e,n]}}function CE(t){return t.internalFormatFloat}function TP(t,n,e,r){let[o,s]=Ac(n,e);return eg(t,o,s,CE(r),r.textureFormatFloat,t.FLOAT)}function IE(t){return t.internalFormatHalfFloat}function NP(t,n,e,r){let[o,s]=Ac(n,e);return eg(t,o,s,IE(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function SE(t){return t.downloadTextureFormat}function EP(t,n,e,r){let[o,s]=Ac(n,e);return eg(t,o,s,SE(r),t.RGBA,t.UNSIGNED_BYTE)}function TE(t){return t.internalFormatPackedFloat}function DP(t,n,e,r){let[o,s]=Bs(n,e);return eg(t,o,s,TE(r),t.RGBA,t.FLOAT)}function NE(t){return t.internalFormatPackedHalfFloat}function kP(t,n,e,r){let[o,s]=Bs(n,e);return eg(t,o,s,NE(r),t.RGBA,r.textureTypeHalfFloat)}function AP(t,n,e){return de(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),xE(t,n,"clipSpacePos",e,3,20,0)&&xE(t,n,"uv",e,2,20,12)}function RP(t,n,e,r,o,s){de(t,()=>t.bindTexture(t.TEXTURE_2D,n));let i,a,l;o instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=s.internalFormatPackedFloat),i.set(o),$().getNumber("WEBGL_VERSION")===2?de(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,i)):de(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),de(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function _P(t,n,e){de(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?$().getNumber("WEBGL_VERSION")===2?de(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):de(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):$().getNumber("WEBGL_VERSION")===2?de(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):de(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),de(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function OP(t,n,e,r){let o=t.createBuffer();de(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o));let a=4*4*n*e;return de(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),de(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),de(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),o}function FP(t,n,e){let r=t,o=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function MP(t,n,e,r){let[o,s]=Ac(n,e),i=4,a=new Uint8Array(j$(n*e,i));return de(t,()=>t.readPixels(0,0,o,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function $P(t,n,e,r,o,s,i,a){let l=t,u=new Float32Array(H$(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function PP(t,n,e){let r=new Float32Array(n*e*4);return de(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}var qd=class{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=$().getNumber("WEBGL_VERSION");if(n!=null?(this.gl=n,W$(e,n)):this.gl=zr(e),n=this.gl,$().getNumber("WEBGL_VERSION")===2){let s=n;this.createVertexArray=()=>de(s,()=>s.createVertexArray()),this.bindVertexArray=i=>de(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>de(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>de(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(n!=null){let s=n.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>de(n,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>de(n,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>de(n,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>de(n,()=>n.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),$().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Ym(this.gl,s),oo(this.gl,i))this.textureHalfFloatExtension=Ym(this.gl,i);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),oo(this.gl,o))this.colorBufferHalfFloatExtension=Ym(this.gl,o);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",oo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(oo(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=IP(this.gl),this.indexBuffer=SP(this.gl),this.framebuffer=nP(this.gl),this.textureConfig=Xm(this.gl,this.textureHalfFloatExtension)}get debug(){return $().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let n=this.gl;de(n,()=>n.finish()),de(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),de(n,()=>n.deleteFramebuffer(this.framebuffer)),de(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),de(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),de(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),TP(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),NP(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),EP(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),_P(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,o){this.throwIfDisposed(),RP(this.gl,n,e,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),kP(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),DP(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(bE(this.gl,this.framebuffer),this.outputTexture=null),de(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>MP(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,o,s,i){return $P(this.gl,n,e,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(n,e){return FP(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);let o=OP(this.gl,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if($().getBool("WEBGL_FENCE_API_ENABLED")){let o=n,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>PP(this.gl,e,r))}createProgram(n){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=CP(e));let r=Y$(e);de(e,()=>e.attachShader(r,this.vertexShader)),de(e,()=>e.attachShader(r,n)),Z$(e,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Dv(e,o),o}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);let e=this.gl;de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),AP(e,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),n!=null&&(de(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,this.program!=null&&this.debug&&Dv(this.gl,this.program),de(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?rP(this.gl,n,e):oP(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),de(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),sP(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();let[o,s]=Bs(e,r);this.setOutputMatrixTextureDriver(n,o,s)}setOutputMatrixWriteRegion(n,e,r,o){this.setOutputMatrixWriteRegionDriver(r,n,o,e)}setOutputPackedMatrixWriteRegion(n,e,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Dv(this.gl,this.program),Zm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let n=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}de(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),de(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ym(this.gl,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT);return}let n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){return z(this,null,function*(){return yield b.repeatedTry(()=>this.disposed||this.isQueryAvailable(n,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(n,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(n,e){if(e===0)return null;if(e===2){let r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(e===0)return!0;if(e===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){let n=fae(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){let{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in $().platform&&(r=$().platform.setTimeoutCustom.bind($().platform)),b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),kv(this.gl,n,this.framebuffer),this.debug&&Zm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(kv(this.gl,this.outputTexture,this.framebuffer),this.debug&&Zm(this.gl)):bE(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);let r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();let o=this.gl;kv(o,n,this.framebuffer),this.debug&&Zm(o),this.outputTexture=n,de(o,()=>o.viewport(0,0,e,r)),de(o,()=>o.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,o){this.throwIfDisposed(),de(this.gl,()=>this.gl.scissor(n,e,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function fae(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}var rD={};ft(rD,{addImpl:()=>kE,bincountImpl:()=>Yd,bincountReduceImpl:()=>Lv,bitwiseAndImpl:()=>AE,castImpl:()=>DE,ceilImpl:()=>RE,concatImpl:()=>Bv,equalImpl:()=>_E,expImpl:()=>FE,expm1Impl:()=>$E,floorDivImpl:()=>LE,floorImpl:()=>PE,gatherNdImpl:()=>zv,gatherV2Impl:()=>Vv,greaterEqualImpl:()=>zE,greaterImpl:()=>BE,lessEqualImpl:()=>UE,lessImpl:()=>VE,linSpaceImpl:()=>Uv,logImpl:()=>GE,maxImpl:()=>Gv,maximumImpl:()=>WE,minimumImpl:()=>jE,multiplyImpl:()=>tg,negImpl:()=>HE,notEqualImpl:()=>qE,prodImpl:()=>KE,raggedGatherImpl:()=>Wv,raggedRangeImpl:()=>jv,raggedTensorToTensorImpl:()=>Hv,rangeImpl:()=>qv,rsqrtImpl:()=>YE,scatterImpl:()=>rs,sigmoidImpl:()=>hL,simpleAbsImpl:()=>EE,sliceImpl:()=>QE,sparseFillEmptyRowsImpl:()=>Kv,sparseReshapeImpl:()=>Xv,sparseSegmentReductionImpl:()=>Qd,sqrtImpl:()=>yL,squaredDifferenceImpl:()=>JE,staticRegexReplaceImpl:()=>eD,stridedSliceImpl:()=>Yv,stringNGramsImpl:()=>Zv,stringSplitImpl:()=>Qv,stringToHashBucketFastImpl:()=>Jv,subImpl:()=>nD,tileImpl:()=>ew,topKImpl:()=>tw,transposeImpl:()=>Zd,uniqueImpl:()=>nw});function Z(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the CPU backend.`)})}function EE(t){let n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}var dae=t=>{let{x:n}=t.inputs,e=t.backend;Z(n,"abs");let r=new Float32Array(b.sizeFromShape(n.shape)),o=e.data.get(n.dataId).values;return r=EE(o),e.makeOutput(r,n.shape,n.dtype)},LP={kernelName:Pa,backendName:"cpu",kernelFunc:dae};function We(t){return(n,e,r,o,s)=>{let i=N.assertAndGetBroadcastShape(n,e),a=i.length,l=b.computeStrides(i),u=b.sizeFromShape(i),c=b.getTypedArrayFromDType(s,u),p=n.length,f=e.length,d=b.computeStrides(n),h=b.computeStrides(e),g=N.getBroadcastDims(n,i),m=N.getBroadcastDims(e,i);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=t(r[y%r.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let x=b.indexToLoc(y,a,l),v=x.slice(-p);g.forEach(A=>v[A]=0);let w=b.locToIndex(v,p,d),T=x.slice(-f);m.forEach(A=>T[A]=0);let k=b.locToIndex(T,f,h);c[y]=t(r[w],o[k])}return[c,i]}}function mn(t){let{inputs:n,backend:e}=t,{real:r,imag:o}=n,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(r.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var BP={kernelName:Kp,backendName:"cpu",kernelFunc:mn};function Kd(t,n,e="float32"){if(e==="complex64"){let o=Kd(t,n,"float32"),s=Kd(t,n,"float32");return mn({inputs:{real:o,imag:s},backend:t})}let r=b.makeZerosTypedArray(b.sizeFromShape(n),e);return t.makeTensorInfo(n,e,r)}function Hn(t){let{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var zP={kernelName:Ts,backendName:"cpu",kernelFunc:Hn};function No(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var VP={kernelName:Ef,backendName:"cpu",kernelFunc:No};function DE(t,n,e,r){if(r==="int32"){let o=Int32Array.from(t);return[n,"int32",o]}if(r==="bool"){let o=b.toTypedArray([0],e),[s,i]=We((a,l)=>a!==l?1:0)(n,[],t,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Eo(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Hn({inputs:{x:o},backend:e});let c=Kd(e,o.shape,o.dtype),p=Eo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),f=mn({inputs:{real:p,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),f}if(o.dtype==="complex64"){let c=No({inputs:{input:o},backend:e}),p=Eo({inputs:{x:c},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(c),p}if(!b.hasEncodingLoss(o.dtype,s)){let c=Hn({inputs:{x:o},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=e.data.get(o.dataId).values,[a,l,u]=DE(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,u)}var UP={kernelName:Ss,backendName:"cpu",kernelFunc:Eo};function Ze(t,n,e,r){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;Z([i,a],t);let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=i.dtype==="string"?N.fromUint8ToStringArray(u):u,f=i.dtype==="string"?N.fromUint8ToStringArray(c):c,d=r||i.dtype,[h,g]=n(i.shape,a.shape,p,f,d);return l.makeTensorInfo(g,d,h)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let u=Eo({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,d=l.data.get(p.dataId).values,h=l.data.get(f.dataId).values,g=Eo({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),y=m.complexTensorInfos.real,x=m.complexTensorInfos.imag,v=l.data.get(y.dataId).values,w=l.data.get(x.dataId).values,[T,k,A]=e(i.shape,a.shape,d,h,v,w),O=l.makeTensorInfo(A,"float32",T),M=l.makeTensorInfo(A,"float32",k),L=mn({inputs:{real:O,imag:M},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(O),l.disposeIntermediateTensorInfo(M),L}else{let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=r||i.dtype,[f,d]=n(i.shape,a.shape,u,c,p);return l.makeTensorInfo(d,p,f)}}}function Xd(t){return(n,e,r,o,s,i)=>{let a=N.assertAndGetBroadcastShape(n,e),l=b.sizeFromShape(a),u=a.length,c=b.computeStrides(a),p=b.getTypedArrayFromDType("float32",l),f=b.getTypedArrayFromDType("float32",l),d=N.getBroadcastDims(n,a),h=N.getBroadcastDims(e,a),g=N.mergeRealAndImagArrays(r,o),m=N.mergeRealAndImagArrays(s,i),y=n.length,x=b.computeStrides(n),v=e.length,w=b.computeStrides(e);if(d.length+h.length===0)for(let T=0;T<p.length;T++){let k=T%g.length,A=T%m.length,O=t(g[k*2],g[k*2+1],m[A*2],m[A*2+1]);p[T]=O.real,f[T]=O.imag}else for(let T=0;T<p.length;T++){let k=b.indexToLoc(T,u,c),A=k.slice(-y);d.forEach(U=>A[U]=0);let O=b.locToIndex(A,y,x),M=k.slice(-v);h.forEach(U=>M[U]=0);let L=b.locToIndex(M,v,w),V=t(g[O*2],g[O*2+1],m[L*2],m[L*2+1]);p[T]=V.real,f[T]=V.imag}return[p,f,a]}}var kE=We((t,n)=>t+n),hae=Xd((t,n,e,r)=>({real:t+e,imag:n+r})),Vs=Ze(jo,kE,hae),GP={kernelName:jo,backendName:"cpu",kernelFunc:Vs};function Yd(t,n,e,r,o){let s=b.sizeFromShape(r),i=b.makeZerosTypedArray(o,e);for(let a=0;a<t.length;a++){let l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(s>0?i[l]+=n[a]:i[l]+=1)}return i}function Lv(t,n,e,r=!1){let o=t.shape[0],s=t.shape[1],i=he([o,e],n.dtype);for(let a=0;a<o;a++)for(let l=0;l<s;l++){let u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||(r?i.set(1,a,u):n.size>0?i.set(i.get(a,u)+n.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}var AE=We((t,n)=>t&n),mae=Ze(zu,AE),WP={kernelName:zu,backendName:"cpu",kernelFunc:mae};function Tn(t){return(n,e,r)=>{let o=b.getArrayFromDType(e,n.length);for(let s=0;s<n.length;++s)o[s]=t(n[s],r);return o}}function Ie(t,n,e){let r=Tn(n);return Ir(t,r,e)}function Ir(t,n,e){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;Z(i,t);let a=s,l=a.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=N.fromUint8ToStringArray(l)}else u=l;let c=e||i.dtype,p=n(u,c,o);return a.makeTensorInfo(i.shape,c,p)}}var RE=Tn(t=>Math.ceil(t)),gae=Ir(hi,RE),jP={kernelName:hi,backendName:"cpu",kernelFunc:gae};function Bv(t,n,e,r){let o=b.getArrayFromDType(e,b.sizeFromShape(n));if(r&&e!=="string"){let s=0;t.forEach(i=>{let a=b.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;t.forEach(i=>{let a=e==="string"?N.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*n[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[l++]}s+=i.shape[1]})}return o}var _E=We((t,n)=>t===n?1:0),OE=Ze(Vu,_E,null,"bool"),HP={kernelName:Vu,backendName:"cpu",kernelFunc:OE};var FE=Tn(t=>Math.exp(t)),ME=Ir(wi,FE,"float32"),qP={kernelName:wi,backendName:"cpu",kernelFunc:ME};var $E=Tn(t=>Math.expm1(t)),yae=Ir(Ci,$E),KP={kernelName:Ci,backendName:"cpu",kernelFunc:yae};var PE=Tn(t=>Math.floor(t)),xae=Ir(Ii,PE),XP={kernelName:Ii,backendName:"cpu",kernelFunc:xae};var LE=We((t,n)=>Math.floor(t/n)),bae=Ze(Si,LE,null,"int32"),YP={kernelName:Si,backendName:"cpu",kernelFunc:bae};function zv(t,n,e,r,o,s,i,a,l){let u=he([r,s],e);for(let c=0;c<r;c++){let p=[],f=0;for(let d=0;d<o;d++){let h=t[c*o+d];f+=h*i[d],p.push(h)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let d=0;d<s;d++)u.values[c*s+d]=n.get(...n.indexToLoc(f*s+d))}return u}function Vv(t,n,e){let r=he(e,t.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],l=i[2],u=n.locToIndex([a,l]);i[2]=n.values[u];let c=t.locToIndex(i);0<=c&&c<t.values.length&&(r.values[o]=t.values[c])}return r}var BE=We((t,n)=>t>n?1:0),vae=Ze(Uu,BE,null,"bool"),ZP={kernelName:Uu,backendName:"cpu",kernelFunc:vae};var zE=We((t,n)=>t>=n?1:0),wae=Ze(Ti,zE,null,"bool"),QP={kernelName:Ti,backendName:"cpu",kernelFunc:wae};var VE=We((t,n)=>t<n?1:0),Cae=Ze(Gu,VE,null,"bool"),JP={kernelName:Gu,backendName:"cpu",kernelFunc:Cae};var UE=We((t,n)=>t<=n?1:0),Iae=Ze(Wu,UE,null,"bool"),eL={kernelName:Wu,backendName:"cpu",kernelFunc:Iae};function Uv(t,n,e){let r=(n-t)/(e-1),o=b.makeZerosTypedArray(e,"float32");o[0]=t;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}var GE=Tn(t=>Math.log(t)),Sae=Ir(ki,GE),tL={kernelName:ki,backendName:"cpu",kernelFunc:Sae};function Gv(t,n,e,r){let o=b.getTypedArrayFromDType(r,b.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*n,a=t[i];for(let l=0;l<n;++l){let u=t[i+l];(Number.isNaN(u)||u>a)&&(a=u)}o[s]=a}return o}var WE=We((t,n)=>Math.max(t,n)),Tae=Ze(Ri,WE),nL={kernelName:Ri,backendName:"cpu",kernelFunc:Tae};var jE=We((t,n)=>Math.min(t,n)),Nae=Ze(_i,jE),rL={kernelName:_i,backendName:"cpu",kernelFunc:Nae};var tg=We((t,n)=>t*n),Eae=Xd((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),Fc=Ze(Fi,tg,Eae),oL={kernelName:Fi,backendName:"cpu",kernelFunc:Fc};function HE(t,n,e){let r=b.createScalarValue(-1,e);return tg([],n,r,t,e)}function Dae(t){let{inputs:n,backend:e}=t,{x:r}=n;Z(r,"neg");let o=e.data.get(r.dataId).values,[s,i]=HE(o,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,s)}var sL={kernelName:cl,backendName:"cpu",kernelFunc:Dae};var qE=We((t,n)=>t!==n?1:0),kae=Ze(Ku,qE,null,"bool"),iL={kernelName:Ku,backendName:"cpu",kernelFunc:kae};function Zd(t,n,e,r,o){let s=n.length,i=b.sizeFromShape(n),a=b.computeStrides(n),l=b.computeStrides(o),u=b.getTypedArrayFromDType(e,b.sizeFromShape(o));for(let c=0;c<i;++c){let p=b.indexToLoc(c,s,a),f=new Array(p.length);for(let h=0;h<f.length;h++)f[h]=p[r[h]];let d=b.locToIndex(f,s,l);u[d]=t[c]}return u}function Vt(t){let{inputs:n,attrs:e,backend:r}=t,{x:o}=n,{perm:s}=e;Z(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let l=r.data.get(o.dataId).values,u=Zd(l,o.shape,o.dtype,s,a);return{dataId:r.write(u,a,o.dtype),shape:a,dtype:o.dtype}}var aL={kernelName:Es,backendName:"cpu",kernelFunc:Vt};function KE(t,n,e,r){let[o,s]=N.computeOutAndReduceShapes(t,r),i=nn(n,"int32"),a=b.makeZerosTypedArray(b.sizeFromShape(o),i),l=b.sizeFromShape(s);for(let u=0;u<a.length;++u){let c=u*l,p=1;for(let f=0;f<l;++f)p*=e[c+f];a[u]=p}return{outVals:a,outShape:o,outDtype:i}}function Aae(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;Z(o,"prod");let a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=N.getAxesPermutation(l,a),c=l,p=o,f=[];u!=null&&(p=Vt({inputs:{x:o},backend:e,attrs:{perm:u}}),f.push(p),c=N.getInnerMostAxes(c.length,a));let d=e.data.get(p.dataId).values,{outVals:h,outShape:g,outDtype:m}=KE(p.shape,p.dtype,d,c),y=g;return i&&(y=N.expandShapeToKeepDim(g,l)),f.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(y,m,h)}var lL={kernelName:gl,backendName:"cpu",kernelFunc:Aae};function Rae(t,n,e){t.forEach((r,o)=>{if(r<0||r>=e){let s=b.indexToLoc(o,n.length,b.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}function _ae(t,n){for(let e=0;e<t.length;++e){let r=t[e],o=e===t.length-1?n:t[e+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Oae(t,n,e,r){let o=[],s=0,i=n.length-1+e.length,a=new Array(i).fill(null).map(()=>[0]);_ae(e,r);let l=1;for(let u=0;u<n.length-1;++u){l*=n[u];let c=n[u+1];for(let p=1;p<l+1;++p)a[u].push(p*c)}for(let u=0;u<t.length;++u){let c=t[u],p=t[u]+1;for(let f=0;f<e.length;++f){let d=e[f],h=f+n.length-1;if(h>=0){let g=a[h],m=g[g.length-1]-d[c];for(let y=c;y<p;++y)a[h].push(d[y+1]+m)}c=d[c],p=d[p]}p!==c&&(o.push([c,p]),s+=p-c)}return{outSplits:a,valueSlices:o,numValues:s}}function Fae(t){let n=[];for(let e=0;e<t.length;++e){let r=t[e].length,o=b.getArrayFromDType("int32",r);n.push(o),t[e].forEach((s,i)=>o[i]=s)}return n}function uL(t,n){let e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function Mae(t,n,e,r,o,s){let i=uL(n,2)[1],a=uL(s,2)[1],l=0;for(let u of e)for(let c=u[0];c<u[1];++c){for(let p=0;p<r;++p)o[l*a+p]=t[c*i+p];++l}}function $ae(t,n,e,r,o){let s=n.slice();s[0]=o;let i=b.getArrayFromDType(e,b.sizeFromShape(s)),a=t.length,l=a===0?0:a/n[0];return Mae(t,n,r,l,i,s),[i,s]}function Wv(t,n,e,r,o,s,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(n[0].length===0)throw new Error("Split tensors must not be scalars");let l=n[0][0]-1;if(Rae(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:p,numValues:f}=Oae(s,i,t,u),d=Fae(c),h=$ae(e,r,o,p,f);return[d,h[0],h[1]]}var cL=2147483647;function jv(t,n,e,r,o,s,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=n.length===0,l=o.length===0,u=i.length===0,c=[];a||c.push(n[0]),l||c.push(o[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],f=b.getArrayFromDType("int32",p+1);f[0]=0;for(let m=0;m<p;++m){let y=a?t[0]:t[m],x=l?r[0]:r[m],v=u?s[0]:s[m];if(v===0)throw new Error("Requires delta != 0");let w;if(v>0&&x<y||v<0&&x>y)w=0;else if(w=Math.ceil(Math.abs((x-y)/v)),w>cL)throw new Error(`Requires ((limit - start) / delta) <= ${cL}`);f[m+1]=f[m]+w}let d=f[p],h=b.getArrayFromDType(e,d),g=0;for(let m=0;m<p;++m){let y=f[m+1]-f[m],x=a?t[0]:t[m],v=u?s[0]:s[m];for(let w=0;w<y;++w)h[g++]=x,x+=v}return[f,h]}var Do=N.RowPartitionType,XE=class t{constructor(n,e,r,o,s,i,a,l,u,c){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=N.getRowPartitionTypesHelper(c),this.raggedRank=N.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===Do.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===Do.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){let e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case Do.VALUE_ROWIDS:return t.getMaxWidthValueRowID(e);case Do.ROW_SPLITS:return t.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Do[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){let e=n.length;if(e===0||e===1)return 0;let r=0;for(let o=0;o<e-1;++o){let s=n[o+1]-n[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(n){let e=n.length;if(e===0)return 0;let r=0,o=n[0],s=0;for(let i=1;i<e;++i){let a=n[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(e-r,s)}tensorShapeFromTensor(n,e,r=!0){if(e.length===0){if(n[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return fL(n,r)}calculateOutputSize(n){let e=this.valuesShape,r=this.defaultValueShape;N.validateDefaultValueShape(r,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=N.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,e,r){let o=Math.min(n,r),s=[],i=0;for(let a=0;a<o;++a,i+=e)s.push(i);for(let a=o;a<n;++a)s.push(-1);return b.assert(s.length===n,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(n,e,r,o){let s=n.length,i=[];for(let a=0;a<s-1;++a){let l=n[a+1]-n[a],u=Math.min(o,l),c=e[a];c===-1&&(u=0);for(let p=0;p<u;++p)i.push(c),c+=r;for(let p=0;p<l-u;++p)i.push(-1)}if(s>0&&i.length!==n[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,e,r,o){let s=n.length,i=[];if(s===0)return[];let a=0,l=n[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<s;++c){let p=n[c];if(p===l)u>=0&&(++a,a<o?u+=r:u=-1);else{if(a=0,l=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);u=e[p]}i.push(u)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,e,r,o){let s=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case Do.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,o);case Do.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,o);default:throw new Error(`Unsupported partition type: ${Do[i]}`)}}getFirstDimensionSize(){let n=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Do.FIRST_DIM_SIZE:return n[0];case Do.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Do.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Do[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let l=o.length-2;l>=0;--l)o[l]=o[l+1]*r[l+1];let s=fL(r,!1),i=b.getArrayFromDType(this.valuesDType,b.sizeFromShape(s));if(o[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,o[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,o[u],r[u]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(n,e,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(n+1);let l=b.sizeFromShape(a),u=e.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let h=this.defaultValueShape;B(()=>{let g=_(c,h);c=Os(g,a).dataSync()})}let p=0,f=0,d=0;for(let h=0;h<=u;++h){let g=h<u?e[h]:-1;if(g===d){++d;continue}if(f<d){let m=s.subarray(p*l),y=i.subarray(f*l),x=(d-f)*l;pL(y,m,x)}if(h>=u){let m=r.length;g=Math.floor(m/l)}if(g>d)if(this.defaultValue.length===1)i.subarray(d*l,g*l).fill(this.defaultValue[0]),d=g;else for(;g>d;){let m=i.slice(d*l);pL(m,c,l),++d}g<0?(p=h+1,f=d):(p=h,f=d,d=f+1)}}};function pL(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function fL(t,n){let e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function Hv(t,n,e,r,o,s,i,a,l,u){return new XE(t,n,e,r,o,s,i,a,l,u).compute()}function qv(t,n,e,r){let o=t===n,s=t<n&&e<0,i=n<t&&e>1;if(o||s||i)return b.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((n-t)/e)),l=b.makeZerosTypedArray(a,r);n<t&&e===1&&(e=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}var YE=Tn(t=>1/Math.sqrt(t)),Pae=Ir(zi,YE),dL={kernelName:zi,backendName:"cpu",kernelFunc:Pae};function rs(t,n,e,r,o,s,i,a,l,u){let c=[r/o,o],p=t.values,f=n.values;if(r===0)return he(e,n.dtype);let d=l instanceof tt?l:he(c,n.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let h=0;h<s;h++){let g=[],m=0;for(let y=0;y<i;y++){let x=p[h*i+y];g.push(x),m+=x*a[y]}if(m<0||m>=r/o)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<o;y++)u?d.values[m*o+y]+=f[h*o+y]:d.values[m*o+y]=n.rank===0?f[0]:f[h*o+y]}return d}var hL=Tn(t=>1/(1+Math.exp(-t))),ZE=Ie(ji,t=>1/(1+Math.exp(-t))),mL={kernelName:ji,backendName:"cpu",kernelFunc:ZE};function QE(t,n,e,r,o){let s=Sn.isSliceContinous(r,n,e),i=b.sizeFromShape(e),a=b.computeStrides(r);if(s){let p=Sn.computeFlatOffset(n,a);return o==="string"?t.slice(p,p+i):t.subarray(p,p+i)}let l=o==="string"?N.fromUint8ToStringArray(t):t,u=he(r,o,l),c=he(e,o);for(let p=0;p<c.size;++p){let f=c.indexToLoc(p),d=f.map((h,g)=>h+n[g]);c.set(u.get(...d),...f)}return o==="string"?N.fromStringArrayToUint8(c.values):c.values}function ko(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,size:i}=r;Z(o,"slice");let[a,l]=Sn.parseSliceParams(o,s,i);Sn.assertParamsValid(o,a,l);let u=e.data.get(o.dataId).values,c=QE(u,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,c)}var gL={kernelName:Cl,backendName:"cpu",kernelFunc:ko};function Kv(t,n,e,r,o,s,i){let a=n[0],l=s[0],u=new Array(l),c=new Array(a),p=n[1];if(l===0){if(a!==0)throw new Error(N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let m=b.getArrayFromDType(e,0),y=b.getArrayFromDType(o,0);return[m,[0,p],y,u,c]}let f=!0,d=0,h=new Array(l).fill(0);for(let m=0;m<a;++m){let y=t[m*p];if(y<0)throw new Error(N.getSparseFillEmptyRowsNegativeIndexErrorMessage(m,y));if(y>=l)throw new Error(N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(m,y,l));++h[y],f=f&&y>=d,d=y}let g=!0;for(let m=0;m<l;++m){let y=h[m]===0;u[m]=y,g=g&&!y,h[m]=Math.max(h[m],1),m>0&&(h[m]+=h[m-1])}if(g&&f){let m=t,y=r;for(let x=0;x<a;++x)c[x]=x;return[m,[a,p],y,u,c]}else{let m=h[l-1],y=b.getArrayFromDType(e,m*p),x=b.getArrayFromDType(o,m),v=new Array(l).fill(0);for(let w=0;w<a;++w){let T=t[w*p],k=v[T],A=(T===0?0:h[T-1])+k;v[T]++;for(let O=0;O<p;++O)y[A*p+O]=t[w*p+O];x[A]=r[w],c[w]=A}for(let w=0;w<l;++w)if(v[w]===0){let k=w===0?0:h[w-1];y[k*p+0]=w;for(let A=1;A<p;++A)y[k*p+A]=0;x[k]=i}return[y,[m,p],x,u,c]}}function Xv(t,n,e,r,o){let s=b.sizeFromShape(r),i=n[0],a=o.length,l=[],u=1,c=-1;for(let m=0;m<a;++m){let y=o[m];if(y===-1){if(c!==-1)throw new Error(N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(N.getSparseReshapeNegativeOutputDimErrorMessage(m,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/u);if(u*m!==s)throw new Error(N.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=m}if(b.sizeFromShape(l)!==s)throw new Error(N.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let f=r.length,d=[];if(f>0){d[f-1]=1;for(let m=f-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let h=[];if(a>0){h[a-1]=1;for(let m=a-2;m>=0;--m)h[m]=h[m+1]*l[m+1]}let g=b.getArrayFromDType(e,i*a);for(let m=0;m<i;++m){let y=0;for(let x=0;x<f;++x)y+=t[m*f+x]*d[x];for(let x=0;x<a;++x)g[m*a+x]=Math.trunc(y/h[x]),y%=h[x]}return[g,[i,a],l]}function Qd(t,n,e,r,o,s=!1,i=0){let a=r.length,l=[n[0],t.length/n[0]],u=l[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=n.slice();f[0]=p;let d=f.reduce((v,w)=>v*w,1),h=b.getArrayFromDType(e,d);if(a===0)return p>0&&h.fill(i),[h,f];if(p<=0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,m=1,y=0,x=o[g];for(;;){let v=0;if(m<a){if(v=o[m],x===v){++m;continue}if(x>=v)throw new Error(N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=p)throw new Error(N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,p));x>y&&h.fill(i,y*u,x*u);for(let w=g;w<m;++w){let T=r[w];if(T<0||T>=l[0])throw new Error(N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,r[w],l[0]));for(let k=0;k<u;k++)h[x*u+k]+=t[T*u+k]}if(s)for(let w=0;w<u;w++)h[x*u+w]/=m-g;if(g=m,++m,y=x+1,x=v,m>a)break}return y<p&&h.fill(i,y*u,p*u),[h,f]}var yL=Tn(t=>Math.sqrt(t)),Lae=Ie(qi,t=>Math.sqrt(t)),xL={kernelName:qi,backendName:"cpu",kernelFunc:Lae};var JE=We((t,n)=>{let e=t-n;return e*e}),Bae=Ze(Ki,JE),bL={kernelName:Ki,backendName:"cpu",kernelFunc:Bae};var eD=Tn((t,n)=>{let{pattern:e,replaceGlobal:r,rewrite:o}=n;return t.replace(new RegExp(e,r?"g":""),o)}),zae=Ir(Xu,eD),vL={kernelName:Xu,backendName:"cpu",kernelFunc:zae};function Yv(t,n,e,r){let o=he(t,n.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];o.set(n.get(...a),...i)}return o}var tD=class{constructor(n,e,r,o,s,i){this.separator=b.encodeString(n),this.nGramWidths=e,this.leftPad=b.encodeString(r),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){let r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,o,s,i){for(let a=0;a<s;++a){let l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),p=i-(u+c),f=e+(u>0?0:a-l),d=0;d+=u*this.leftPad.length;for(let x=0;x<p;++x)d+=n[f+x].length;d+=c*this.rightPad.length;let h=u+c+p-1;d+=h*this.separator.length,r[o+a]=new Uint8Array(d);let g=r[o+a],m=0,y=x=>x.forEach(v=>g[m++]=v);for(let x=0;x<u;++x)y(this.leftPad),y(this.separator);for(let x=0;x<p-1;++x)y(n[f+x]),y(this.separator);if(p>0){y(n[f+p-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(n,e){let r=n.length,o=e.length;if(o>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<o;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}let s=o-1,i=b.getArrayFromDType("int32",o);if(r===0||o===0){let l=new Array(r);for(let u=0;u<=s;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){let u=e[l]-e[l-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}let a=new Array(i[s]);for(let l=0;l<s;++l){let u=e[l],c=i[l];if(this.nGramWidths.forEach(p=>{let f=e[l+1]-e[l],d=this.getNumNGrams(f,p);this.createNGrams(n,u,a,c,d,p),c+=d}),this.preserveShort&&c===i[l]){let p=e[l+1]-e[l];if(p===0)continue;let f=p+2*this.padWidth;this.createNGrams(n,u,a,c,1,f)}}return[a,i]}};function Zv(t,n,e,r,o,s,i,a){return new tD(e,r,o,s,i,a).compute(t,n)}function Vae(t,n,e,r){if(!t.length)return;if(n.length===0){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(n.length===1){let s=n[0],i=t.indexOf(s);for(;i!==-1;){let a=t.subarray(0,i);(!e||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(s)}(!e||t.length!==0)&&r.push(t);return}let o=0;for(let s=0;s<t.length+1;s++)if(s===t.length||n.indexOf(t[s])!==-1){let i=t.subarray(o,s);(!e||i.length!==0)&&r.push(i),o=s+1}}function Qv(t,n,e){let r=t.length,o=[],s=0,i=0,a=new Array(r);for(let f=0;f<r;++f){let d=o.length;Vae(t[f],n,e,o);let h=o.length-d;a[f]=h,s+=h,i=Math.max(i,h)}let l=b.getArrayFromDType("int32",s*2),u=new Array(s),c=[r,i],p=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[p*2]=f,l[p*2+1]=d,u[p]=o[p],++p;return[l,u,c]}function Jv(t,n){let e=b.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)e[r]=b.fingerPrint64(t[r]).modulo(n).getLowBitsUnsigned();return e}var nD=We((t,n)=>t-n),Uae=Xd((t,n,e,r)=>({real:t-e,imag:n-r})),ng=Ze(Xi,nD,Uae),wL={kernelName:Xi,backendName:"cpu",kernelFunc:ng};function ew(t,n){let e=new Array(t.rank);for(let o=0;o<e.length;o++)e[o]=t.shape[o]*n[o];let r=he(e,t.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%t.shape[l];let a=t.locToIndex(i);r.values[o]=t.values[a]}return r}var rg=(t,n)=>{let e=n.value-t.value;return e===0?t.index-n.index:e};function CL(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){let a=r-e+1,l=n-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),f=Math.max(e,Math.floor(n-l*c/a+p)),d=Math.min(r,Math.floor(n+(a-l)*c/a+p));CL(t,n,f,d)}let o=t[n],s=e,i=r;for(b.swap(t,e,n),rg(t[r],o)>0&&b.swap(t,e,r);s<i;){for(b.swap(t,s,i),s++,i--;rg(t[s],o)<0;)s=s+1;for(;rg(t[i],o)>0;)i=i-1}rg(t[e],o)===0?b.swap(t,e,i):(i=i+1,b.swap(t,i,r)),i<=n&&(e=i+1),n<=i&&(r=i-1)}}function tw(t,n,e,r,o){let s=n[n.length-1],[i,a]=[t.length/s,s],l=b.getTypedArrayFromDType(e,i*r),u=b.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let f=p*a,d=t.subarray(f,f+a),h=new Array(d.length);d.forEach((x,v)=>h[v]={value:x,index:v}),r<h.length&&(CL(h,r),h=h.slice(0,r)),o&&h.sort(rg);let g=p*r,m=l.subarray(g,g+r),y=u.subarray(g,g+r);for(let x=0;x<r;x++)m[x]=h[x].value,y[x]=h[x].index}let c=n.slice();return c[c.length-1]=r,[he(c,e,l),he(c,"int32",u)]}function nw(t,n,e,r){let o=b.parseAxisParam(n,e)[0],s=[1,e[0],1];for(let h=0;h<o;h++)s[0]*=e[h];s[1]=e[o];for(let h=o+1;h<e.length;h++)s[2]*=e[h];let i=new Map,a=new Int32Array(e[o]),l=new tt(s,r,t),u=[],c=s[0]===1&&s[2]===1;for(let h=0;h<e[o];h++){let g;if(c)g=t[h].toString();else{let y=[];for(let x=0;x<s[0];x++)for(let v=0;v<s[2];v++)y.push(l.get(x,h,v));g=y.join(",")}let m=i.get(g);if(m!=null)a[h]=m;else{let y=i.size;i.set(g,y),a[h]=y,u.push(h)}}let p=s.slice();p[1]=i.size;let f=new tt(p,r);u.forEach((h,g)=>{for(let m=0;m<s[0];m++)for(let y=0;y<s[2];y++)f.set(l.get(m,h,y),m,g,y)});let d=e.slice();return d[o]=p[1],{outputValues:f.values,outputShape:d,indices:a}}var{addImpl:IL,bincountImpl:rw,bincountReduceImpl:SL,bitwiseAndImpl:TL,castImpl:NL,ceilImpl:EL,concatImpl:DL,equalImpl:kL,expImpl:AL,expm1Impl:RL,floorImpl:_L,gatherNdImpl:OL,gatherV2Impl:FL,greaterImpl:ML,greaterEqualImpl:$L,lessImpl:PL,lessEqualImpl:LL,linSpaceImpl:BL,logImpl:zL,maxImpl:VL,maximumImpl:UL,minimumImpl:GL,multiplyImpl:WL,negImpl:jL,notEqualImpl:HL,prodImpl:qL,raggedGatherImpl:KL,raggedRangeImpl:XL,raggedTensorToTensorImpl:YL,rangeImpl:ZL,rsqrtImpl:QL,scatterImpl:JL,sigmoidImpl:eB,simpleAbsImpl:ow,sliceImpl:tB,sparseFillEmptyRowsImpl:nB,sparseReshapeImpl:rB,sparseSegmentReductionImpl:sw,sqrtImpl:oB,staticRegexReplaceImpl:sB,stridedSliceImpl:iB,stringNGramsImpl:aB,stringSplitImpl:lB,stringToHashBucketFastImpl:uB,subImpl:cB,tileImpl:pB,topKImpl:fB,transposeImpl:Mc,uniqueImpl:dB}=rD;function oD(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function Yt(t,n){return n===1?[t]:oD(t,n)}function hB(t,n){if(t===1)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}var iw=class{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=ut(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=Yt("rc",this.rank),r=ke(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(n){let e=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${n[n.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(n){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(this.rank===1)return"";let e=n.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(n){let e=this.getSourceCoordsArr(n);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var Jd=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Gae(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Vd():zd(n)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};

        ${r}

        setOutput(result);
      }
    `}};function Gae(t,n){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${n?dP(["r","c","d"],"inputShape"):ns(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}var aw=class{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){let o=gB(e,r),s=yB(n,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=mB(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let a;return o===jn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):o===jn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):o===jn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):o===jn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):o===jn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,o){if(this.freeTextures==null)return;let s=gB(r,o),i=yB(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=mB(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=$().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let u=this.usedTextures[i],c=u&&u.indexOf(n);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let n=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${n})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Wae(t,n){let e=t;if(n===e.R32F)return 4;if(n===e.R16F)return 2;if(n===e.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===e.RGBA16F)return 8;if(n===e.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}function mB(t,n,e,r,o){let s=jae(n,r),i;if(o){let[l,u]=Bs(t[0],t[1]);i=l*u}else{let[l,u]=Ac(t[0],t[1]);i=l*u}let a=Wae(e,s);return i*a}function jae(t,n){switch(t){case jn.PACKED_2X2_FLOAT32:return TE(n);case jn.PACKED_2X2_FLOAT16:return NE(n);case jn.UNPACKED_FLOAT32:return CE(n);case jn.UNPACKED_FLOAT16:return IE(n);case jn.PACKED_4X1_UNSIGNED_BYTE:return SE(n);default:throw new Error(`Unknown physical texture type ${t}`)}}function Hae(t){return $().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?jn.PACKED_2X2_FLOAT32:jn.UNPACKED_FLOAT32:t?jn.PACKED_2X2_FLOAT16:jn.UNPACKED_FLOAT16}function gB(t,n){if(t===Jn.UPLOAD)return jn.PACKED_2X2_FLOAT32;if(t===Jn.RENDER||t==null)return Hae(n);if(t===Jn.DOWNLOAD||t===Jn.PIXELS)return jn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function yB(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}var Mn=class{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},fn="if (isnan(x)) return x;",xB="return x;",sD="return abs(x);";var bB="return (x >= 0.0) ? x : (exp(x) - 1.0);",vB=fn+`
  return (x < 0.0) ? 0.0 : x;
`,wB=fn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Us="return x;",CB="return 1.0 / (1.0 + exp(-1.0 * x));";var SB="return x;",TB=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,NB=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,EB=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DB="return 1.0 / (1.0 + exp(-1.0 * x));",Sr=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var lw=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length);let e=n.length,r=Yt("rc",e),o=ke(e),s=hB(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Kae=Wn.whereImpl,Xae=1e-7,Yae=1e-4,uw={};function Zae(t){return t in uw||(uw[t]={}),uw[t]}var Qae=$().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Jae=600;function ele(){return $().global.screen==null?1024:$().global.screen.height*$().global.screen.width*window.devicePixelRatio*Jae/1024/1024}var kB=(()=>{class t extends si{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!$().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(e!=null){if(e instanceof qd)r=e;else{let o=zr($().getNumber("WEBGL_VERSION"),e);r=new qd(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=zr($().getNumber("WEBGL_VERSION"));r=new qd(o),this.binaryCache=Zae($().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new aw(this.gpgpu),this.numMBBeforeWarning=ele(),this.texData=new $u(this,wo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,o,s,i,a){let l=this.makeTensorInfo(r,o),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[s,i]},u.texShape=[s,i];let c=Qm(r),p=new Jm(c,!1,a),f=this.runWebGLProgram(p,[l],o,[[s,i]]);return f.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),f.dataId}write(e,r,o){if(($().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:e,usage:Jn.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let r=this.texData.get(e);r.refCount++}decRef(e){if(this.texData.has(e)){let r=this.texData.get(e);r.refCount--}}move(e,r,o,s,i){if($().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:s,values:r,usage:Jn.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let r=this.texData.get(e),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(a!=null){let d;u?d=new Sr(l,Us):d=new Mn(l,Us);let h=this.runWebGLProgram(d,[{dataId:e,shape:l,dtype:s}],s),g=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(o!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return o;let c=this.activeTimers!=null,p;c&&(p=b.now());let f;if(s==="complex64"){let d=this.readSync(i.real.dataId),h=this.readSync(i.imag.dataId);f=N.mergeRealAndImagArrays(d,h)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,f)}read(e){return z(this,null,function*(){if(this.pendingRead.has(e)){let g=this.pendingRead.get(e);return new Promise(m=>g.push(m))}let r=this.texData.get(e),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:l,isPacked:u}=r;if(i!=null){let g;u?g=new Sr(s,Us):g=new Mn(s,Us);let m=this.runWebGLProgram(g,[{dataId:e,shape:s,dtype:a}],a),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(o!=null)return this.convertAndCacheOnCPU(e);if($().getBool("DEBUG")&&!$().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,p;if(a!=="complex64"&&$().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let g=this.texData.get(p.dataId);c=this.gpgpu.createBufferFromTexture(g.texture.texture,...Km(s))}this.pendingRead.set(e,[]),a!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let f;if(a==="complex64"){let g=yield Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),m=g[0],y=g[1];f=N.mergeRealAndImagArrays(m,y)}else if(c==null)f=this.getValuesFromTexture(e);else{let g=b.sizeFromShape(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,g)}if(p!=null&&this.disposeIntermediateTensorInfo(p),c!=null){let g=this.gpgpu.gl;de(g,()=>g.deleteBuffer(c))}let d=this.convertAndCacheOnCPU(e,f),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(g=>g(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&wo().removeDataId(e,this),this.pendingDeletes--),d})}readToGPU(e,r={}){let o=this.texData.get(e),{values:s,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=o;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;u?h=new Sr(i,Us):h=new Mn(i,Us);let g=this.runWebGLProgram(h,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,r.customTexShape),f=wo().makeTensorFromTensorInfo(p),d=this.texData.get(p.dataId);return Object.assign({tensorRef:f},d.texture)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return he(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return he(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let r=0;r<e.length;r++){let o=e[r];if(!q$(o))throw $().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:r,dtype:o,isPacked:s}=this.texData.get(e),i=b.sizeFromShape(r);if($().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),h=this.texData.get(d.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Km(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),g}let a=$().getBool("WEBGL_PACK")&&s===!0,l=a?Qm(r):r,u=a?new $v(l):new Mv(l),c=this.runWebGLProgram(u,[{shape:l,dtype:o,dataId:e}],"float32"),p=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let i=b.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=b.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return z(this,null,function*(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=yield Promise.all(i);l.kernelMs=b.sum(u),l.getExtraProfileInfo=()=>u.map((c,p)=>({name:a[p],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}getQueryTime(e){return z(this,null,function*(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let r=e;return r.endMs-r.startMs})}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=Qae){return $().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&b.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){N.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=e.dataSync();return Kae(e.shape,r)}packedUnaryOp(e,r,o){let s=new Sr(e.shape,r),i=this.compileAndRun(s,[e],o);return wo().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let s=ow(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if($().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,sD,e.dtype);let r=new Mn(e.shape,sD),o=this.compileAndRun(r,[e]);return wo().makeTensorFromTensorInfo(o)}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,o){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,o),this)}unpackTensor(e){let r=new lw(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){let r=new iw(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){let o=[tu(e.shape),...nu(e.shape)],s={dtype:e.dtype,shape:o,dataId:e.dataId},i=[tu(r),...nu(r)],a=new Jd(i,o),l=!0,u=[o],c=this.runWebGLProgram(a,[s],e.dtype,u,l);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){let o=this.texData.get(e),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let d=b.sizeFromShape(i),h=r[0]*r[1]*4;b.assert(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let l=Qm(i),u;s?u=new Fv(l):u=new Ov(l);let c=!0,p=[r??Km(l)],f=this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,p,c,r);return{dtype:a,shape:i,dataId:f.dataId}}runWebGLProgram(e,r,o,s,i=!1,a){let l=this.makeTensorInfo(e.outputShape,o),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===kc.DENSE){let x=a??Km(e.outputShape);u.texShape=x.map(v=>v*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),b.sizeFromShape(l.shape)===0)return u.values=b.getTypedArrayFromDType(l.dtype,0),l;let c=[],p=r.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(x.dataId);if(v.texture==null){if(!e.packedInputs&&b.sizeFromShape(x.shape)<=$().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!v.isPacked!=!!e.packedInputs)x=v.isPacked?this.unpackTensor(x):this.packTensor(x),c.push(x),v=this.texData.get(x.dataId);else if(v.isPacked&&!Rc(v.shape,x.shape)){let w=x,T=x.shape;x.shape=v.shape,x=this.packedReshape(x,T),c.push(x),v=this.texData.get(x.dataId),w.shape=T}return{shape:x.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);let f={shape:l.shape,texData:u,isUniform:!1},d=wP(e,p,f),h=this.getAndSaveBinary(d,()=>bP(this.gpgpu,e,p,f)),g=this.activeTimers!=null,m;g&&(m=this.startTimer()),$().get("ENGINE_COMPILE_ONLY")||vP(this.gpgpu,h,p,f,s),c.forEach(x=>this.disposeIntermediateTensorInfo(x)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));let y=$().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let x=b.now();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!$().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){let x=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),x}return l}compileAndRun(e,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(e,r,o,s,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||($().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!$().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=$().getBool("DEBUG");$().set("DEBUG",!1);let r=this.abs(se(1e-8)).dataSync()[0];if($().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Xae:Yae}uploadToGPU(e){let r=this.texData.get(e),{shape:o,dtype:s,values:i,texture:a,usage:l,isPacked:u}=r;if(a!=null)return;let c=this.activeTimers!=null,p;c&&(p=b.now());let f=r.texShape;if(f==null&&(f=iP(o,u),r.texShape=f),i!=null){let d=Qm(o),h,g=f[1],m=f[0],y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Bs(f[0],f[1])),u?h=new Pv(d,y):h=new Jm(d,y);let x=y?[m,g]:f,v=this.makeTensorInfo(x,s),w=this.texData.get(v.dataId);y?w.usage=Jn.PIXELS:w.usage=Jn.UPLOAD,w.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),g,m,i);let T=[[m,g]],A=this.runWebGLProgram(h,[v],s,T,!0),O=this.texData.get(A.dataId);r.texShape=O.texShape,r.isPacked=O.isPacked,r.usage=O.usage,$().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(r.texture=O.texture,r.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=b.now()-p)}else{let d=this.acquireTexture(f,l,s,u);r.texture=d}}convertAndCacheOnCPU(e,r){let o=this.texData.get(e),{dtype:s}=o;return r!=null&&(o.values=tle(r,s)),o.values}acquireTexture(e,r,o,s){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*b.bytesPerElement(r)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){return z(this,null,function*(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(r));return Promise.all(e)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});e.push(o)}return Promise.all(e)}})}checkCompletionAsync_(e){return z(this,null,function*(){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(yield Nc(),this.checkCompletionAsync_(e))})}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(yE(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=wE(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=o,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,o){e.channels=e.channels||"RGBA";let{texture:s,height:i,width:a,channels:l}=e,u=wo().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=u.writeTexture(s,r,o,i,a,l);return wo().makeTensorFromDataId(c,r,o,u)}}return t.nextDataId=0,t})();function tle(t,n){if(n==="float32"||n==="complex64")return t;if(n==="int32"||n==="bool"){let e=n==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}else throw new Error(`Unknown dtype ${n}`)}_l.isBrowser()&&Lx("webgl",()=>new kB,2);var eh=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Tr=class{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=N.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${n}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Ur=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var Vr=class{constructor(n,e,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=N.assertAndGetBroadcastShape(e,r);let s=this.outputShape.length;this.enableShapeUniforms=ut(s);let i="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ke(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=Yt("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${n}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Zt(t){let{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var AB={kernelName:Ts,backendName:"webgl",kernelFunc:Zt};function Nr(t){let{inputs:n,backend:e}=t,{real:r,imag:o}=n,s=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(s.dataId),a=Zt({inputs:{x:r},backend:e}),l=Zt({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:l},s}var RB={kernelName:Kp,backendName:"webgl",kernelFunc:Nr};var iD="return (a < 0.) ? b * a : a;",aD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function nle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{alpha:s}=r,i=e.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),a=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vr(aD,o.shape,i.shape):new Tr(iD,o.shape,i.shape),l=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),l}var _B={kernelName:nl,backendName:"webgl",kernelFunc:nle};var lD="return (a < 0.) ? b * a : a;",uD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function rle(t){let{inputs:n,backend:e}=t,{x:r,alpha:o}=n,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vr(uD,r.shape,o.shape):new Tr(lD,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],"float32")}var OB={kernelName:ml,backendName:"webgl",kernelFunc:rle};var Ao="if (isnan(x)) return x;";function ge({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),f=e(p.values,l);return a.makeTensorInfo(i.shape,l,f)}let u=$().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&n!=null,c;return u?c=new Sr(i.shape,n):c=new Mn(i.shape,t),a.runWebGLProgram(c,[i],l)}}function rt({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:l,b:u}=i,c=a;if(r&&l.dtype==="complex64"){let h=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[h.complexTensorInfos.real,g.complexTensorInfos.real],[h.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{let[w,T]=v,k={dataId:w.dataId,dtype:w.dtype,shape:l.shape},A={dataId:T.dataId,dtype:T.dtype,shape:u.shape},O=new Tr(t,l.shape,u.shape);return c.runWebGLProgram(O,[k,A],nn(w.dtype,T.dtype))}),x=Nr({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),x}let p=s||nn(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&o!=null){let h=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m=l.dtype==="string"?N.fromUint8ToStringArray(h):h,y=l.dtype==="string"?N.fromUint8ToStringArray(g):g,[x,v]=o(l.shape,u.shape,m,y,p),w=c.makeTensorInfo(v,p),T=c.texData.get(w.dataId);return T.values=x,w}let f=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&n!=null,d;return f?d=new Vr(n,l.shape,u.shape,e):d=new Tr(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],p)}}function ua(t,n=!1){if(t==="linear")return n?SB:xB;if(t==="relu")return n?NB:vB;if(t==="elu")return n?TB:bB;if(t==="relu6")return n?EB:wB;if(t==="prelu")return n?uD:lD;if(t==="leakyrelu")return n?aD:iD;if(t==="sigmoid")return n?DB:CB;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}var th=class{constructor(n,e,r,o=!1,s=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ut(this.outputShape.length);let c=o?n[1]:n[2],p=Math.ceil(c/2),f=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",h=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",y="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",w="rc.x";n[0]<e[0]?v=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(w=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${w};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${g[0]});
          result += (${h[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}};var cD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},og=class{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=N.assertAndGetBroadcastShape(e,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${n}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var FB="return a * b;";function sg(t){let{inputs:n,backend:e}=t,{a:r,b:o}=n,s=N.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),u=new og(cD.REAL,r.shape,o.shape),c=new og(cD.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],f=e.runWebGLProgram(u,p,"float32"),d=e.runWebGLProgram(c,p,"float32"),h=Nr({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}if(e.shouldExecuteOnCPU([r,o])){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),[u,c]=WL(r.shape,o.shape,a.values,l.values,s),p=e.makeTensorInfo(c,s),f=e.texData.get(p.dataId);return f.values=u,p}let i;return $().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Vr(FB,r.shape,o.shape):i=new Tr(FB,r.shape,o.shape),e.runWebGLProgram(i,[r,o],s)}var MB={kernelName:Fi,backendName:"webgl",kernelFunc:sg};function $B(t,n,e){let r=[tu(t.shape),...nu(t.shape)],o={dtype:t.dtype,shape:r,dataId:t.dataId},s=[tu(n),...nu(n)],i=new Jd(s,r),a=!0,l=[r],u=e.runWebGLProgram(i,[o],t.dtype,l,a);return{dataId:u.dataId,shape:n,dtype:u.dtype}}function ee(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{shape:s}=r,i=e,a=b.sizeFromShape(o.shape),l=b.inferFromImplicitShape(s,a),u=b.sizeFromShape(l);b.assert(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!Rc(o.shape,l)&&!(c.texture!==null&&Rc(c.shape,l))?$B(o,l,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}var PB={kernelName:yl,backendName:"webgl",kernelFunc:ee};var ig=class{constructor(n,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a=Math.floor(r/4)*4,l=r%4,u="sumValue += dot(values, ones);";if(e!=null){let p=1/e;u=`sumValue += dot(values * ${b.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var cw=class{constructor(n,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?u="sumValue":e==="prod"?u="prodValue":e==="all"?u="allValue":e==="any"&&(u="anyValue");let c=Math.floor(r/4)*4,p=r%4,f=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";e==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):e==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function sle(t){let n=[];for(;n.length===0||n[n.length-1].outSize!==1;){let e=n.length?n[n.length-1].outSize:t[1],r=N.computeOptimalWindowSize(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}function Gr(t,n,e,r){let o=sle(t.shape),s=t;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:l,outSize:u}=o[i],c,p;e==="mean"?c=i===0?new ig({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new ig({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):c=new cw({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},e),p=s,s=r.runWebGLProgram(c,[s],n),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return s}var pw=class{constructor(n,e){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;let o=ke(this.rank),s=ile(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function ile(t){let n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let o=0;o<t.length;o++)r[t[o]]=e[o];return r.join()}var fw=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ke(this.rank),s=oD("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function ru(t,n,e){let r=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fw(t.shape,n):new pw(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function LB(t,n,e,r){let o=n,s=t.shape.length,i=b.parseAxisParam(o,t.shape),a=i,l=N.getAxesPermutation(a,s),u=l!=null,c=t;u&&(c=ru(t,l,r),a=N.getInnerMostAxes(a.length,s)),N.assertAxesAreInnerMostDims("sum",a,s);let[p,f]=N.computeOutAndReduceShapes(c.shape,a),d=p;e&&(d=N.expandShapeToKeepDim(p,i));let h=b.sizeFromShape(f),m=b.sizeFromShape(t.shape)/h,y=ee({inputs:{x:c},attrs:{shape:[m,h]},backend:r}),x=oc(t.dtype),v=Gr(y,x,"sum",r),w=ee({inputs:{x:v},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),w}function $c(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;return LB(o,s,i,e)}var BB={kernelName:Il,backendName:"webgl",kernelFunc:$c};function At(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{perm:s}=r,i=e,a=o.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=o.shape[s[c]];let u;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,f=Mc(p,o.shape,o.dtype,s,l);u=i.makeTensorInfo(l,o.dtype);let d=i.texData.get(u.dataId);d.values=f}else u=ru(o,s,i);return u}var zB={kernelName:Es,backendName:"webgl",kernelFunc:At};var pD=1e3;function Pc({a:t,b:n,transposeA:e,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){let u=t.shape.length,c=n.shape.length,p=e?t.shape[u-2]:t.shape[u-1],f=r?n.shape[c-1]:n.shape[c-2],d=e?t.shape[u-1]:t.shape[u-2],h=r?n.shape[c-2]:n.shape[c-1],g=t.shape.slice(0,-2),m=n.shape.slice(0,-2),y=b.sizeFromShape(g),x=b.sizeFromShape(m),w=Mr.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([d,h]);b.assert(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);let T=e?[y,p,d]:[y,d,p],k=r?[x,h,f]:[x,f,h],A=ee({inputs:{x:t},backend:o,attrs:{shape:T}}),O=ee({inputs:{x:n},backend:o,attrs:{shape:k}}),M=[A,O],L=Math.max(y,x),V=e?A.shape[1]:A.shape[2],U=s!=null,G=i!=null,j=l==="leakyrelu",H=l!=null?ua(l,!0):null,Y=U||G||j||H!=null,Q;if((d===1||h===1)&&V>pD&&Y===!1){let J=A,re=O;e&&(J=At({inputs:{x:A},backend:o,attrs:{perm:[0,2,1]}}),M.push(J)),r&&(re=At({inputs:{x:O},backend:o,attrs:{perm:[0,2,1]}}),M.push(re));let oe=h!==1,le=h===1,ae=J;oe&&(ae=ee({inputs:{x:J},backend:o,attrs:{shape:[L,V,1]}}),M.push(ae));let fe=h===1?2:1,ce=re;le&&(ce=ee({inputs:{x:re},backend:o,attrs:{shape:[L,1,V]}}),M.push(ce));let me=sg({inputs:{a:ae,b:ce},backend:o});Q=$c({inputs:{x:me},backend:o,attrs:{axis:fe,keepDims:!0}}),M.push(me)}else{let J=nn(t.dtype,n.dtype),re=new th(T,k,[L,d,h],e,r,U,H,G,j),oe=[A,O];if(s!=null&&oe.push(s),G&&oe.push(i),j){let le=o.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));oe.push(le),M.push(le)}Q=o.runWebGLProgram(re,oe,J)}let X=ee({inputs:{x:Q},backend:o,attrs:{shape:w}});M.push(Q);for(let J of M)o.disposeIntermediateTensorInfo(J);return X}function ale(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r;return Pc({a:o,b:s,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var VB={kernelName:Yu,backendName:"webgl",kernelFunc:ale};var UB="return abs(x);";function lle(t){let{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=e.texData.get(r.dataId),i=ow(s.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Sr(r.shape,UB):o=new Mn(r.shape,UB),e.runWebGLProgram(o,[r],r.dtype)}var GB={kernelName:Pa,backendName:"webgl",kernelFunc:lle};var ule=fn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,cle=ge({opSnippet:ule}),WB={kernelName:ai,backendName:"webgl",kernelFunc:cle};var ple=fn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,fle=ge({opSnippet:ple}),jB={kernelName:li,backendName:"webgl",kernelFunc:fle};var HB="return a + b;",dle=rt({opSnippet:HB,packedOpSnippet:HB,supportsComplex:!0,cpuKernelImpl:IL}),qB={kernelName:jo,backendName:"webgl",kernelFunc:dle};var dw=class{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var hw=class{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function mw(t){let{inputs:n,backend:e}=t,r=n;if(r.length===1)return Zt({inputs:{x:r[0]},backend:e});if(r.length>$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(r.length/2),u=mw({inputs:r.slice(0,l),backend:e}),c=mw({inputs:r.slice(l),backend:e});return mw({inputs:[u,c],backend:e})}let o=r.map(l=>l.dtype).reduce((l,u)=>nn(l,u)),s=r.map(l=>l.shape),a=$().getBool("WEBGL_PACK")?new hw(r[0].shape,s):new dw(r[0].shape,s);return e.runWebGLProgram(a,r,o)}var KB={kernelName:La,backendName:"webgl",kernelFunc:mw};function hle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,a)),N.assertAxesAreInnerMostDims("all",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Gr(g,g.dtype,"all",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var XB={kernelName:Up,backendName:"webgl",kernelFunc:hle};function mle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,a)),N.assertAxesAreInnerMostDims("any",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Gr(g,g.dtype,"any",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var YB={kernelName:Gp,backendName:"webgl",kernelFunc:mle};var gw=class{constructor(n,e,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var yw=class{constructor(n,e,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,b.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=n[n.length-1],i=Math.ceil(s/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,l=a.length,u=ke(l),c=Yt("coords",l),p,f;if(i===1){f=l+1;let O=ke(f);p=`
        ${O} sourceLocR = ${O}(${c.join()}, 0);
        ++${c[l-1]};
        ${O} sourceLocG = ${O}(${c.join()}, 0);
        ++${c[l-2]};
        ${O} sourceLocA = ${O}(${c.join()}, 0);
        --${c[l-1]};
        ${O} sourceLocB = ${O}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let d=["x","y","z","w","u","v"].slice(0,f),h="."+d[f-1],g=d.map(O=>"int "+O),m=Yt("sourceLocR",f-1).concat("inIdx.r"),y=Yt("sourceLocG",f-1).concat("inIdx.g"),x=Yt("sourceLocB",f-1).concat("inIdx.b"),v=Yt("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",T=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,A=o?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${T}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function ZB(t,n,e,r=null){let o=n.shape[0],s=n.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=N.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},l=new gw(a,e,r==null),u=[n];r!=null&&u.push(r);let c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=ZB(t,n,e,c);return t.disposeIntermediateTensorInfo(c),p}function QB(t,n,e,r=null){let o=r!=null?r.shape:n.shape,s=o[o.length-1],i=N.computeOptimalWindowSize(s),a=new yw(o,i,e,r==null),l=r==null?[n]:[n,r],u=t.runWebGLProgram(a,l,"int32");if(u.shape.length===n.shape.length){let c=QB(t,n,e,u);return t.disposeIntermediateTensorInfo(u),c}return u}function xw(t,n,e,r){let o=[e];if(N.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,n.shape.length),!$().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){let s=[],i=t.texData.get(n.dataId),a=i!==null&&i.isPacked,l=n;a&&(l=t.unpackTensor(n),s.push(l));let[u,c]=N.computeOutAndReduceShapes(l.shape,o),p=b.sizeFromShape(c),f=ee({inputs:{x:l},backend:t,attrs:{shape:[-1,p]}});s.push(f);let d=ZB(t,f,r);s.push(d);let h=ee({inputs:{x:d},backend:t,attrs:{shape:u}});return s.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}return QB(t,n,r)}function gle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=At({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=xw(e,l,i[0],"max");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var JB={kernelName:Ba,backendName:"webgl",kernelFunc:gle};function yle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=At({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=xw(e,l,i[0],"min");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var ez={kernelName:za,backendName:"webgl",kernelFunc:yle};var xle=fn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ble=ge({opSnippet:xle}),tz={kernelName:ui,backendName:"webgl",kernelFunc:ble};var vle=fn+"return log(x + sqrt(x * x + 1.0));",wle=ge({opSnippet:vle}),nz={kernelName:ci,backendName:"webgl",kernelFunc:wle};var Cle=fn+`
  return atan(x);
`,Ile=ge({opSnippet:Cle}),rz={kernelName:pi,backendName:"webgl",kernelFunc:Ile};var Sle=eh+`
  return atan(a, b);
`,Tle=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ur+`
  return result;
`,Nle=rt({opSnippet:Sle,packedOpSnippet:Tle}),oz={kernelName:di,backendName:"webgl",kernelFunc:Nle};var Ele=fn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Dle=ge({opSnippet:Ele}),sz={kernelName:fi,backendName:"webgl",kernelFunc:Dle};var os=class{constructor(n,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,d=n.padInfo.top,h=n.padInfo.left;this.outputShape=n.outShape;let g=e==="avg",m=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,y=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`,x="0.0";if(g||(x="-1.0 / 1e-20"),r){let O=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${O} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?m:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / max(count, 1.0)");let T=Math.floor(i/4)*4,k=i%4,A=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${h});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${T}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${T};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${w});
      }
    `}},ou=class{constructor(n,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,p=n.dilationHeight,f=n.dilationWidth,d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,g=n.effectiveFilterWidth,m=n.padInfo.front,y=n.padInfo.top,x=n.padInfo.left;this.outputShape=n.outShape;let v=e==="avg",w="0.0";if(v||(w="-1.0 / 1e-20"),r){let L=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${m}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${n.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${h} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let T="max",k=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(k="avgValue / max(count, 1.0)");let A=Math.floor(i/4)*4,O=i%4,M=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${m}, ${y}, ${x});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${A};
            if (${O===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${O===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${O===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${k});
      }
    `}};function kle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;zs(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return Zt({inputs:{x:o},backend:e});let p=new os(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var iz={kernelName:Va,backendName:"webgl",kernelFunc:kle};function Ale(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],p=N.computePool3DInfo(o.shape,s,i,c,a,l,u),f=new ou(p,"avg",!1);return e.runWebGLProgram(f,[o],"float32")}var az={kernelName:Ua,backendName:"webgl",kernelFunc:Ale};var bw=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dilationHeight,a=n.dilationWidth,l=n.effectiveFilterHeight,u=n.effectiveFilterWidth,c=l-1-n.padInfo.top,p=u-1-n.padInfo.left,f=1/(e*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},vw=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let e=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterDepth,f=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=p-1-n.padInfo.front,g=f-1-n.padInfo.top,m=d-1-n.padInfo.left,y=1/(e*r*o);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${g}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rle(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],f=N.computePool3DInfo(i.shape,a,l,p,u,c),d=new vw(f);return e.runWebGLProgram(d,[o],i.dtype)}var lz={kernelName:jp,backendName:"webgl",kernelFunc:Rle};function _le(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s;zs([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=r,c=N.computePool2DInfo(i.shape,a,l,1,u),p=new bw(c);return e.runWebGLProgram(p,[o],i.dtype)}var uz={kernelName:Wp,backendName:"webgl",kernelFunc:_le};function Ole(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;return Pc({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var cz={kernelName:Ga,backendName:"webgl",kernelFunc:Ole};var ww=class{constructor(n,e,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(n,e),N.assertAndGetBroadcastShape(n,r);let a="0.0";o!=null&&(N.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(N.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Cw=class{constructor(n,e,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(n,e),N.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";o!=null&&(N.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(N.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Fle=({inputs:t,backend:n,attrs:e})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=t;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);let u=[r,o,s],c=null;i!=null&&(c=i.shape,u.push(i));let p=null;a!=null&&(p=a.shape,u.push(a));let f=$().getBool("WEBGL_PACK_NORMALIZATION")?new Cw(r.shape,o.shape,s.shape,c,p,l):new ww(r.shape,o.shape,s.shape,c,p,l);return n.runWebGLProgram(f,u,u[0].dtype)},pz={kernelName:el,backendName:"webgl",kernelFunc:Fle};var Iw=class{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;let e=ke(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=Mle(this.rank),o,s=n.map((i,a)=>`sourceLoc.${fD[a]} = start[${a}] + coords.${fD[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},fD=["x","y","z","w","u","v"];function Mle(t){if(t===1)return"sourceLoc";if(t<=6)return fD.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}var Sw=class{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=ke(this.rank),r=Yt("coords",this.rank),o=Yt("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${e}(${n.map((c,p)=>`start[${p}]`).join()});`:n.map((c,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}};function $le(t,n,e,r){let o=r.texData.get(t.dataId),s=r.makeTensorInfo(e,t.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=Sn.computeFlatOffset(n,b.computeStrides(t.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||t.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function ss(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,size:i}=r,[a,l]=Sn.parseSliceParams(o,s,i);if(Sn.assertParamsValid(o,a,l),b.sizeFromShape(l)===0)return e.makeTensorInfo(l,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),f=tB(p.values,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,f)}let{isPacked:u}=e.texData.get(o.dataId),c=Sn.isSliceContinous(o.shape,a,l);if(u||!c){let p=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sw(l):new Iw(l),f=[a];return e.runWebGLProgram(p,[o],o.dtype,f)}return e.uploadToGPU(o.dataId),$le(o,a,l,e)}var fz={kernelName:Cl,backendName:"webgl",kernelFunc:ss};var Ple=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,crops:i}=r;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,v)=>x*v),l=N.getReshaped(o.shape,s,a),u=N.getPermuted(l.length,s.length),c=N.getReshapedPermuted(o.shape,s,a),p=N.getSliceBeginCoords(i,s.length),f=N.getSliceSize(c,i,s.length),d=[],h=ee({inputs:{x:o},backend:e,attrs:{shape:l}}),g=At({inputs:{x:h},backend:e,attrs:{perm:u}}),m=ee({inputs:{x:g},backend:e,attrs:{shape:c}}),y=ss({inputs:{x:m},backend:e,attrs:{begin:p,size:f}});return d.push(h),d.push(g),d.push(m),d.forEach(x=>e.disposeIntermediateTensorInfo(x)),y},dz={kernelName:Wa,backendName:"webgl",kernelFunc:Ple};function Lle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i}=r,a=e.readSync(o.dataId),l=e.readSync(s.dataId),u=rw(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var hz={kernelName:Hp,backendName:"webgl",kernelFunc:Lle};var Ble=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,zle=`
  return float(int(a.r) & int(b.r));
`;function Vle(t){let{inputs:n,backend:e}=t,{a:r,b:o}=n,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=$().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,o])||i===1){let l=e.texData.get(r.dataId).values,u=e.texData.get(o.dataId).values,[c,p]=TL(r.shape,o.shape,l,u,r.dtype),f=e.makeTensorInfo(p,r.dtype),d=e.texData.get(f.dataId);return d.values=c,f}let a;return s?a=new Vr(Ble,r.shape,o.shape,!1):a=new Tr(zle,r.shape,o.shape),e.runWebGLProgram(a,[r,o],r.dtype)}var mz={kernelName:zu,backendName:"webgl",kernelFunc:Vle};function Ule(t){let{inputs:n,backend:e}=t,{s0:r,s1:o}=n,s=e.readSync(r.dataId),i=e.readSync(o.dataId),a=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var gz={kernelName:qp,backendName:"webgl",kernelFunc:Ule};var Gle="return float(a != b);",dD=rt({opSnippet:Gle,cpuKernelImpl:HL,dtype:"bool"}),yz={kernelName:Ku,backendName:"webgl",kernelFunc:dD};function ca(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.texData.get(r.dataId);return Zt({inputs:{x:o.complexTensorInfos.real},backend:e})}var xz={kernelName:Ef,backendName:"webgl",kernelFunc:ca};var Wle="return float(int(x));";function bz(t,n){let e=new Mn(t.shape,Wle),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function hD(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Zt({inputs:{x:o},backend:e});let i=bt(o.shape),a=hD({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),l=Nr({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if(o.dtype==="complex64"){let i=ca({inputs:{input:o},backend:e}),a=hD({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=Zt({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.texData.get(o.dataId).values,[a,l,u]=NL(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,u)}if(s==="int32")return bz(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),l=dD({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var vz={kernelName:Ss,backendName:"webgl",kernelFunc:hD};var wz="return ceil(x);",jle=ge({opSnippet:wz,packedOpSnippet:wz,cpuKernelImpl:EL}),Cz={kernelName:hi,backendName:"webgl",kernelFunc:jle};var Tw=class{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Nw=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Hle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{clipValueMin:s,clipValueMax:i}=r,a;$().getBool("WEBGL_PACK_CLIP")?a=new Nw(o.shape):a=new Tw(o.shape);let l=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,l)}var Iz={kernelName:mi,backendName:"webgl",kernelFunc:Hle};var Ew=class{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function Sz(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}function qle(t){let{inputs:n,backend:e}=t,{x:r}=n,o=e.texData.get(r.dataId),s=new Ew(r.shape),i=[Sz(r,o.complexTensorInfos.real),Sz(r,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var Tz={kernelName:ja,backendName:"webgl",kernelFunc:qle};var Dw=class{constructor(n){this.outputShape=[],this.outputShape=N.computeOutShape(n,1),this.variableNames=n.map((i,a)=>`T${a}`);let e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];let r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};var Aw=class{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=N.computeOutShape(n,e);let r=this.outputShape,o=r.length,s=ke(o),i=Yt("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=n.map((g,m)=>`T${m}`);let l=new Array(n.length-1);l[0]=n[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+n[g][e];let u=a[e],c=a.slice(-2),p=a.join(),f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){let m=l[g-1];f+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${kw(a,u,m)}),
            vec2(${kw(c,u,m)}));
        }`}let d=l.length,h=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${kw(a,u,h)}),
          vec2(${kw(c,u,h)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function kw(t,n,e){let r=t.indexOf(n);return t.map((s,i)=>i===r?`${s} - ${e}`:s).join()}function Lc(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.texData.get(r.dataId);return Zt({inputs:{x:o.complexTensorInfos.imag},backend:e})}var Nz={kernelName:df,backendName:"webgl",kernelFunc:Lc};function nh(t,n,e){let r=t[0].dtype;if(r==="complex64"){let d=t.map(x=>ca({inputs:{input:x},backend:e})),h=t.map(x=>Lc({inputs:{input:x},backend:e})),g=nh(d,n,e),m=nh(h,n,e),y=Nr({inputs:{real:g,imag:m},backend:e});return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),h.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let o=e.shouldExecuteOnCPU(t);if(r==="string"&&(o=!0),o){let d=t.map(w=>{let k=[-1,b.sizeFromShape(w.shape.slice(n))];return ee({inputs:{x:w},backend:e,attrs:{shape:k}})}),h=d.map(w=>({vals:e.readSync(w.dataId),shape:w.shape})),g=N.computeOutShape(d.map(w=>w.shape),1),m=d[0].shape[0]===1,y=DL(h,g,r,m),x=N.computeOutShape(t.map(w=>w.shape),n),v=e.makeTensorInfo(x,r,y);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),v}let s=t.filter(d=>b.sizeFromShape(d.shape)>0),i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let d=i?new Mn(t[0].shape,Us):new Sr(t[0].shape,Us);return e.runWebGLProgram(d,t,r)}let a=$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let d=[];for(let g=0;g<s.length;g+=a){let m=s.slice(g,g+a);d.push(nh(m,n,e))}let h=nh(d,n,e);for(let g of d)e.disposeIntermediateTensorInfo(g);return h}if(i){let d=new Aw(s.map(h=>h.shape),n);return e.runWebGLProgram(d,s,r)}let{tensors2D:l,outShape:u}=Kle(s,n,e),c=new Dw(l.map(d=>d.shape)),p=e.runWebGLProgram(c,l,r);l.forEach(d=>e.disposeIntermediateTensorInfo(d));let f=ee({inputs:{x:p},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(p),f}function Kle(t,n,e){let r=N.computeOutShape(t.map(s=>s.shape),n);return{tensors2D:t.map(s=>ee({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(n))]},backend:e})),outShape:r}}function mD(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r,s=b.parseAxisParam(o,n[0].shape)[0],i=n.map(u=>u.shape);N.assertParamsConsistent(i,s);let a=N.computeOutShape(n.map(u=>u.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,n[0].dtype,[]);let l=n.filter(u=>b.sizeFromShape(u.shape)>0);return l.length===1?Zt({inputs:{x:l[0]},backend:e}):nh(l,s,e)}var Ez={kernelName:Ha,backendName:"webgl",kernelFunc:mD};var rh=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;let i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,p=n.dilationWidth,f=n.filterHeight,d=n.filterWidth,h=Math.floor(n.inChannels/4)*4,g=n.inChannels%4,m=n.dataFormat==="channelsLast",y=m?1:2,x=m?2:3,v=m?3:1,w="",T="";r&&(o?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,T="result = activation(result);");let k=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${n.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${T}
        setOutput(result);
      }
    `}},Rw=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let e=n.padInfo.front,r=n.padInfo.top,o=n.padInfo.left,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,p=n.filterDepth,f=n.filterHeight,d=n.filterWidth,h=Math.floor(n.inChannels/4)*4,g=n.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var oh=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ut(this.outputShape.length);let i=n.padInfo.left,a=n.strideWidth,l=n.dilationWidth,u=n.filterHeight,c=n.filterWidth,p=c,f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)f+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)f+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(p+1)/2;m++){let y=m*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let x=i%2===0?b.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${n.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${n.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",h="";r&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${h}
         setOutput(result);
       }
     `}};var _w=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=ut(this.outputShape.length);let{dataFormat:r}=e,o=zt(),s=r==="channelsLast",i=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`,u="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${o.output} = result;
      }
    `}};function Ow(t,n){let e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&e===1&&t[0]>1?[t[0],1]:null}function Fw({x:t,filter:n,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let l=t.shape,u=r.texData.get(t.dataId),c=e.inChannels,p=l[0]*l[1]*l[2],f=e.outChannels,d=e.dataFormat==="channelsLast",h=!1,g=!1,m,y=[];if(s!=null){let w=Ow(s.shape,d);w!=null&&(s=ee({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(o!=null){let w=Ow(o.shape,d);w!=null&&(o=ee({inputs:{x:o},backend:r,attrs:{shape:w}}),y.push(o))}if(!((p===1||f===1)&&c>pD)&&u.isPacked&&d&&u.texture!=null&&l[2]%2!==0&&b.arraysEqual(u.shape.slice(-3),l.slice(-3))){let w=l[0]*l[1]*(l[2]+1),T={dataId:t.dataId,shape:[1,w,e.inChannels],dtype:t.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,b.assert(Rc(u.shape,T.shape),()=>`packed reshape ${u.shape} to ${T.shape} isn't free`);let A=ee({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(A);let O=Pc({a:T,b:A,backend:r,transposeA:h,transposeB:g,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),M=r.texData.get(O.dataId);b.assert(M.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,M.shape=e.outShape,m=Zt({inputs:{x:O},backend:r}),m.shape=e.outShape,y.push(O)}else{let w=e.outHeight*e.outWidth,T=ee({inputs:{x:t},backend:r,attrs:{shape:d?[e.batchSize,w,e.inChannels]:[e.batchSize,e.inChannels,w]}}),k=ee({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),A=Pc({a:d?T:k,b:d?k:T,transposeA:!d,transposeB:g,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});m=ee({inputs:{x:A},backend:r,attrs:{shape:e.outShape}}),y.push(T),y.push(k),y.push(A)}for(let w of y)r.disposeIntermediateTensorInfo(w);return m}function Mw({x:t,filter:n,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:f,dataFormat:d}=e,h=d==="channelsLast",g=l*u*c,m=f*p,y=[e.batchSize,g,m],x=!0,v=!1,w=[];if(s!=null){let X=Ow(s.shape,h);X!=null&&(s=ee({inputs:{x:s},backend:r,attrs:{shape:X}}),w.push(s))}if(o!=null){let X=Ow(o.shape,h);X!=null&&(o=ee({inputs:{x:o},backend:r,attrs:{shape:X}}),w.push(o))}let T=ee({inputs:{x:n},backend:r,attrs:{shape:[1,g,b.sizeFromShape(n.shape)/g]}});w.push(T);let k=new _w(y,e),A=[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],O=r.runWebGLProgram(k,[t],"float32",A),M=ee({inputs:{x:O},backend:r,attrs:{shape:y}});w.push(O),w.push(M);let L=o!=null,V=s!=null,U=a==="leakyrelu",G=a?ua(a,!0):null,j=new th(h?M.shape:T.shape,h?T.shape:M.shape,h?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],x,v,L,G,V,U),H=h?[M,T]:[T,M];if(o&&H.push(o),V&&H.push(s),U){let X=r.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));H.push(X),w.push(X)}let Y=r.runWebGLProgram(j,H,"float32"),Q=ee({inputs:{x:Y},backend:r,attrs:{shape:e.outShape}});w.push(Y);for(let X of w)r.disposeIntermediateTensorInfo(X);return Q}function Xle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=Fw({x:o,filter:s,convInfo:f,backend:e});else if(f.strideWidth<=2&&p==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let g=new oh(f),m=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=e.runWebGLProgram(g,[o,s],"float32",m)}else if($().getBool("WEBGL_CONV_IM2COL"))d=Mw({x:o,filter:s,convInfo:f,backend:e});else{let g=new rh(f);d=e.runWebGLProgram(g,[o,s],"float32")}let h=ee({inputs:{x:d},backend:e,attrs:{shape:f.outShape}});return e.disposeIntermediateTensorInfo(d),h}var Dz={kernelName:qa,backendName:"webgl",kernelFunc:Xle};var $w=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Pw=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dataFormat==="channelsLast",a=e-1-n.padInfo.top,l=r-1-n.padInfo.left,u=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Lw=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.padInfo.front,i=n.padInfo.top,a=n.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yF = 0; yF < ${n.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${n.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${n.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${n.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bw=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=e-1-n.padInfo.front,u=r-1-n.padInfo.top,c=o-1-n.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Yle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),d=new $w(f);return e.runWebGLProgram(d,[o,s],"float32")}var kz={kernelName:Xp,backendName:"webgl",kernelFunc:Yle};var zw=class{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=ut(this.outputShape.length);let e=n.filterHeight,r=n.filterWidth,o=e-1-n.padInfo.top,s=r-1-n.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Zle(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,p=N.convertConv2DDataFormat(u),f=N.computeConv2DInfo(i,s.shape,a,1,l,c,!1,p);if($().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let d=[[f.strideHeight,f.strideWidth]],h=new zw(f);return e.runWebGLProgram(h,[o,s],"float32",d)}else{let d=new Pw(f);return e.runWebGLProgram(d,[o,s],"float32")}}var Az={kernelName:Ka,backendName:"webgl",kernelFunc:Zle};function Qle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r,u=N.computeConv3DInfo(o.shape,s.shape,i,l,a),c=new Rw(u);return e.runWebGLProgram(c,[o,s],"float32")}var Rz={kernelName:Xa,backendName:"webgl",kernelFunc:Qle};function Jle(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:l}=r,u=N.computeConv3DInfo(o.shape,l,i,1,a),c=new Lw(u);return e.runWebGLProgram(c,[o,s],"float32")}var _z={kernelName:Yp,backendName:"webgl",kernelFunc:Jle};function eue(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:l}=r,u=N.computeConv3DInfo(l,s.shape,a,1,i),c=new Bw(u);return e.runWebGLProgram(c,[o,s],"float32")}var Oz={kernelName:Zp,backendName:"webgl",kernelFunc:eue};var tue=Ao+`
  return cos(x);
`,nue=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ur}
  return result;
`,rue=ge({opSnippet:tue,packedOpSnippet:nue}),Fz={kernelName:gi,backendName:"webgl",kernelFunc:rue};var oue=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,sue=ge({opSnippet:oue}),Mz={kernelName:yi,backendName:"webgl",kernelFunc:sue};var Vw=class{constructor(n,e,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,l,u]=n,[c]=e,[p,f]=r;this.outputShape=[c,p,f,u];let d=o==="bilinear"?1:0,[h,g]=[`${a-1}.0`,`${l-1}.0`],[m,y,x]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[v,w,T]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${T};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var iue=t=>{let{inputs:n,backend:e,attrs:r}=t,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new Vw(o.shape,s.shape,a,l,u);return e.runWebGLProgram(c,[o,s,i],"float32")},$z={kernelName:Jp,backendName:"webgl",kernelFunc:iue};var sh=function(t){return t.Prod="*",t.Sum="+",t}(sh||{}),ag=class{constructor(n,e,r,o){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===sh.Prod?"1.0":"0.0",a=r?i:`getX(${Pz(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1],u="",c="";r?(u=o?`end != ${l-1}`:"end != 0",c=o?"end + 1":"end - 1"):(u=o?`end + pow2 < ${l}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ke(s)} coords = getOutputCoords();
        int end = ${Lz(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${Lz(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Pz(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Pz(t,n,e){if(t===1)return`${n}`;if(t===2)return`${n}.x, ${n}.y`;if(t===3)return`${n}.x, ${n}.y, ${n}.z`;if(t===4)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function Lz(t,n,e){if(t===1)return`${n}`;if(t===2)return`${n}.y`;if(t===3)return`${n}.z`;if(t===4)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function Uw(t,n,e,r,o,s){let i=n.shape.length,a=N.getAxesPermutation([r],i),l=n;a!=null&&(l=At({inputs:{x:n},backend:e,attrs:{perm:a}}));let u=N.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);let c=l.shape[u],p=Zt({inputs:{x:l},backend:e});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){let d=new ag(t,l.shape,!1,s),h=[[f]],g=p;p=e.runWebGLProgram(d,[p],p.dtype,h),e.disposeIntermediateTensorInfo(g)}if(o){let f=new ag(t,l.shape,o,s),d=p;p=e.runWebGLProgram(f,[p],p.dtype),e.disposeIntermediateTensorInfo(d)}if(a!=null){let f=N.getUndoAxesPermutation(a),d=At({inputs:{x:p},backend:e,attrs:{perm:f}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),d}return p}function aue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return Uw(sh.Prod,o,e,s,i,a)}var Bz={kernelName:Qp,backendName:"webgl",kernelFunc:aue};function lue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return Uw(sh.Sum,o,e,s,i,a)}var zz={kernelName:Ya,backendName:"webgl",kernelFunc:lue};function uue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.readSync(o.dataId),u=e.readSync(s.dataId),c=rw(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=e.bufferSync(o),u=e.bufferSync(s),c=SL(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Vz={kernelName:ef,backendName:"webgl",kernelFunc:uue};var Gw=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function cue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockSize:s,dataFormat:i}=r,a=o.shape[0],l=i==="NHWC"?o.shape[1]:o.shape[2],u=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=l*s,f=u*s,d=c/(s*s),h=i==="NHWC"?[a,p,f,d]:[a,d,p,f],g=new Gw(h,s,i);return e.runWebGLProgram(g,[o],o.dtype)}var Uz={kernelName:tf,backendName:"webgl",kernelFunc:cue};var ih=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ut(this.outputShape.length);let i=n.filterHeight,a=n.filterWidth,l=n.outChannels/n.inChannels,u="",c="";r&&(o?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var ah=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ut(this.outputShape.length);let i=n.outChannels/n.inChannels,a=n.padInfo.left,l=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,p=n.filterWidth,f=p,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){let x=y*2;if(d+=`
          xC = xCCorner + ${x*u};
          `,l===1){if(x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,u===1&&x>0?d+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<p)){let v=a%2===0?b.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,u>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:d+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):v===1?d+=`
                    xC${x+1} = xTexelC${x};
                    `:d+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<p&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<p&&(d+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<p&&(d+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<p&&(d+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let h="",g="";r&&(o?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:h=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");let m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}};function pue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=N.computeConv2DInfo(o.shape,s.shape,i,c,a,u,!0),f;$().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?f=new ah(p):f=new ih(p);let d=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(f,[o,s],"float32",d)}var Gz={kernelName:Za,backendName:"webgl",kernelFunc:pue};var Ww=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},jw=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=e-1-n.padInfo.top,a=r-1-n.padInfo.left,l=n.outChannels/n.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function fue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,p=N.computeConv2DInfo(o.shape,c,i,a,l,u,!0),f=new Ww(p);return e.runWebGLProgram(f,[o,s],"float32")}var Wz={kernelName:nf,backendName:"webgl",kernelFunc:fue};function due(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,p=N.computeConv2DInfo(c,s.shape,i,a,l,u,!0),f=new jw(p);return e.runWebGLProgram(f,[o,s],"float32")}var jz={kernelName:rf,backendName:"webgl",kernelFunc:due};var Hw=class{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function hue(t){let{inputs:n,backend:e}=t,{x:r}=n,o=[...r.shape,...r.shape],s=b.sizeFromShape(r.shape),i=ee({inputs:{x:r},backend:e,attrs:{shape:[s]}}),a=new Hw(s),l=e.runWebGLProgram(a,[i],i.dtype),u=ee({inputs:{x:l},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}var Hz={kernelName:of,backendName:"webgl",kernelFunc:hue};var qw=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let{inHeight:e,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:p,left:f}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function mue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r,u=N.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",l),c,p=new qw(u);c=e.runWebGLProgram(p,[o,s],"float32");let f=ee({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),f}var qz={kernelName:Qa,backendName:"webgl",kernelFunc:mue};function gue(t){let{inputs:n,backend:e,attrs:r}=t,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:l}=N.decodeEinsumEquation(o,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=N.getEinsumComputePath(a,l),p=c.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of c[g]){let{permutationIndices:y,expandDims:x}=N.getEinsumPermutation(d,l[m]),v;N.isIdentityPermutation(y)?v=s[m]:(v=At({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(v));let w=v.shape.slice();for(let T=0;T<x.length;++T)w.splice(x[T],0,1);b.arraysEqual(v.shape,w)||(v=ee({inputs:{x:v},backend:e,attrs:{shape:w}}),h.push(v)),f===null?f=v:(f=sg({inputs:{a:v,b:f},backend:e}),h.push(f))}g<p-1&&(u[g]>=0&&(f=$c({inputs:{x:f},backend:e,attrs:{axis:u[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var Kz={kernelName:sf,backendName:"webgl",kernelFunc:gue};var yue="return (x >= 0.0) ? x : (exp(x) - 1.0);",xue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bue=ge({opSnippet:yue,packedOpSnippet:xue}),Xz={kernelName:bi,backendName:"webgl",kernelFunc:bue};var vue="return (b >= 0.0) ? a : a * (b + 1.0);",wue=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Cue=t=>{let{inputs:n,backend:e}=t,{dy:r,y:o}=n,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vr(wue,r.shape,o.shape):new Tr(vue,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],r.dtype)},Yz={kernelName:af,backendName:"webgl",kernelFunc:Cue};var Iue=`
  return vec4(equal(a, b));
`,Sue="return float(a == b);",Tue=rt({opSnippet:Sue,packedOpSnippet:Iue,dtype:"bool",cpuKernelImpl:kL}),Zz={kernelName:Vu,backendName:"webgl",kernelFunc:Tue};var Nue=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${N.ERF_P};
  float a1 = ${N.ERF_A1};
  float a2 = ${N.ERF_A2};
  float a3 = ${N.ERF_A3};
  float a4 = ${N.ERF_A4};
  float a5 = ${N.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Eue=ge({opSnippet:Nue}),Qz={kernelName:vi,backendName:"webgl",kernelFunc:Eue};var Due=Ao+`
  return exp(x);
`,kue=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gD=ge({opSnippet:Due,packedOpSnippet:kue,cpuKernelImpl:AL,dtype:"float32"}),Jz={kernelName:wi,backendName:"webgl",kernelFunc:gD};function Kw(t){let{inputs:n,attrs:e,backend:r}=t,{dim:o}=e,{input:s}=n,i=s.shape.length,a=s.shape.slice(),l=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),ee({inputs:{x:s},backend:r,attrs:{shape:a}})}var eV={kernelName:Ja,backendName:"webgl",kernelFunc:Kw};var tV="return exp(x) - 1.0;",Aue=ge({opSnippet:tV,packedOpSnippet:tV,cpuKernelImpl:RL}),nV={kernelName:Ci,backendName:"webgl",kernelFunc:Aue};var lg=class{constructor(n,e,r){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(n==="real")a="return real * expR - imag * expI;";else if(n==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Xw(t,n,e){let r=e.texData.get(t.dataId),o=b.sizeFromShape(t.shape),s=t.shape[t.shape.length-1],i=o/s,a=ee({inputs:{x:t},backend:e,attrs:{shape:[i,s]}}),l=a.shape,u=new lg("real",l,n),c=new lg("imag",l,n),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=e.runWebGLProgram(u,p,"float32"),d=e.runWebGLProgram(c,p,"float32"),h=Nr({inputs:{real:f,imag:d},backend:e});e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d);let g=ee({inputs:{x:h},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(h),g}function Rue(t){let{inputs:n,backend:e}=t,{input:r}=n;return Xw(r,!1,e)}var rV={kernelName:lf,backendName:"webgl",kernelFunc:Rue};var Yw=class{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function pa(t){let{backend:n,attrs:e}=t,{shape:r,value:o}=e,{dtype:s}=e;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(r));return i.fill(o),n.makeTensorInfo(r,s,i)}else{let i=new Yw(r,o),a=[[o]];return n.runWebGLProgram(i,[],s,a)}}var oV={kernelName:uf,backendName:"webgl",kernelFunc:pa};var Zw=class{constructor(n){this.variableNames=["Image"],this.outputShape=[];let e=n[2];this.outputShape=n,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var sV={kernelName:cf,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{let{image:e}=t,r=n,o=new Zw(e.shape);return r.runWebGLProgram(o,[e],e.dtype)}};var iV="return floor(x);",_ue=ge({opSnippet:iV,packedOpSnippet:iV,cpuKernelImpl:_L}),aV={kernelName:Ii,backendName:"webgl",kernelFunc:_ue};var Oue=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Fue=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Mue=rt({opSnippet:Oue,packedOpSnippet:Fue,dtype:"int32"}),lV={kernelName:Si,backendName:"webgl",kernelFunc:Mue};var Qw=class{constructor(n){this.variableNames=["A"];let e=zt(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Jw=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=zt(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var uV={kernelName:Sm,backendName:"webgl",kernelFunc:$ue},lh,yD=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function $ue(t){let{inputs:n,backend:e,attrs:r}=t,{pixels:o}=n,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[l,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[u,l],p=[u,l,s];if(a||i){let g=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(lh==null||g!==yD)&&(yD=g,lh=document.createElement("canvas").getContext("2d",{willReadFrequently:yD})),lh.canvas.width=l,lh.canvas.height=u,lh.drawImage(o,0,0,l,u),o=lh.canvas}let f=e.makeTensorInfo(c,"int32");e.texData.get(f.dataId).usage=Jn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId),o);let d=$().getBool("WEBGL_PACK")?new Jw(p):new Qw(p),h=e.runWebGLProgram(d,[f],"int32");return e.disposeData(f.dataId),h}function Pue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=N.convertConv2DDataFormat(c),m=N.computeConv2DInfo(o.shape,s.shape,l,p,u,f,!1,g),y,x=[],v=i!=null,w=a!=null,T=d==="leakyrelu",k=()=>{let O=[o,s],M=(L,V)=>{if(V==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let U=ee({inputs:{x:L},backend:e,attrs:{shape:[L.shape[0],1,1]}});return x.push(U),U}return L};if(v&&O.push(M(i,c)),w&&O.push(M(a,c)),T){let L=e.makeTensorInfo([],"float32",b.createScalarValue(h,"float32"));O.push(L),x.push(L)}return O};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=Fw({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else if(m.strideWidth<=2&&g==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let O=d?ua(d,!0):null,M=new oh(m,v,O,w,T),L=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],V=k();y=e.runWebGLProgram(M,V,"float32",L)}else if($().getBool("WEBGL_CONV_IM2COL"))y=Mw({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else{let O=d?ua(d,!1):null,M=new rh(m,v,O,w,T),L=k();y=e.runWebGLProgram(M,L,"float32")}let A=ee({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return x.push(y),x.forEach(O=>e.disposeIntermediateTensorInfo(O)),A}var cV={kernelName:Zu,backendName:"webgl",kernelFunc:Pue};function Lue(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:d}=r,h=[],g=c;g==null&&(g=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let m=N.computeConv2DInfo(o.shape,s.shape,l,g,u,p,!0),y=$().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=f?ua(f,y):null,v=[o,s],w=i!=null,T=a!=null,k=f==="leakyrelu";if(w&&v.push(i),T&&v.push(a),k){let L=e.makeTensorInfo([],"float32",b.createScalarValue(d,"float32"));v.push(L),h.push(L)}let A;y?A=new ah(m,w,x,T,k):A=new ih(m,w,x,T,k);let O=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],M=e.runWebGLProgram(A,v,"float32",O);return h.forEach(L=>e.disposeIntermediateTensorInfo(L)),M}var pV={kernelName:Qu,backendName:"webgl",kernelFunc:Lue};var eC=class{constructor(n,e,r,o){this.sliceDim=n,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=ke(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Bue(t){let{inputs:n,backend:e}=t,{params:r,indices:o}=n,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(r.shape),[l,u,c,p]=N.prepareAndValidate(r,o),f=ee({inputs:{x:o},backend:e,attrs:{shape:[u,i]}}),d=ee({inputs:{x:r},backend:e,attrs:{shape:[b.sizeFromShape(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let y=e.readSync(o.dataId),x=e.bufferSync(r),v=OL(y,x,r.dtype,u,i,c,p,r.shape,a);return e.makeTensorInfo(l,r.dtype,v.values)}let h=new eC(i,p,[u,c],r.shape),g=e.runWebGLProgram(h,[d,f],d.dtype),m=ee({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),m}var fV={kernelName:pf,backendName:"webgl",kernelFunc:Bue};var tC=class{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let r=ke(this.rank),o=zue(n,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function zue(t,n){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<t.length;o++)o===2?r.push("index"):r.push(`${e[o]}`);return r.join()}function xD(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,indices:s}=n,{axis:i,batchDims:a}=r,l=b.parseAxisParam(i,o.shape)[0];if($().get("DEBUG")){let x=e.readSync(s.dataId),v=o.shape[l];for(let w=0;w<x.length;++w){let T=x[w];b.assert(T<=v-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${v-1}]`)}}let u=N.segment_util.collectGatherOpShapeInfo(o,s,l,a),c=b.sizeFromShape(s.shape),p=[],f=ee({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=ee({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(f),p.push(d);let h=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let x=e.bufferSync(d),v=e.bufferSync(f),w=FL(v,x,h);return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(u.outputShape,w.dtype,w.values)}let g=new tC(f.shape,h),m=e.runWebGLProgram(g,[f,d],f.dtype);p.push(m);let y=ee({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}var dV={kernelName:tl,backendName:"webgl",kernelFunc:xD};var Vue="return float(a > b);",Uue=`
  return vec4(greaterThan(a, b));
`,Gue=rt({opSnippet:Vue,packedOpSnippet:Uue,cpuKernelImpl:ML,dtype:"bool"}),hV={kernelName:Uu,backendName:"webgl",kernelFunc:Gue};var Wue="return float(a >= b);",jue=`
  return vec4(greaterThanEqual(a, b));
`,Hue=rt({opSnippet:Wue,packedOpSnippet:jue,dtype:"bool",cpuKernelImpl:$L}),mV={kernelName:Ti,backendName:"webgl",kernelFunc:Hue};function que(t){let{inputs:n,backend:e}=t,{input:r}=n;return Xw(r,!0,e)}var gV={kernelName:ff,backendName:"webgl",kernelFunc:que};var Kue="return float(!isnan(x) && !isinf(x));",Xue=ge({opSnippet:Kue,dtype:"bool"}),yV={kernelName:Ni,backendName:"webgl",kernelFunc:Xue};var Yue="return float(isinf(x));",Zue=ge({opSnippet:Yue,dtype:"bool"}),xV={kernelName:Ei,backendName:"webgl",kernelFunc:Zue};var Que="return float(isnan(x));",Jue=ge({opSnippet:Que,dtype:"bool"}),bV={kernelName:Di,backendName:"webgl",kernelFunc:Jue};var ece="return float(a < b);",tce=`
  return vec4(lessThan(a, b));
`,nce=rt({opSnippet:ece,packedOpSnippet:tce,cpuKernelImpl:PL,dtype:"bool"}),vV={kernelName:Gu,backendName:"webgl",kernelFunc:nce};var rce="return float(a <= b);",oce=`
  return vec4(lessThanEqual(a, b));
`,sce=rt({opSnippet:rce,packedOpSnippet:oce,cpuKernelImpl:LL,dtype:"bool"}),wV={kernelName:Wu,backendName:"webgl",kernelFunc:sce};function ice(t){let{backend:n,attrs:e}=t,{start:r,stop:o,num:s}=e,i=BL(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var CV={kernelName:hf,backendName:"webgl",kernelFunc:ice};var ace=Ao+`
  return x < 0.0 ? 0./0. : log(x);
`,lce=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,uce=ge({opSnippet:ace,packedOpSnippet:lce,cpuKernelImpl:zL}),IV={kernelName:ki,backendName:"webgl",kernelFunc:uce};var cce=Ao+`
  return log(1.0 + x);
`,pce=ge({opSnippet:cce}),SV={kernelName:Ai,backendName:"webgl",kernelFunc:pce};var fce="return float(a >= 1.0 && b >= 1.0);",dce=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,hce=rt({opSnippet:fce,packedOpSnippet:dce,dtype:"bool"}),TV={kernelName:ju,backendName:"webgl",kernelFunc:hce};var mce="return float(!(x >= 1.0));",gce=ge({opSnippet:mce}),NV={kernelName:Hu,backendName:"webgl",kernelFunc:gce};var yce="return float(a >= 1.0 || b >= 1.0);",xce=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bce=rt({opSnippet:yce,packedOpSnippet:xce,dtype:"bool"}),EV={kernelName:qu,backendName:"webgl",kernelFunc:bce};var nC=class{constructor(n,e,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=n[3]-1;this.outputShape=n;let l,u=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var rC=class{constructor(n,e,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=n[3]-1;this.outputShape=n;let l,u=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var vce=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:l}=r,u=$().getBool("WEBGL_PACK_NORMALIZATION")?new rC(o.shape,s,i,a,l):new nC(o.shape,s,i,a,l);return e.runWebGLProgram(u,[o],o.dtype)},DV={kernelName:rl,backendName:"webgl",kernelFunc:vce};var oC=class{constructor(n,e,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var wce=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,p=new oC(o.shape,a,l,u,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},kV={kernelName:mf,backendName:"webgl",kernelFunc:wce};function AV(t,n,e,r){let o=b.sizeFromShape(n),i=b.sizeFromShape(t.shape)/o,a=ee({inputs:{x:t},attrs:{shape:[i,o]},backend:r}),l=Gr(a,t.dtype,"max",r),u=ee({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}function bD(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=c!=null,f=e.shouldExecuteOnCPU([o]),d=o;if(p){if(f){let v=e.texData.get(d.dataId).values,w=new Array(a);for(let A=0;A<w.length;A++)w[A]=o.shape[c[A]];let T=Mc(v,o.shape,o.dtype,c,w);d=e.makeTensorInfo(w,o.dtype);let k=e.texData.get(d.dataId);k.values=T}else d=ru(o,c,e);u=N.getInnerMostAxes(u.length,a)}N.assertAxesAreInnerMostDims("max",u,a);let[h,g]=N.computeOutAndReduceShapes(d.shape,u),m=h;i&&(m=N.expandShapeToKeepDim(h,l));let y;if(f){let v=e.texData.get(d.dataId).values,w=VL(v,b.sizeFromShape(g),m,o.dtype);y=e.makeTensorInfo(m,o.dtype);let T=e.texData.get(y.dataId);T.values=w}else y=AV(d,g,m,e);return p&&e.disposeIntermediateTensorInfo(d),y}var RV={kernelName:ol,backendName:"webgl",kernelFunc:bD};var Cce=eh+`
  return max(a, b);
`,Ice=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ur+`
  return result;
`,Sce=rt({opSnippet:Cce,packedOpSnippet:Ice,cpuKernelImpl:UL}),_V={kernelName:Ri,backendName:"webgl",kernelFunc:Sce};function Tce(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;zs(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return Zt({inputs:{x:o},backend:e});let p=new os(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var OV={kernelName:sl,backendName:"webgl",kernelFunc:Tce};function Nce(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],p=N.computePool3DInfo(o.shape,s,i,c,a,u,l),f=new ou(p,"max",!1);return e.runWebGLProgram(f,[o],o.dtype)}var FV={kernelName:il,backendName:"webgl",kernelFunc:Nce};var sC=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let e=n.strideHeight,r=n.strideWidth,o=n.dilationHeight,s=n.effectiveFilterHeight,i=n.effectiveFilterWidth,a=s-1-n.padInfo.top,l=i-1-n.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},iC=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let e=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.dilationDepth,i=n.dilationHeight,a=n.dilationWidth,l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth,p=l-1-n.padInfo.front,f=u-1-n.padInfo.top,d=c-1-n.padInfo.left,h=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Ece(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],f=N.computePool3DInfo(i.shape,a,l,p,u,c),d=new ou(f,"max",!0),h=e.runWebGLProgram(d,[i],i.dtype),g=new iC(f),m=e.runWebGLProgram(g,[o,h],i.dtype);return e.disposeIntermediateTensorInfo(h),m}var MV={kernelName:yf,backendName:"webgl",kernelFunc:Ece};function Dce(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s,output:i}=n,a=s;zs([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,f=N.computePool2DInfo(a.shape,l,u,1,c,p),d=!0,h=new os(f,"max",d),g=e.runWebGLProgram(h,[a],a.dtype),m=new sC(f),y=e.runWebGLProgram(m,[o,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}var $V={kernelName:gf,backendName:"webgl",kernelFunc:Dce};function PV(t,n,e,r){let o=new os(e,"max",!1),s=r.runWebGLProgram(o,[t],"float32");o=new os(e,"max",!0,!0,n);let i=r.runWebGLProgram(o,[t],"float32");return[s,i]}var LV={kernelName:xf,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,l=e;b.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];b.assert(N.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=N.computePool2DInfo(r.shape,o,s,u,i),[p,f]=PV(r,a,c,l);return[p,f]}};function BV(t,n,e,r){let o=b.sizeFromShape(n),i=b.sizeFromShape(t.shape)/o,a=ee({inputs:{x:t},attrs:{shape:[i,o]},backend:r}),l=Gr(a,"float32","mean",r),u=ee({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}var zV={kernelName:al,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{keepDims:o,axis:s}=n,i=e,a=r.shape.length,l=b.parseAxisParam(s,r.shape),u=l,c=N.getAxesPermutation(u,a),p=c!=null,f=i.shouldExecuteOnCPU([r]),d=[],h=r;if(p){if(f){let w=i.texData.get(h.dataId).values,T=new Array(a);for(let O=0;O<T.length;O++)T[O]=r.shape[c[O]];let k=Mc(w,r.shape,r.dtype,c,T);h=i.makeTensorInfo(T,r.dtype);let A=i.texData.get(h.dataId);A.values=k}else h=ru(r,c,i);d.push(h),u=N.getInnerMostAxes(u.length,a)}N.assertAxesAreInnerMostDims("sum",u,a);let[g,m]=N.computeOutAndReduceShapes(h.shape,u),y=g;o&&(y=N.expandShapeToKeepDim(g,l));let x=BV(h,m,y,i);for(let v of d)i.disposeIntermediateTensorInfo(v);return x}};function kce(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,o.shape.length)),N.assertAxesAreInnerMostDims("min",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Gr(g,g.dtype,"min",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var VV={kernelName:ll,backendName:"webgl",kernelFunc:kce};var Ace=eh+`
  return min(a, b);
`,Rce=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ur+`
  return result;
`,_ce=rt({opSnippet:Ace,packedOpSnippet:Rce,cpuKernelImpl:GL}),UV={kernelName:_i,backendName:"webgl",kernelFunc:_ce};var aC=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+n[p]+c[1]);let o=n.length,s=ke(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+n[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),u=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var lC=class{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((h,g)=>h[0]+n[g]+h[1]);let o=n.length,s=ke(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+n[g]).join(","),l=Yt("rc",o),u=Yt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=r==="reflect"?0:1,d="";if(o===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[o-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Oce=({inputs:t,backend:n,attrs:e})=>{let{x:r}=t,{paddings:o,mode:s}=e,i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lC(r.shape,o,s):new aC(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)},GV={kernelName:ul,backendName:"webgl",kernelFunc:Oce};var Fce=`if (b == 0.0) return NAN;
  return mod(a, b);`,Mce=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ur+`
  return result;
`,$ce=rt({opSnippet:Fce,packedOpSnippet:Mce}),WV={kernelName:Oi,backendName:"webgl",kernelFunc:$ce};var uC=class{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var Pce=`
if (a == b) {
  return 1.0;
};
return a / b;`,Lce=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,vD=rt({opSnippet:Pce,packedOpSnippet:Lce,checkOutOfBounds:!0}),jV={kernelName:xi,backendName:"webgl",kernelFunc:vD};var HV="return a - b;",wD=rt({opSnippet:HV,packedOpSnippet:HV,supportsComplex:!0,cpuKernelImpl:cB}),qV={kernelName:Xi,backendName:"webgl",kernelFunc:wD};function CD(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{dim:s}=r,i=b.parseAxisParam([s],o.shape),a=bD({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=N.expandShapeToKeepDim(a.shape,i),u=ee({inputs:{x:a},backend:e,attrs:{shape:l}}),c=wD({inputs:{a:o,b:u},backend:e}),p=gD({inputs:{x:c},backend:e}),f=$c({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),d=ee({inputs:{x:f},backend:e,attrs:{shape:l}}),h=vD({inputs:{a:p,b:d},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}var KV={kernelName:Nl,backendName:"webgl",kernelFunc:CD};function Bce(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r,l=a?o:CD({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new uC(u,c,s),f=[[i]],d=e.runWebGLProgram(p,[l],"int32",f);return a||e.disposeIntermediateTensorInfo(l),d}var XV={kernelName:bf,backendName:"webgl",kernelFunc:Bce};var zce=fn+`
  return -x;
`,Vce=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Uce(t){let{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){let s=e.texData.get(r.dataId),[i,a]=jL(s.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Sr(r.shape,Vce):o=new Mn(r.shape,zce),e.runWebGLProgram(o,[r],r.dtype)}var YV={kernelName:cl,backendName:"webgl",kernelFunc:Uce};var Gce=Wn.nonMaxSuppressionV3Impl;function Wce(t){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=Gce(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var ZV={kernelName:vf,backendName:"webgl",kernelFunc:Wce};var jce=Wn.nonMaxSuppressionV4Impl;function Hce(t){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:f,validOutputs:d}=jce(c,p,i,a,l,u);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var QV={kernelName:wf,backendName:"webgl",kernelFunc:Hce};var qce=Wn.nonMaxSuppressionV5Impl;function Kce(t){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(o.dataId),p=e.readSync(s.dataId),f=i,d=a,h=l,g=u,{selectedIndices:m,selectedScores:y}=qce(c,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var JV={kernelName:Cf,backendName:"webgl",kernelFunc:Kce};var cC=class{constructor(n,e,r,o){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var Xce=t=>{let{inputs:n,backend:e,attrs:r}=t,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:l}=r,u=b.sizeFromShape(o.shape),c=new cC(u,i,a,l),p=ee({inputs:{x:o},backend:e,attrs:{shape:[u]}}),f=e.runWebGLProgram(c,[p],s);e.disposeIntermediateTensorInfo(p);let d=[...o.shape,i],h=ee({inputs:{x:f},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(f),h},e3={kernelName:fl,backendName:"webgl",kernelFunc:Xce};function ug(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="complex64"){let o=ca({inputs:{input:r},backend:e}),s=ug({inputs:{x:o},backend:e}),i=Lc({inputs:{input:r},backend:e}),a=ug({inputs:{x:i},backend:e}),l=Nr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return pa({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:e})}var t3={kernelName:kl,backendName:"webgl",kernelFunc:ug};function n3(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=ca({inputs:{input:r},backend:e}),s=n3({inputs:{x:o},backend:e}),i=Lc({inputs:{input:r},backend:e}),a=ug({inputs:{x:i},backend:e}),l=Nr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return pa({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}var r3={kernelName:pl,backendName:"webgl",kernelFunc:n3};function Yce(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r;if(n.length===1)return Kw({inputs:{input:n[0]},backend:e,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=n.map(c=>{let p=Kw({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),u=mD({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var o3={kernelName:dl,backendName:"webgl",kernelFunc:Yce};var pC=class{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+n[c]+u[1]);let o=n.length,s=ke(o),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var fC=class{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+n[m]+g[1]);let o=n.length,s=ke(o),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+n[m]).join(","),l=Yt("rc",o),u=Yt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${c}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let g=0,m=o===1?2:4;g<m;g++)h+=`
        ${f[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${p});
        }
      `;h+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var ID=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,constantValue:i}=r;if(b.sizeFromShape(o.shape)===0){let u=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return pa({backend:e,attrs:{shape:u,value:i,dtype:o.dtype}})}let a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fC(o.shape,s,i):new pC(o.shape,s,i),l=[[i]];return e.runWebGLProgram(a,[o],o.dtype,l)},s3={kernelName:hl,backendName:"webgl",kernelFunc:ID};var Zce=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Qce=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ur+`
  return result;
`,Jce=rt({opSnippet:Zce,packedOpSnippet:Qce}),i3={kernelName:Mi,backendName:"webgl",kernelFunc:Jce};function epe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=[],u=b.parseAxisParam(s,o.shape),c=u,p=N.getAxesPermutation(c,a),f=o;p!=null&&(f=At({inputs:{x:o},backend:e,attrs:{perm:p}}),c=N.getInnerMostAxes(c.length,a),l.push(f)),N.assertAxesAreInnerMostDims("prod",c,a);let d;if(e.shouldExecuteOnCPU([f])){let h=e.texData.get(f.dataId).values,{outVals:g,outShape:m,outDtype:y}=qL(f.shape,f.dtype,h,c);d=e.makeTensorInfo(m,y,g)}else{let[h,g]=N.computeOutAndReduceShapes(f.shape,c),m=b.sizeFromShape(g),y=ee({inputs:{x:f},backend:e,attrs:{shape:[-1,m]}}),x=oc(o.dtype),v=Gr(y,x,"prod",e);d=ee({inputs:{x:v},backend:e,attrs:{shape:h}}),l.push(y),l.push(v)}if(i){l.push(d);let h=N.expandShapeToKeepDim(d.shape,u);d=ee({inputs:{x:d},backend:e,attrs:{shape:h}})}return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var a3={kernelName:gl,backendName:"webgl",kernelFunc:epe};function tpe(t){let{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,l=o.map(y=>e.readSync(y.dataId)),u=o.map(y=>y.shape),c=e.readSync(s.dataId),p=e.readSync(i.dataId),[f,d,h]=KL(l,u,c,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var l3={kernelName:If,backendName:"webgl",kernelFunc:tpe};function npe(t){let{inputs:n,backend:e}=t,{starts:r,limits:o,deltas:s}=n,i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=XL(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),f=e.makeTensorInfo([c.length],r.dtype,c);return[p,f]}var u3={kernelName:Sf,backendName:"webgl",kernelFunc:npe};function rpe(t){let{inputs:n,backend:e,attrs:r}=t,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.readSync(o.dataId),c=e.readSync(s.dataId),p=e.readSync(i.dataId),f=a.map(m=>e.readSync(m.dataId)),d=a.map(m=>m.shape),[h,g]=YL(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var c3={kernelName:Tf,backendName:"webgl",kernelFunc:rpe};var SD=t=>{let{backend:n,attrs:e}=t,{start:r,stop:o,step:s,dtype:i}=e,a=ZL(r,o,s,i);return n.makeTensorInfo([a.length],i,a)},p3={kernelName:Nf,backendName:"webgl",kernelFunc:SD};var ope="return 1.0 / x;",spe=ge({opSnippet:ope}),f3={kernelName:$i,backendName:"webgl",kernelFunc:spe};var ipe=fn+`
  return (x < 0.0) ? 0.0 : x;
`,ape=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lpe=ge({opSnippet:ipe,packedOpSnippet:ape}),d3={kernelName:Pi,backendName:"webgl",kernelFunc:lpe};var upe=fn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,cpe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ppe=ge({opSnippet:upe,packedOpSnippet:cpe}),h3={kernelName:Li,backendName:"webgl",kernelFunc:ppe};var dC=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=n;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var hC=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=n;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function fpe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,u]=a,c=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new hC(o.shape,l,u,s,i):new dC(o.shape,l,u,s,i);return e.runWebGLProgram(c,[o],"float32")}var m3={kernelName:bl,backendName:"webgl",kernelFunc:fpe};var mC=class{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=n,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function dpe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r,a=new mC(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var g3={kernelName:kf,backendName:"webgl",kernelFunc:dpe};var gC=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=n;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var yC=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=n;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function hpe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,u]=a,c=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new yC(o.shape,l,u,s,i):new gC(o.shape,l,u,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var y3={kernelName:xl,backendName:"webgl",kernelFunc:hpe};var xC=class{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=n,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function mpe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r,a=new xC(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var x3={kernelName:Df,backendName:"webgl",kernelFunc:mpe};var bC=class{constructor(n,e){this.variableNames=["x"];let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${n[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&n[a]!==1?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`,s=n.map((a,l)=>o(l)).join(","),i=ke(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var vC=class{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;let o=Yt("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ke(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${n[0]} - rc - 1),
            ${n[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),
                ${n[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${s}){
            result.g = ${u(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return f(h)}function u(h){return h[r-1]="("+h[r-1]+" + 1)",f(h)}function c(h){return h[r-2]="("+h[r-2]+" + 1)",f(h)}function p(h){return h[r-1]="("+h[r-1]+" + 1)",h[r-2]="("+h[r-2]+" + 1)",f(h)}function f(h){let g=n.map((x,v)=>d(v,h)),m=g.join(","),y=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function d(h,g){return e.indexOf(h)!==-1&&n[h]!==1?`${n[h]} - ${g[h]} - 1`:`${g[h]}`}}};function gpe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dims:s}=r,i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Zt({inputs:{x:o},backend:e});let l=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vC(o.shape,a):new bC(o.shape,a);return e.runWebGLProgram(l,[o],o.dtype)}var b3={kernelName:vl,backendName:"webgl",kernelFunc:gpe};var wC=class{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=n[1],o=n[2];this.outputShape=n;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var v3={kernelName:Hf,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,{radians:o,fillValue:s,center:i}=n,a=e,l=new wC(r.shape,s),[u,c]=N.getImageCenter(i,r.shape[1],r.shape[2]),p=[[u,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(l,[r],r.dtype,p)}};var ype=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,xpe=ge({opSnippet:ype}),w3={kernelName:Bi,backendName:"webgl",kernelFunc:xpe};var bpe="return inversesqrt(x);",vpe=ge({opSnippet:bpe,cpuKernelImpl:QL}),C3={kernelName:zi,backendName:"webgl",kernelFunc:vpe};var su=class{constructor(n,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=ke(s.length),c=ke(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${n}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};var CC=class{constructor(n,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let u=ke(s.length),c=ke(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides",x=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${n}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function wpe(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(s,o,i),f=[p/u,u];if(p===0)return e.makeTensorInfo(i,o.dtype);let d=ee({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),h=ee({inputs:{x:s},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0])),m;$().getBool("WEBGL_PACK")?m=new CC(l,a,d.shape.length,h.shape.length,c,f):m=new su(l,a,d.shape.length,h.shape.length,c,f);let y=e.runWebGLProgram(m,[h,d,g],h.dtype),x=ee({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),x}var I3={kernelName:Af,backendName:"webgl",kernelFunc:wpe};var IC=class{constructor(n,e,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=$().getNumber("WEBGL_VERSION")===2?s:i,l=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Cpe(t){let{inputs:n,backend:e,attrs:r}=t,{sortedSequence:o,values:s}=n,{side:i}=r,a=new IC(o.shape[0],o.shape[1],s.shape[1],i),l=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",l)}var S3={kernelName:_f,backendName:"webgl",kernelFunc:Cpe};var SC=class{constructor(n,e,r){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);o=l.join(),s=u.join()}let i=ke(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Ipe(t){let{inputs:n,backend:e}=t,{condition:r,t:o,e:s}=n,i=new SC(r.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[r,o,s],nn(o.dtype,s.dtype))}var T3={kernelName:wl,backendName:"webgl",kernelFunc:Ipe};var Spe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N.SELU_SCALEALPHA};
  float scale = ${N.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Tpe=ge({opSnippet:Spe}),N3={kernelName:Vi,backendName:"webgl",kernelFunc:Tpe};var Npe=Ao+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Epe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dpe=ge({opSnippet:Npe,packedOpSnippet:Epe,cpuKernelImpl:eB}),E3={kernelName:ji,backendName:"webgl",kernelFunc:Dpe};var kpe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ape=ge({opSnippet:kpe}),D3={kernelName:Wi,backendName:"webgl",kernelFunc:Ape};var Rpe=Ao+`
  return sin(x);
`,_pe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ur}
  return result;
`,Ope=ge({opSnippet:Rpe,packedOpSnippet:_pe}),k3={kernelName:Ui,backendName:"webgl",kernelFunc:Ope};var Fpe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Mpe=ge({opSnippet:Fpe}),A3={kernelName:Gi,backendName:"webgl",kernelFunc:Mpe};var $pe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Ppe=ge({opSnippet:$pe}),R3={kernelName:Hi,backendName:"webgl",kernelFunc:Ppe};var Lpe=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,paddings:i}=r;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,x)=>y*x),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<o.shape.length;++y)l.push([0,0]);let u=[],c=ID({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),p=N.getReshaped(c.shape,s,a,!1),f=N.getPermuted(p.length,s.length,!1),d=N.getReshapedPermuted(c.shape,s,a,!1),h=ee({inputs:{x:c},backend:e,attrs:{shape:p}}),g=At({inputs:{x:h},backend:e,attrs:{perm:f}}),m=ee({inputs:{x:g},backend:e,attrs:{shape:d}});return u.push(c),u.push(h),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m},_3={kernelName:Sl,backendName:"webgl",kernelFunc:Lpe};function Bpe(t){let{inputs:n,backend:e}=t,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(r.dataId),l=e.readSync(o.dataId),u=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,f,d,h,g]=nB(a,r.shape,r.dtype,l,o.dtype,u,c);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var O3={kernelName:Of,backendName:"webgl",kernelFunc:Bpe};function zpe(t){let{inputs:n,backend:e}=t,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(s.dataId)),[u,c,p]=rB(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var F3={kernelName:Ff,backendName:"webgl",kernelFunc:zpe};function Vpe(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=sw(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}var M3={kernelName:Mf,backendName:"webgl",kernelFunc:Vpe};function Upe(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=sw(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}var $3={kernelName:$f,backendName:"webgl",kernelFunc:Upe};function Gpe(t){let{inputs:n,backend:e,attrs:r}=t,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=N.calculateShapes(s,o,a),d=!1;if(s.dtype==="string"){let y=e.bufferSync(o),x=e.bufferSync(s),v=b.decodeString(e.readSync(i.dataId)[0]),w=JL(y,x,a,f,c,u,l,p,v,d);return e.makeTensorInfo(a,w.dtype,w.values)}let h=new su(u,l,o.shape.length,s.shape.length,p,[f,1],d),g=e.runWebGLProgram(h,[s,o,i],s.dtype),m=ee({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}var P3={kernelName:Pf,backendName:"webgl",kernelFunc:Gpe};function Wpe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=N.prepareSplitSize(o,s,a),u=o.shape.length,c=new Array(u).fill(0),p=o.shape.slice();return l.map(f=>{let d=[...p];d[a]=f;let h=ss({inputs:{x:o},backend:e,attrs:{begin:c,size:d}});return c[a]+=f,h})}var L3={kernelName:Tl,backendName:"webgl",kernelFunc:Wpe};var B3="return sqrt(x);",jpe=ge({opSnippet:B3,packedOpSnippet:B3,cpuKernelImpl:oB}),z3={kernelName:qi,backendName:"webgl",kernelFunc:jpe};var Hpe="return x * x;",qpe=ge({opSnippet:Hpe}),V3={kernelName:Lf,backendName:"webgl",kernelFunc:qpe};var U3="return (a - b) * (a - b);",Kpe=rt({opSnippet:U3,packedOpSnippet:U3}),G3={kernelName:Ki,backendName:"webgl",kernelFunc:Kpe};function Xpe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=e.readSync(o.dataId),i=N.fromUint8ToStringArray(s),a=sB(i,"string",r);return e.makeTensorInfo(o.shape,"string",a)}var W3={kernelName:Xu,backendName:"webgl",kernelFunc:Xpe};function Ype({inputs:t,attrs:n,backend:e}){let{x:r}=t,o=fn+`
    return x > 0.0 ? 1.0 : float(${n.alpha});
  `,s=new Mn(r.shape,o);return e.runWebGLProgram(s,[r],r.dtype)}var j3={kernelName:Qi,backendName:"webgl",kernelFunc:Ype};var TC=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=ke(r.length),i=ke(r.length),a="";if(o===1)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${n});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Zpe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:v,strides:w}=Sn.sliceInfo(o.shape,s,i,a,l,u,c,p,f),T;if(g)T=ee({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=Sn.computeOutShape(x,v,w),O=ss({inputs:{x:o},backend:e,attrs:{begin:x,size:A}});T=ee({inputs:{x:O},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(O)}else if(e.shouldExecuteOnCPU([o])){let O=e.readSync(o.dataId),M=he(o.shape,o.dtype,O),L=iB(d,M,w,x);T=e.makeTensorInfo(h,o.dtype,L.values)}else{let O=new TC(x,w,d);T=e.runWebGLProgram(O,[o],o.dtype)}let k=ee({inputs:{x:T},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(T),k}var H3={kernelName:Bf,backendName:"webgl",kernelFunc:Zpe};function Qpe(t){let{inputs:n,backend:e,attrs:r}=t,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=n,f=e.readSync(c.dataId),d=e.readSync(p.dataId),[h,g]=aB(f,d,o,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var q3={kernelName:zf,backendName:"webgl",kernelFunc:Qpe};function Jpe(t){let{inputs:n,backend:e,attrs:r}=t,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),l=e.readSync(i.dataId)[0],[u,c,p]=lB(a,l,o),f=c.length;return[e.makeTensorInfo([f,2],"int32",u),e.makeTensorInfo([f],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var K3={kernelName:Vf,backendName:"webgl",kernelFunc:Jpe};function efe(t){let{inputs:n,backend:e,attrs:r}=t,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=uB(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var X3={kernelName:Uf,backendName:"webgl",kernelFunc:efe};var tfe="return tan(x);",nfe=ge({opSnippet:tfe}),Y3={kernelName:Yi,backendName:"webgl",kernelFunc:nfe};var rfe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ofe=ge({opSnippet:rfe}),Z3={kernelName:Zi,backendName:"webgl",kernelFunc:ofe};function sfe(t){let{inputs:n,backend:e,attrs:r}=t,{tensor:o,indices:s,updates:i}=n,{}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(i,s,o.shape),f=[p/u,u];if(p===0)return e.makeTensorInfo(o.shape,s.dtype);let d=ee({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),h=ee({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=ee({inputs:{x:o},backend:e,attrs:{shape:f}}),m=new su(l,a,d.shape.length,h.shape.length,c,f,!1,!0),y=e.runWebGLProgram(m,[h,d,g],g.dtype),x=ee({inputs:{x:y},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),x}var Q3={kernelName:Rf,backendName:"webgl",kernelFunc:sfe};var NC=class{constructor(n,e){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;let o=ke(this.rank),s=ife(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function ife(t){let n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`imod(resRC, ${t[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<t.length;o++)r.push(`imod(${e[o]}, ${t[o]})`);return r.join()}function TD(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let l=e.readSync(o.dataId),u=o.dtype==="string"?l.map(f=>b.decodeString(f)):l,c=he(o.shape,o.dtype,u),p=pB(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new NC(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var J3={kernelName:Ns,backendName:"webgl",kernelFunc:TD};var EC=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},DC=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Bc(t,n){n!==null&&t.disposeIntermediateTensorInfo(n)}function eU(t){let n=1;for(;n<t;)n*=2;return n}function afe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{k:s,sorted:i}=r,a=$().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=$().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=o.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>l){let L=e.readSync(o.dataId),[V,U]=fB(L,u,o.dtype,s,i);return[e.makeTensorInfo(V.shape,V.dtype,V.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return u[u.length-1]=0,[e.makeTensorInfo(u,o.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(c===1)return[o,pa({attrs:{shape:u,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),f=p!==null&&p.isPacked,d=f?e.unpackTensor(o):o,g=b.sizeFromShape(u)/c,m=ee({inputs:{x:d},attrs:{shape:[g,c]},backend:e});f&&Bc(e,d);let y=eU(s),x=eU(c),v=null,w=()=>v===null?[m,m]:[m,v],T=(L,V,U)=>{let G=w(),j=new EC(U),Y=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[L],[V]],Q=v;v=e.runWebGLProgram(j,G,"int32",Y),Bc(e,Q)};for(let L=1;L<y;L*=2){let V=L*2;for(let U=L;U>=1;U/=2)T(V,U,[g,x])}for(let L=x;L>y;L/=2){let V=w(),U=new DC([g,L/2]),j=[[c],[v===null?1:0],[y]],H=v;v=e.runWebGLProgram(U,V,"int32",j),Bc(e,H);let Y=y/2,Q=Y*2;for(let X=Y;X>=1;X/=2)T(Q,X,v.shape)}let k=v;v=ss({inputs:{x:v},backend:e,attrs:{begin:0,size:[g,s]}}),Bc(e,k);let A=xD({inputs:{x:m,indices:v},backend:e,attrs:{axis:1,batchDims:1}});Bc(e,m);let O=u.slice(0,-1);O.push(s),k=v,v=ee({inputs:{x:v},attrs:{shape:O},backend:e}),Bc(e,k);let M=A;return A=ee({inputs:{x:A},attrs:{shape:O},backend:e}),Bc(e,M),[A,v]}var tU={kernelName:Gf,backendName:"webgl",kernelFunc:afe};var kC=class{constructor(n,e,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${n}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function lfe(t){let{inputs:n,backend:e,attrs:r}=t,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,p,f,d]=o.shape,[h,g]=u??[p,f],m=[c,h,g,d],y=new kC(p,f,i,a,l,m);return e.runWebGLProgram(y,[o,s],"float32")}var nU={kernelName:Wf,backendName:"webgl",kernelFunc:lfe};function ufe(t){let{inputs:n,attrs:e,backend:r}=t,{axis:o}=e,{x:s}=n;zs(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:l,indices:u}=dB(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var rU={kernelName:jf,backendName:"webgl",kernelFunc:ufe};function cfe(t){let{inputs:n,backend:e,attrs:r}=t,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,l=o.shape[s],u=new Array(a-1),c=0;for(let g=0;g<a;g++)g!==s&&(u[c++]=i.shape[g]);let p=[],f=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let h=new Array(l);for(let g=0;g<h.length;g++){f[s]=g;let m=ss({inputs:{x:i},backend:e,attrs:{begin:f,size:d}}),y=ee({inputs:{x:m},backend:e,attrs:{shape:u}});h[g]=y,p.push(m)}return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var oU={kernelName:El,backendName:"webgl",kernelFunc:cfe};var AC=class{constructor(n,e){this.variableNames=["x","segmentIds"];let r=n.windowSize,o=n.batchSize,s=n.inSize,i=n.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let l="0.0",u="sumValue",c=Math.floor(r/4)*4,p=r%4,f=`
        sumValue += dot(values, segFilter);
    `,d="";s%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function pfe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,segmentIds:s}=n,{numSegments:i}=r,a=o.shape.length,l=[],u=0,c=N.getAxesPermutation([u],a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),l.push(p),u=N.getInnerMostAxes(1,a)[0]);let f=N.segment_util.computeOutShape(p.shape,u,i),d=b.sizeFromShape([p.shape[u]]),h=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}});l.push(h);let g=oc(o.dtype),m=(w,T,k,A,O)=>{let M=w.shape[0],L=w.shape[1],V=N.segment_util.segOpComputeOptimalWindowSize(L,O),U={windowSize:V,inSize:L,batchSize:M,numSegments:O},G=new AC(U,T),j=e.compileAndRun(G,[w,k],A);if(l.push(j),j.shape[1]===O)return j;let H=SD({backend:e,attrs:{start:0,stop:O,step:1,dtype:"float32"}}),Y=TD({inputs:{x:H},backend:e,attrs:{reps:[L/V]}});return l.push(H),l.push(Y),m(j,T,Y,A,O)},y=m(h,"unsortedSegmentSum",s,g,i),x=ee({inputs:{x:y},backend:e,attrs:{shape:f}}),v=x;if(c!=null){l.push(x);let w=N.getUndoAxesPermutation(c);v=At({inputs:{x:v},backend:e,attrs:{perm:w}})}return l.forEach(w=>e.disposeIntermediateTensorInfo(w)),v}var sU={kernelName:Dl,backendName:"webgl",kernelFunc:pfe};var ffe=[VB,GB,WB,jB,qB,KB,XB,YB,JB,ez,tz,nz,rz,oz,sz,iz,az,lz,uz,cz,pz,dz,hz,mz,gz,vz,Cz,Iz,RB,Tz,Ez,Dz,kz,Az,Rz,_z,Oz,Fz,Mz,$z,Bz,zz,Vz,Uz,Gz,Wz,jz,Hz,qz,Kz,Xz,Yz,Zz,Qz,Jz,eV,nV,rV,oV,sV,aV,lV,uV,cV,pV,fV,dV,hV,mV,AB,gV,Nz,yV,xV,bV,_B,vV,wV,CV,IV,SV,TV,NV,EV,DV,kV,RV,_V,OV,FV,MV,$V,LV,zV,VV,UV,GV,WV,XV,MB,YV,ZV,QV,JV,yz,e3,r3,o3,s3,i3,OB,a3,l3,u3,c3,p3,xz,jV,f3,d3,h3,PB,m3,g3,y3,x3,b3,v3,w3,C3,I3,S3,T3,N3,E3,D3,k3,A3,fz,KV,R3,_3,O3,F3,M3,$3,P3,L3,z3,V3,G3,W3,j3,H3,q3,K3,X3,qV,BB,Y3,Z3,Q3,J3,tU,nU,zB,rU,oU,sU,t3];for(let t of ffe)Dx(t);var RC={kernelName:Pa,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,So(K(e,"float32"),-1))}}};var iU={kernelName:ai,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=_e(K(e,"float32")),o=ct(te(se(1),r));return $e(ne(t,o))}}}};var aU={kernelName:li,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=ct(te(_e(K(e,"float32")),1));return ne(t,r)}}}};var lU={kernelName:jo,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=t,l=dt(e.shape,o);return l.length>0&&(a=ie(a,l)),_(a,e.shape)},b:()=>{let a=t,l=dt(r.shape,o);return l.length>0&&(a=ie(a,l)),_(a,r.shape)}}}};var uU={kernelName:La,saveAllInputs:!0,gradFunc:(t,n)=>{let e={};return n.forEach((r,o)=>{e[o]=()=>t.clone()}),e}};var cU={kernelName:Ba,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ye(e)}}};var pU={kernelName:za,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ye(e)}}};var fU={kernelName:ui,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,ct(te(se(1),_e(K(e,"float32")))))}}};var dU={kernelName:ci,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=ct(W(se(1),_e(K(e,"float32"))));return ne(t,r)}}}};var hU={kernelName:di,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=W(_e(e),_e(r)),l=R(t,ne(r,a)),u=dt(e.shape,o);return u.length>0&&(l=ie(l,u)),_(l,e.shape)},b:()=>{let a=W(_e(e),_e(r)),l=$e(R(t,ne(e,a))),u=dt(r.shape,o);return u.length>0&&(l=ie(l,u)),_(l,r.shape)}}}};var mU={kernelName:pi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,W(_e(K(e,"float32")),1))}}};var gU={kernelName:fi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,te(se(1),_e(K(e,"float32"))))}}};function dfe(t,n,e,r,o,s){let i=I(t,"dy","avgPool3dGrad"),a=I(n,"input","avgPool3dGrad"),l=i,u=a,c=!1;a.rank===4&&(c=!0,l=_(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=_(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),D(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),gt("avgPool3dGrad",o,s);let p={dy:l,input:u},f={filterSize:e,strides:r,pad:o,dimRoundingMode:s},d=E.runKernel(jp,p,f);return c?_(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var yU=S({avgPool3dGrad_:dfe});var xU={kernelName:Ua,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>yU(t,r,o,s,i,a)}}};function hfe(t,n,e,r,o){let s=I(t,"dy","avgPoolGrad"),i=I(n,"input","avgPoolGrad");D(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,l=s,u=!1;i.rank===3&&(u=!0,a=_(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=_(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),D(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:l,input:a},p={filterSize:e,strides:r,pad:o},f=E.runKernel(Wp,c,p);return u?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var bU=S({avgPoolGrad_:hfe});var vU={kernelName:Va,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{filterSize:o,strides:s,pad:i}=e;return{x:()=>bU(t,r,o,s,i)}}};var wU={kernelName:Ga,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{let[r,o]=n,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>Fe(t,o,!1,!0),b:()=>Fe(r,t,!0,!1)}:!s&&i?{a:()=>Fe(t,o,!1,!1),b:()=>Fe(t,r,!0,!1)}:s&&!i?{a:()=>Fe(o,t,!1,!0),b:()=>Fe(r,t,!1,!1)}:{a:()=>Fe(o,t,!0,!0),b:()=>Fe(t,r,!0,!0)}}};var CU={kernelName:Wa,gradFunc:(t,n,e)=>{let{blockShape:r,crops:o}=e;return{x:()=>jl(t,r,o)}}};var IU={kernelName:FO,gradFunc:(t,n,e)=>{let r=e,o=r.inputShape,s=r.shape,i=Array.from(s);for(let l=o.length-1;l>=0;l--)if(o[l]===s[l])i[l]=1;else if(o[l]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>ie(t,a,!0)}}};var SU={kernelName:Ss,gradFunc:t=>({x:()=>t.clone()})};var TU={kernelName:hi,gradFunc:t=>({x:()=>ye(t)})};var NU={kernelName:mi,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>yt(Vn(ar(r,o),$r(r,s)),t,ye(t))}}};var EU={kernelName:ja,inputsToSave:["x"],gradFunc:RC.gradFunc};var DU={kernelName:Ha,saveAllInputs:!0,gradFunc:(t,n,e)=>{let r=n.map(l=>l.shape),{axis:o}=e,s=ln(o,n[0].shape)[0],i=r.map(l=>l[s]);return cn(t,i,s).map(l=>()=>l)}};var kU={kernelName:qa,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,{dilations:s,strides:i,pad:a,dataFormat:l}=e;return D(to(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>ud(r.shape,t,o,i,a,l),filter:()=>kd(r,t,o.shape,i,a,l)}}};var AU={kernelName:Ka,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,{strides:s,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>vr(t,o,s,i,a,1,l),filter:()=>kd(t,r,o.shape,s,i,a,l)}}};function mfe(t,n,e,r,o){let s=t;t.rank===4&&(s=_(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;i.rank===4&&(i=_(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),D(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),D(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),D(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},l={strides:r,pad:o,filterShape:e};return E.runKernel(Yp,a,l)}var RU=S({conv3DBackpropFilter_:mfe});var _U={kernelName:Xa,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let{dilations:r,strides:o,pad:s}=e;D(to(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,a]=n;return{x:()=>pb(i.shape,t,a,o,s),filter:()=>RU(i,t,a.shape,o,s)}}};var OU={kernelName:gi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R($e(wd(K(e,"float32"))),t)}}};var FU={kernelName:yi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(Cd(K(e,"float32")),t)}}};var MU={kernelName:Ya,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=dN([o],r.rank),l=fd(t,o,s,!i);return a!=null&&(l=Me(l,a)),l}}}};var $U={kernelName:Za,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let{dilations:r,strides:o,pad:s,dimRoundingMode:i}=e,a=r??[1,1];D(to(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[l,u]=n;return D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),D(Rn(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),gt("depthwiseConv2d",s,i),{x:()=>Hb(l.shape,t,u,o,s,a,i),filter:()=>jb(l,t,u.shape,o,s,a,i)}}};var PU={kernelName:Qa,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,s={x:r,filter:o,dy:t},i={x:r,filter:o,dy:t};return{x:()=>E.runKernel(wm,s,e),filter:()=>E.runKernel(Cm,i,e)}}};var LU={kernelName:bi,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n,r={dy:t,y:e};return{x:()=>E.runKernel(af,r)}}};var BU={kernelName:vi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n,r=R(Ht($e(_e(e))),2/Math.sqrt(Math.PI));return{x:()=>R(t,r)}}};var zU={kernelName:wi,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,e)}}};var VU={kernelName:Ja,inputsToSave:["input"],gradFunc:(t,n)=>{let[e]=n;return{input:()=>_(t,e.shape)}}};var UU={kernelName:Ci,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,Ht(e))}}};var GU={kernelName:Ii,gradFunc:t=>({x:()=>ye(t)})};var WU={kernelName:Si,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=ne(t,K(r,"float32")),l=dt(e.shape,o);return l.length>0?_(ie(a,l),e.shape):a},b:()=>{let a=R(t,K(e,"float32")),l=dt(r.shape,o);l.length>0&&(a=_(ie(a,l),r.shape));let u=_e(r);return $e(ne(a,K(u,"float32")))}}}};var jU={kernelName:el,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{let{varianceEpsilon:r}=e,[o,s,i,a]=n,l=a??se(1),u=dt(s.shape,o.shape),c=[];if(s.rank===1){for(let w=0;w<o.shape.length-1;++w)c.push(o.shape[w]);c.push(1)}let p=te(o,s),f=R(t,l),d=xd(W(i,se(r))),h=R(R(R(d,d),d),se(-.5));return{x:()=>s.rank===1?_(R(R(t,On(_(d,[1,1,1,s.shape[0]]),c)),l),o.shape):_(R(R(t,d),l),o.shape),mean:()=>{let w=R(R(d,se(-1)),f);return s.rank===1&&(w=ie(w,u)),_(w,s.shape)},variance:()=>{let w=R(R(h,p),f);return s.rank===1&&(w=ie(w,u)),_(w,s.shape)},scale:()=>{let w=R(p,d),T=R(t,w);return s.rank===1&&(T=ie(T,u)),_(T,s.shape)},offset:()=>{let w=t;return s.rank===1&&(w=ie(w,u)),_(w,s.shape)}}}};var KU={kernelName:tl,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{let[r,o]=n,{axis:s,batchDims:i}=e,a=ln(s,r.shape)[0],l=(u,c,p)=>()=>{let f=u.shape,d=c.size,h=f.slice(0,a),g=h.length,m=f.slice(s,f.length).slice(1),y=m.length,x=HU(0,g),v=HU(g+1,g+1+y),w=qU([h,[d],m]),T=_(p,w),k=_(c,[d]),A=qU([[g],x,v]),O=Me(T,A),M=Dd(O,k,u.shape[a]),L=Mm(A);return M=Me(M,L),M};if(i===1){let u=r.shape[0],c=r.split(u,0);return{x:()=>Bt(c.map((d,h)=>l(d,o.slice(h,1),t.slice(h,1))())).reshape(r.shape),indices:()=>o}}else return{x:l(r,o,t),indices:()=>o}}};function HU(t,n){let e=[];for(let r=t;r<n;++r)e.push(r);return e}function qU(t){let n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}var XU={kernelName:Ti,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>ye(e),b:()=>ye(r)}}};var YU={kernelName:Ts,gradFunc:t=>({x:()=>K(t,"float32")})};var ZU={kernelName:Ni,gradFunc:t=>({x:()=>ye(t)})};var QU={kernelName:Ei,gradFunc:t=>({x:()=>ye(t)})};var JU={kernelName:Di,gradFunc:t=>({x:()=>ye(t)})};var eG={kernelName:nl,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{alpha:o}=e,s=Lt(r,0);return{x:()=>yt(s,t,R(t,o))}}};var tG={kernelName:Ai,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,W(e,1))}}};var nG={kernelName:ki,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,K(e,"float32"))}}};var rG={kernelName:MO,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e;return{logits:()=>{let i=Ht(r);return te(t,R(ie(t,o,!0),i))}}}};function gfe(t,n,e,r=5,o=1,s=1,i=.5){let a={x:t,y:n,dy:e},l={depthRadius:r,bias:o,alpha:s,beta:i};return E.runKernel(mf,a,l)}var oG=S({localResponseNormalizationBackprop_:gfe});var sG={kernelName:rl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{depthRadius:s,bias:i,alpha:a,beta:l}=e;return{x:()=>oG(r,o,t,s,i,a,l)}}};function _C(t,n,e,r){return n.rank<e.rank&&(n=_(n,Io(n.shape,r))),t.rank<e.rank&&(t=_(t,Io(t.shape,r))),{x:()=>R(t,K(Zn(e,n),t.dtype))}}var ND={kernelName:ol,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let r=e,{reductionIndices:o}=r,s=n[0],i=n[1],a=ln(o,s.shape),l=_C(t,i,s,a);return{x:()=>l.x()}}};var iG={kernelName:Ri,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>R(t,K(ar(e,r),"float32")),b:()=>R(t,K(oa(e,r),"float32"))}}};function yfe(t,n,e,r,o,s,i){let a=I(t,"dy","maxPool3dGrad"),l=I(n,"input","maxPool3dGrad"),u=I(e,"output","maxPool3dGrad"),c=a,p=l,f=u,d=!1;l.rank===4&&(d=!0,c=_(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=_(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=_(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),D(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),D(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),D(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),gt("maxPool3dGrad",s,i);let h={dy:c,input:p,output:f},g={filterSize:r,strides:o,pad:s,dimRoundingMode:i},m=E.runKernel(yf,h,g);return d?_(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var aG=S({maxPool3dGrad_:yfe});var lG={kernelName:il,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>aG(t,r,o,s,i,a,l)}}};function xfe(t,n,e,r,o,s,i){let a=I(t,"dy","maxPoolGrad"),l=I(n,"input","maxPoolGrad"),u=I(e,"output","maxPoolGrad");D(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),D(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),D(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),gt("maxPoolGrad",s,i);let c={dy:a,input:l,output:u},p={filterSize:r,strides:o,pad:s,dimRoundingMode:i};return E.runKernel(gf,c,p)}var uG=S({maxPoolGrad_:xfe});var cG={kernelName:sl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{filterSize:s,strides:i,pad:a}=e;return{x:()=>uG(t,r,o,s,i,a)}}};var pG={kernelName:al,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e,s=ln(o,r.shape),a=fN(r.shape,s)[1],l=Le(a);return{x:()=>{let c=r.shape.slice();s.forEach(d=>{c[d]=1});let p=_(t,c);return ne(R(p,en(r.shape,"float32")),l)}}}};var fG={kernelName:ll,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let r=e,{axis:o}=r,[s,i]=n,a=ln(o,s.shape),l=_C(t,i,s,a);return{x:()=>l.x()}}};var dG={kernelName:_i,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>R(t,K($r(e,r),"float32")),b:()=>R(t,K(Lt(e,r),"float32"))}}};var hG={kernelName:ul,inputsToSave:["x"],gradFunc:(t,n,e)=>{let r=n[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>ve(t,s,r.shape)}}};var mG={kernelName:Oi,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=dt(e.shape,o);return a.length>0?_(ie(t,a),e.shape):t},b:()=>{let a=R(t,$e($s(ne(e,r)))),l=dt(r.shape,o);return l.length>0?_(ie(a,l),r.shape):a}}}};var gG={kernelName:Fi,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=R(t,K(r,"float32")),l=dt(e.shape,o);return l.length>0?_(ie(a,l),e.shape):a},b:()=>{let a=R(t,K(e,"float32")),l=dt(r.shape,o);return l.length>0?_(ie(a,l),r.shape):a}}}};var yG={kernelName:cl,gradFunc:t=>({x:()=>$e(t)})};var xG={kernelName:fl,inputsToSave:["indices"],gradFunc:(t,n)=>{let e=n[0];return{indices:()=>bt(e.shape,"float32")}}};var bG={kernelName:pl,gradFunc:t=>({x:()=>ye(t)})};var vG={kernelName:dl,saveAllInputs:!0,gradFunc:(t,n,e)=>{let{axis:r}=e;return pn(t,r).map(s=>()=>s)}};var ED={kernelName:hl,inputsToSave:["x"],gradFunc:(t,n,e)=>{let r=n[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>ve(t,s,r.shape)}}};var wG={kernelName:Mi,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{let[e,r,o]=n,s=e,i=r,a=De(s.shape,i.shape);return{a:()=>{let c=K(i,"float32"),p=R(t,R(c,zn(s,te(c,se(1))))),f=dt(s.shape,a);return f.length>0&&(p=ie(p,f)),_(p,s.shape)},b:()=>{let c=Lt(s,0),p=yt(c,Cn(s),ye(s)),f=R(t,R(o,p)),d=dt(i.shape,a);return d.length>0&&(f=ie(f,d)),_(f,i.shape)}}}};var CG={kernelName:ml,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{let[e,r]=n,o=Lt(e,0);return{x:()=>yt(o,t,R(t,r)),alpha:()=>{let s=yt(o,ye(t),R(t,e)),i=dt(r.shape,t.shape);return i.length>0&&(s=ie(s,i)),_(s,r.shape)}}}};function bfe(t,n,e){let r=t.shape.slice();r[e]=1;let o=_(n,r),s=fc(t,e,!0,!1),i=fc(t,e,!0,!0),a=R(s,i);return R(o,a)}function vfe(t,n,e){let r=t.shape.length,o=r-e.length,s=N.getAxesPermutation(e,r),i=t;s!=null&&(i=Me(t,s));let a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((f,d)=>f*d,1);a.push(u);let c=i.reshape(a),p=bfe(c,n,o);if(p=p.reshape(i.shape),s!=null){let f=N.getUndoAxesPermutation(s);p=Me(p,f)}return p}var IG={kernelName:gl,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e,s=[];return o==null?s=r.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>vfe(r,t,s)}}};var SG={kernelName:xi,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=ne(t,K(r,"float32")),l=dt(e.shape,o);return l.length>0?_(ie(a,l),e.shape):a},b:()=>{let a=R(t,K(e,"float32")),l=dt(r.shape,o);l.length>0&&(a=_(ie(a,l),r.shape));let u=_e(r);return $e(ne(a,K(u,"float32")))}}}};var TG={kernelName:$i,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,$e(_e(e)))}}};var NG={kernelName:Li,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n,r=R($r(e,6),So(e));return{x:()=>R(t,K(r,"float32"))}}};var EG={kernelName:Pi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,K(So(e),"float32"))}}};var DG={kernelName:yl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>_(t,e.shape)}}};var kG={kernelName:bl,inputsToSave:["images"],gradFunc:(t,n,e)=>{let[r]=n,o={dy:t,images:r};return{images:()=>E.runKernel(kf,o,e)}}};var AG={kernelName:xl,inputsToSave:["images"],gradFunc:(t,n,e)=>{let[r]=n,o={dy:t,images:r};return{images:()=>E.runKernel(Df,o,e)}}};var RG={kernelName:vl,gradFunc:(t,n,e)=>{let{dims:r}=e,o=ln(r,t.shape);return{x:()=>un(t,o)}}};var _G={kernelName:Bi,gradFunc:t=>({x:()=>ye(t)})};var OG={kernelName:zi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>$e(ne(t,R(zn(e,1.5),2)))}}};var FG={kernelName:wl,inputsToSave:["condition"],gradFunc:(t,n)=>{let[e]=n;return{condition:()=>K(ye(e),"float32"),t:()=>R(t,K(e,t.dtype)),e:()=>R(t,K(Gl(e),t.dtype))}}};var MG={kernelName:Vi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=Lt(e,se(0)),o=se(PN),s=se(LN),i=R(t,s),a=R(R(t,o),Ht(K(e,"float32")));return yt(r,i,a)}}}};var $G={kernelName:ji,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,R(e,te(se(1),e)))}}};var PG={kernelName:Wi,gradFunc:t=>({x:()=>ye(t)})};var LG={kernelName:Ui,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(Pl(K(e,"float32")),t)}}};var BG={kernelName:Gi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(pd(K(e,"float32")),t)}}};var zG={kernelName:Cl,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{begin:o,size:s}=e,i=r.shape,[a,l]=$N(r,o,s),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>lr(t,u)}}};var VG={kernelName:Nl,outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r]=n,{dim:o}=e,s=!0,i=R(t,r);return{logits:()=>te(i,R(ie(i,[o],s),r))}}};var UG={kernelName:Hi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,_n(e))}}};var DD={kernelName:Sl,gradFunc:(t,n,e)=>{let{blockShape:r,paddings:o}=e;return{x:()=>$l(t,r,o)}}};var kD={kernelName:Tl,gradFunc:(t,n,e)=>{let{axis:r}=e;return{x:()=>Je(t,r)}}};var GG={kernelName:qi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,R(ct(K(e,"float32")),2))}}};var WG={kernelName:Lf,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(t,R(K(e,"float32"),2))}}};var jG={kernelName:Ki,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=se(2);return{a:()=>R(t,R(o,te(e,r))),b:()=>R(t,R(o,te(r,e)))}}};var HG={kernelName:Qi,gradFunc:t=>({x:()=>ye(t)})};var qG={kernelName:Xi,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=De(e.shape,r.shape);return{a:()=>{let a=t,l=dt(e.shape,o);return l.length>0&&(a=ie(a,l)),_(a,e.shape)},b:()=>{let a=t,l=dt(r.shape,o);return l.length>0&&(a=ie(a,l)),_($e(a),r.shape)}}}};var KG={kernelName:Il,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,o=r.shape.slice(),{axis:s}=e;ln(s,r.shape).forEach(u=>{o[u]=1});let a=_(t,o),l=R(a,en(r.shape,"float32"));return{x:()=>l}}};var XG={kernelName:Yi,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ne(t,_e(Pl(e)))}}};var YG={kernelName:Zi,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>R(te(se(1),_e(e)),t)}}};var ZG={kernelName:Ns,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{reps:o}=e;return{x:()=>{let i=ye(r);if(r.rank===1)for(let a=0;a<o[0];++a)i=W(i,ve(t,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)i=W(i,ve(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)i=W(i,ve(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)for(let c=0;c<o[3];++c)i=W(i,ve(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};var QG={kernelName:Es,gradFunc:(t,n,e)=>{let r=e,{perm:o}=r,s=Mm(o);return{x:()=>Me(t,s)}}};var JG={kernelName:El,gradFunc:(t,n,e)=>{let r=e,{axis:o}=r;return{value:()=>Bt(t,o)}}};var eW={kernelName:Dl,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>wfe(t,e)}}};function wfe(t,n){let e=Cr(n,ye(n)),r=Ps(t,e),o=ar(n,se(0,"int32")),s=r.rank-o.rank;for(let a=0;a<s;++a)o=Pt(o,a+1);o=Vn(o,en(r.shape,"bool"));let i=ye(r);return yt(o,r,i)}var tW={kernelName:kl,gradFunc:t=>({x:()=>ye(t)})};var Cfe=[RC,iU,aU,lU,uU,cU,pU,fU,dU,hU,mU,gU,xU,vU,wU,CU,IU,SU,TU,NU,EU,DU,AU,kU,_U,OU,FU,MU,$U,PU,SG,LU,BU,zU,VU,UU,WU,GU,jU,KU,XU,YU,ZU,QU,JU,eG,tG,nG,rG,sG,ND,ND,iG,lG,cG,pG,fG,dG,hG,mG,gG,yG,xG,bG,vG,ED,ED,wG,CG,IG,TG,NG,EG,DG,kG,AG,RG,_G,OG,FG,MG,$G,PG,LG,BG,zG,VG,UG,DD,DD,kD,kD,GG,jG,WG,HG,qG,KG,XG,YG,ZG,QG,JG,eW,tW];for(let t of Cfe)PO(t);F().prototype.abs=function(){return this.throwIfDisposed(),St(this)};F().prototype.acos=function(){return this.throwIfDisposed(),qx(this)};F().prototype.acosh=function(){return this.throwIfDisposed(),Kx(this)};F().prototype.add=function(t){return this.throwIfDisposed(),W(this,t)};F().prototype.all=function(t,n){return this.throwIfDisposed(),sd(this,t,n)};F().prototype.any=function(t,n){return this.throwIfDisposed(),cc(this,t,n)};F().prototype.argMax=function(t){return this.throwIfDisposed(),As(this,t)};F().prototype.argMin=function(t){return this.throwIfDisposed(),Xx(this,t)};F().prototype.asScalar=function(){return this.throwIfDisposed(),D(this.size===1,()=>"The array must have only 1 element."),_(this,[])};F().prototype.asType=function(t){return this.throwIfDisposed(),K(this,t)};F().prototype.as1D=function(){return this.throwIfDisposed(),_(this,[this.size])};F().prototype.as2D=function(t,n){return this.throwIfDisposed(),_(this,[t,n])};F().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),_(this,[t,n,e])};F().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),_(this,[t,n,e,r])};F().prototype.as5D=function(t,n,e,r,o){return this.throwIfDisposed(),_(this,[t,n,e,r,o])};F().prototype.asin=function(){return this.throwIfDisposed(),Yx(this)};F().prototype.asinh=function(){return this.throwIfDisposed(),Zx(this)};F().prototype.atan=function(){return this.throwIfDisposed(),Qx(this)};F().prototype.atan2=function(t){return this.throwIfDisposed(),Jx(this,t)};F().prototype.atanh=function(){return this.throwIfDisposed(),eb(this)};F().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),Ml(this,t,n,e,r)};F().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),$l(this,t,n)};F().prototype.batchNorm=function(t,n,e,r,o){return this.throwIfDisposed(),_s(this,t,n,e,r,o)};F().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Os(this,t)};F().prototype.cast=function(t){return this.throwIfDisposed(),K(this,t)};F().prototype.ceil=function(){return this.throwIfDisposed(),ib(this)};F().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),vn(this,t,n)};F().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof Pe&&(t=[t]),Je([this,...t],n)};F().prototype.conv1d=function(t,n,e,r,o,s){return this.throwIfDisposed(),ld(this,t,n,e,r,o,s)};F().prototype.conv2dTranspose=function(t,n,e,r,o){return this.throwIfDisposed(),cd(this,t,n,e,r,o)};F().prototype.conv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),vr(this,t,n,e,r,o,s)};F().prototype.cos=function(){return this.throwIfDisposed(),Pl(this)};F().prototype.cosh=function(){return this.throwIfDisposed(),pd(this)};F().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),fc(this,t,n,e)};F().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),fd(this,t,n,e)};F().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),db(this,t,n)};F().prototype.depthwiseConv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),Fs(this,t,n,e,r,o,s)};F().prototype.dilation2d=function(t,n,e,r,o){return this.throwIfDisposed(),hb(this,t,n,e,r,o)};F().prototype.divNoNan=function(t){return this.throwIfDisposed(),mb(this,t)};F().prototype.div=function(t){return this.throwIfDisposed(),ne(this,t)};F().prototype.dot=function(t){return this.throwIfDisposed(),gb(this,t)};F().prototype.elu=function(){return this.throwIfDisposed(),Ms(this)};F().prototype.equal=function(t){return this.throwIfDisposed(),Zn(this,t)};F().prototype.erf=function(){return this.throwIfDisposed(),dd(this)};F().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),yb(this,t,n)};F().prototype.exp=function(){return this.throwIfDisposed(),Ht(this)};F().prototype.expandDims=function(t){return this.throwIfDisposed(),Pt(this,t)};F().prototype.expm1=function(){return this.throwIfDisposed(),xb(this)};F().prototype.fft=function(){return this.throwIfDisposed(),Kl(this)};F().prototype.flatten=function(){return this.throwIfDisposed(),_(this,[this.size])};F().prototype.floor=function(){return this.throwIfDisposed(),$s(this)};F().prototype.floorDiv=function(t){return this.throwIfDisposed(),od(this,t)};F().prototype.gather=function(t,n,e){return this.throwIfDisposed(),Ps(this,t,n,e)};F().prototype.greaterEqual=function(t){return this.throwIfDisposed(),ar(this,t)};F().prototype.greater=function(t){return this.throwIfDisposed(),Lt(this,t)};F().prototype.ifft=function(){return this.throwIfDisposed(),ia(this)};F().prototype.irfft=function(){return this.throwIfDisposed(),Td(this)};F().prototype.isFinite=function(){return this.throwIfDisposed(),bb(this)};F().prototype.isInf=function(){return this.throwIfDisposed(),vb(this)};F().prototype.isNaN=function(){return this.throwIfDisposed(),wb(this)};F().prototype.leakyRelu=function(t){return this.throwIfDisposed(),zl(this,t)};F().prototype.lessEqual=function(t){return this.throwIfDisposed(),$r(this,t)};F().prototype.less=function(t){return this.throwIfDisposed(),oa(this,t)};F().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),Cb(this,t,n,e,r)};F().prototype.logSigmoid=function(){return this.throwIfDisposed(),Ib(this)};F().prototype.logSoftmax=function(t){return this.throwIfDisposed(),hd(this,t)};F().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),Ul(this,t,n)};F().prototype.log=function(){return this.throwIfDisposed(),Cn(this)};F().prototype.log1p=function(){return this.throwIfDisposed(),Vl(this)};F().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Vn(this,t)};F().prototype.logicalNot=function(){return this.throwIfDisposed(),Gl(this)};F().prototype.logicalOr=function(t){return this.throwIfDisposed(),md(this,t)};F().prototype.logicalXor=function(t){return this.throwIfDisposed(),Sb(this,t)};F().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),Fe(this,t,n,e)};F().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),Wl(this,t,n,e,r)};F().prototype.max=function(t,n){return this.throwIfDisposed(),wn(this,t,n)};F().prototype.maximum=function(t){return this.throwIfDisposed(),Cr(this,t)};F().prototype.mean=function(t,n){return this.throwIfDisposed(),xt(this,t,n)};F().prototype.min=function(t,n){return this.throwIfDisposed(),na(this,t,n)};F().prototype.minimum=function(t){return this.throwIfDisposed(),ro(this,t)};F().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),Eb(this,t,n)};F().prototype.mod=function(t){return this.throwIfDisposed(),Db(this,t)};F().prototype.mul=function(t){return this.throwIfDisposed(),R(this,t)};F().prototype.neg=function(){return this.throwIfDisposed(),$e(this)};F().prototype.norm=function(t,n,e){return this.throwIfDisposed(),ra(this,t,n,e)};F().prototype.notEqual=function(t){return this.throwIfDisposed(),Zo(this,t)};F().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),mc(this,t,n,e)};F().prototype.onesLike=function(){return this.throwIfDisposed(),hn(this)};F().prototype.pad=function(t,n){return this.throwIfDisposed(),lr(this,t,n)};F().prototype.pool=function(t,n,e,r,o,s){return this.throwIfDisposed(),kb(this,t,n,e,r,o,s)};F().prototype.pow=function(t){return this.throwIfDisposed(),zn(this,t)};F().prototype.prelu=function(t){return this.throwIfDisposed(),Hl(this,t)};F().prototype.prod=function(t,n){return this.throwIfDisposed(),Ab(this,t,n)};F().prototype.reciprocal=function(){return this.throwIfDisposed(),Mb(this)};F().prototype.relu=function(){return this.throwIfDisposed(),Fn(this)};F().prototype.relu6=function(){return this.throwIfDisposed(),gd(this)};F().prototype.reshapeAs=function(t){return this.throwIfDisposed(),_(this,t.shape)};F().prototype.reshape=function(t){return this.throwIfDisposed(),_(this,t)};F().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),Qb(this,t,n,e)};F().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),Jb(this,t,n,e)};F().prototype.reverse=function(t){return this.throwIfDisposed(),un(this,t)};F().prototype.rfft=function(){return this.throwIfDisposed(),Xl(this)};F().prototype.round=function(){return this.throwIfDisposed(),yd(this)};F().prototype.rsqrt=function(){return this.throwIfDisposed(),xd(this)};F().prototype.selu=function(){return this.throwIfDisposed(),bd(this)};F().prototype.separableConv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),vd(this,t,n,e,r,o,s)};F().prototype.sigmoid=function(){return this.throwIfDisposed(),_n(this)};F().prototype.sign=function(){return this.throwIfDisposed(),$b(this)};F().prototype.sin=function(){return this.throwIfDisposed(),wd(this)};F().prototype.sinh=function(){return this.throwIfDisposed(),Cd(this)};F().prototype.slice=function(t,n){return this.throwIfDisposed(),ve(this,t,n)};F().prototype.softmax=function(t){return this.throwIfDisposed(),ql(this,t)};F().prototype.softplus=function(){return this.throwIfDisposed(),Yo(this)};F().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),jl(this,t,n)};F().prototype.split=function(t,n){return this.throwIfDisposed(),cn(this,t,n)};F().prototype.sqrt=function(){return this.throwIfDisposed(),ct(this)};F().prototype.square=function(){return this.throwIfDisposed(),_e(this)};F().prototype.squaredDifference=function(t){return this.throwIfDisposed(),Nd(this,t)};F().prototype.squeeze=function(t){return this.throwIfDisposed(),Qn(this,t)};F().prototype.stack=function(t,n){this.throwIfDisposed();let e=t instanceof Pe?[this,t]:[this,...t];return Bt(e,n)};F().prototype.step=function(t){return this.throwIfDisposed(),So(this,t)};F().prototype.stridedSlice=function(t,n,e,r,o,s,i,a){return this.throwIfDisposed(),Pb(this,t,n,e,r,o,s,i,a)};F().prototype.sub=function(t){return this.throwIfDisposed(),te(this,t)};F().prototype.sum=function(t,n){return this.throwIfDisposed(),ie(this,t,n)};F().prototype.tan=function(){return this.throwIfDisposed(),Lb(this)};F().prototype.tanh=function(){return this.throwIfDisposed(),Xo(this)};F().prototype.tile=function(t){return this.throwIfDisposed(),On(this,t)};F().prototype.toBool=function(){return this.throwIfDisposed(),K(this,"bool")};F().prototype.toFloat=function(){return this.throwIfDisposed(),K(this,"float32")};F().prototype.toInt=function(){return this.throwIfDisposed(),K(this,"int32")};F().prototype.topk=function(t,n){return this.throwIfDisposed(),zb(this,t,n)};F().prototype.transpose=function(t){return this.throwIfDisposed(),Me(this,t)};F().prototype.unique=function(t){return this.throwIfDisposed(),Vb(this,t)};F().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),Dd(this,t,n)};F().prototype.unstack=function(t){return this.throwIfDisposed(),pn(this,t)};F().prototype.where=function(t,n){return this.throwIfDisposed(),yt(t,this,n)};F().prototype.zerosLike=function(){return this.throwIfDisposed(),ye(this)};var so=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},cr=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},P=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},we=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},OC=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}};var cg=class{constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){let r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){let r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}};function _o(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}else{let e=new Array(n);return e.fill(t),e}}function io(t,n){if(!t)throw new OC(n)}function RD(t,n){let e=0;for(let r of t)r===n&&e++;return e}function Nn(t){return t.length===1?t[0]:t}function ot(t){return Array.isArray(t)?t:[t]}function Oo(t){let e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function fa(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}var Ro={};function uh(t){if(t==null)return null;let n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function AD(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(n=>AD(n));else{let n=Object.keys(t);for(let e of n){let r=t[e];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?t[e]=r.value:AD(r))}}}function Gs(t,n={},e={},r="object",o=!1){if(typeof t=="string"){let s=t,i;if(s in e)i=e[s];else if(s in Ro)i=Ro[s];else if(i=n[s],i==null)throw new P(`Unknown ${r}: ${t}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=t;if(s.className==null||s.config==null)throw new P(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,l;if(i in e?[a,l]=e[i]:i in Ro?[a,l]=Ro.className:i in n&&([a,l]=n[i]),a==null)throw new P(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let d of Object.keys(Ro))u[d]=Ro[d];for(let d of Object.keys(e))u[d]=e[d];let c=s.config;c.customObjects=u;let p=Object.assign({},Ro);for(let d of Object.keys(e))Ro[d]=e[d];AD(s.config);let f=l(a,s.config,e,o);return Ro=Object.assign({},p),f}else{let u=Object.assign({},Ro);for(let p of Object.keys(e))Ro[p]=e[p];let c=new a(s.config);return Ro=Object.assign({},u),c}}}function Ife(t,n){return t<n?-1:t>n?1:0}function pg(t,n){return-1*Ife(t,n)}function Fo(t){if(t==null)return t;let n=[];for(let e of t)n.indexOf(e)===-1&&n.push(e);return n}function nW(t){if(t==null)throw new P(`Invalid value in obj: ${JSON.stringify(t)}`);for(let n in t)if(t.hasOwnProperty(n))return!1;return!0}function Ws(t,n,e){if(e!=null&&t.indexOf(e)<0)throw new P(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function FC(t,n,e=0,r=1/0){return io(e>=0),io(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(o=>typeof o===n)}function Qt(t,n){Array.isArray(t)?(b.assert(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>Qt(e,`element ${r+1} of ${n}`))):b.assert(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${rW(t)}.`)}function rW(t){return t===null?"null":Array.isArray(t)?"["+t.map(n=>rW(n)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function oW(t,n,e){let r=e!=null?e():b.now(),o;return(...i)=>{let a=e!=null?e():b.now();return a-r<n||(r=a,o=t(...i)),o}}function MC(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}var Sfe=0;function PC(){return Sfe++}var $C={};function iu(t=""){return t in $C||($C[t]=0),$C[t]+=1,t+$C[t].toString()}var sW=["channelsFirst","channelsLast"],iW=["nearest","bilinear"],aW=["valid","same","causal"],lW=["max","avg"],uW=["sum","mul","concat","ave"];var ch=new Map;function Rt(t){Ws(sW,"DataFormat",t)}function pW(t){Ws(iW,"InterpolationFormat",t)}function pr(t){Ws(aW,"PaddingMode",t)}function _D(t){Ws(lW,"PoolMode",t)}var fg=[],cW="/";function as(t,n){fg.push(t);try{let e=n();return fg.pop(),e}catch(e){throw fg.pop(),e}}function Tfe(){return fg.length===0?"":fg.join(cW)+cW}function LC(t){if(!fW(t))throw new Error("Not a valid tensor name: '"+t+"'");return Tfe()+t}function BC(t){if(!fW(t))throw new Error("Not a valid tensor name: '"+t+"'");ch.has(t)||ch.set(t,0);let n=ch.get(t);if(ch.set(t,ch.get(t)+1),n>0){let e=`${t}_${n}`;return ch.set(e,1),e}else return t}var Nfe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fW(t){return!!t.match(Nfe)}function dW(t){return t===parseInt(t.toString(),10)}function Mo(t,n,e){n==null&&(n=0),e==null&&(e=t.length);let r=1;for(let o=n;o<e;++o)r*=t[o];return r}function zc(t){if(t.length===0)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){let r=t[e];r<n&&(n=r)}return n}function ls(t){if(t.length===0)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){let r=t[e];r>n&&(n=r)}return n}function fr(t,n){if(n<t)throw new P(`end (${n}) < begin (${t}) is forbidden.`);let e=[];for(let r=t;r<n;++r)e.push(r);return e}var OD;function sn(){return OD==null&&(OD=Bx().epsilon()),OD}function dr(){return"channelsLast"}function er(t,n){return K(t,n)}function ha(t,n=-1){let e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),_(t,e)}function hW(t,n){return B(()=>{if(t.shape.length!==2)throw new P(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);let e=ha(t,1);return VC(e,[1,n,1])})}function mW(t){let n=[Mo(t.shape)];return _(t,n)}function gW(t){if(t.rank<=1)throw new P(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);let n=[t.shape[0],Mo(t.shape,1)];return _(t,n)}function da(t,n,e){return B(()=>{switch(t.rank){case 1:return Id(t,n,e);case 2:return Lm(t,[n,0],[e,t.shape[1]]);case 3:return Sd(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return bc(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return ve(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return ve(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new P(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function FD(t,n,e){return B(()=>{switch(t.rank){case 1:return Id(t,n,e);case 2:return Lm(t,[0,n],[t.shape[0],e]);case 3:return Sd(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return bc(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function dg(t,n,e,r){return B(()=>{switch(t.rank){case 1:return Id(t,n,e);case 2:switch(r){case 1:return da(t,n,e);case 2:return FD(t,n,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return da(t,n,e);case 2:return Sd(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return FD(t,n,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return da(t,n,e);case 2:return bc(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return bc(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return FD(t,n,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function ph(t,n=-1){let e;return n<0&&(e=t[0].rank,e!==0?n=e:n=0),n===t[0].rank&&(n=-1),Je(t,n)}function $D(t,n){switch(t.rank){case 1:return ab([t,n]);case 2:return ad([t,n],0);case 3:return lb([t,n],0);case 4:return ub([t,n],0);default:throw new P(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function VC(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new P(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return On(t,n)}function fh(t,n=0,e=1,r,o){return xc(t,n,e,r,o)}function $o(t,n,e,r){if(t.rank<2||n.rank<2)throw new we(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3){let o=t.shape.slice(-1)[0],s=n.shape.slice(-2)[0];if(o!==s)throw new we(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`)}if(t.rank===2&&n.rank===2)return Yl.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?MD(t.rank,r,dr()):null,activation:e});{let o=t.shape.slice(),s=o.pop();t=_(t,[-1,s]);let i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(h,g)=>g===0?n.rank-2:g<=n.rank-2?g-1:g);n=_(Me(n,c),[l,-1]);let p=[...o,...u];return _(Yl.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?MD(t.rank,r,dr()):null,activation:e}),p)}}function UC(t,n,e){return B(()=>(Array.isArray(n)?n=Tt(n,"int32"):n=K(n,"int32"),Ps(t,n,e)))}function Vc(t){return R(t,t)}function MD(t,n,e){let r=n.shape;if(n.rank!==1&&n.rank!==t)throw new P(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(t===5){if(e==="channelsFirst")return r.length===1?_(n,[1,r[0],1,1,1]):_(n,[1,r[3],r[0],r[1],r[2]]);if(e==="channelsLast")return r.length===1?_(n,[1,1,1,1,r[0]]):_(n,[1].concat(r))}else if(t===4){if(e==="channelsFirst")return r.length===1?_(n,[1,r[0],1,1]):_(n,[1,r[2],r[0],r[1]]);if(e==="channelsLast")return r.length===1?_(n,[1,1,1,r[0]]):_(n,[1].concat(r))}else if(t===3){if(e==="channelsFirst")return r.length===1?_(n,[1,r[0],1]):_(n,[1,r[1],r[0]]);if(e==="channelsLast")return r.length===1?_(n,[1,1,r[0]]):_(n,[1].concat(r))}else if(t<3)return n;throw new P(`Unsupported input rank by biasAdd: ${n.rank}`)}function hr(t,n,e){return B(()=>(e==null&&(e=dr()),Rt(e),W(t,MD(t.rank,n,e))))}function yW(t,n=1){if(n!==1)throw new we(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return Ms(t)}function xW(t){return B(()=>ne(t,W(St(t),1)))}function GC(t,n,e,r){return B(()=>CN(t,n,e,r))}function bW(t){return B(()=>{let n=W(.5,R(.2,t));return vn(n,0,1)})}function au(t,n,e=!1){return e?t():n()}var vW=["fanIn","fanOut","fanAvg"],wW=["normal","uniform","truncatedNormal"];function Efe(t){Ws(vW,"FanMode",t)}function Dfe(t){Ws(wW,"Distribution",t)}var mr=class extends q.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},SW=(()=>{class t extends mr{apply(e,r){return bt(e,r)}}return t.className="Zeros",t})();q.registerClass(SW);var WC=(()=>{class t extends mr{apply(e,r){return en(e,r)}}return t.className="Ones",t})();q.registerClass(WC);var TW=(()=>{class t extends mr{constructor(e){if(super(),typeof e!="object")throw new P(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new P(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return B(()=>R(se(this.value),en(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})();q.registerClass(TW);var NW=(()=>{class t extends mr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Pr(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})();q.registerClass(NW);var EW=(()=>{class t extends mr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new we(`randomNormal does not support dType ${r}.`);return fh(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})();q.registerClass(EW);var DW=(()=>{class t extends mr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new we(`truncatedNormal does not support dType ${r}.`);return Ed(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})();q.registerClass(DW);var kW=(()=>{class t extends mr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,r){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new P("Identity matrix initializer can only be used for 2D square matrices.");return R(this.gain,dc(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})();q.registerClass(kW);function kfe(t,n="channelsLast"){let e,r;if(Rt(n),t.length===2)e=t[0],r=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(n==="channelsFirst"){let o=Mo(t,2);e=t[1]*o,r=t[0]*o}else if(n==="channelsLast"){let o=Mo(t,0,t.length-2);e=t[t.length-2]*o,r=t[t.length-1]*o}}else{let o=Mo(t);e=Math.sqrt(o),r=Math.sqrt(o)}return[e,r]}var Wr=(()=>{class t extends mr{constructor(e){if(super(),e.scale<0)throw new P(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Efe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Dfe(this.distribution),this.seed=e.seed}apply(e,r){let o=kfe(e),s=o[0],i=o[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(s+i)/2),this.distribution==="normal"){let l=Math.sqrt(a);if(r=r||"float32",r!=="float32"&&r!=="int32")throw new we(`${this.getClassName()} does not support dType ${r}.`);return Ed(e,0,l,r,this.seed)}else{let l=Math.sqrt(3*a);return Pr(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();q.registerClass(Wr);var PD=(()=>{class t extends Wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="GlorotUniform",t})();q.registerClass(PD);var LD=(()=>{class t extends Wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="GlorotNormal",t})();q.registerClass(LD);var BD=(()=>{class t extends Wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="HeNormal",t})();q.registerClass(BD);var zD=(()=>{class t extends Wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="HeUniform",t})();q.registerClass(zD);var VD=(()=>{class t extends Wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="LeCunNormal",t})();q.registerClass(VD);var UD=(()=>{class t extends Wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}return t.className="LeCunUniform",t})();q.registerClass(UD);var AW=(()=>{class t extends mr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return B(()=>{if(e.length<2)throw new we("Shape must be at least 2D.");if(r!=="int32"&&r!=="float32"&&r!==void 0)throw new TypeError(`Unsupported data type ${r}.`);r=r;let o=b.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],i=o*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=[Math.max(s,o),Math.min(s,o)],l=fh(a,0,1,r,this.seed),u=TN.qr(l,!1),c=u[0],f=u[1].flatten().stridedSlice([0],[Math.min(s,o)*Math.min(s,o)],[Math.min(s,o)+1]);return c=R(c,f.sign()),o<s&&(c=c.transpose()),R(se(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})();q.registerClass(AW);var CW={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function IW(t,n={}){return Gs(t,q.SerializationMap.getMap().classNameMap,n,"initializer")}function vt(t){return uh(t)}function pt(t){if(typeof t=="string"){let n=t in CW?CW[t]:t;if(n==="GlorotNormal")return new LD;if(n==="GlorotUniform")return new PD;if(n==="HeNormal")return new BD;if(n==="HeUniform")return new zD;if(n==="LeCunNormal")return new VD;if(n==="LeCunUniform")return new UD;{let e={};return e.className=n,e.config={},IW(e)}}else return t instanceof mr?t:IW(t)}function jC(t){return Array.isArray(t)&&Array.isArray(t[0])}function dh(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function xe(t){let n;if(Array.isArray(t)){if(t.length!==1)throw new P(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function Re(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new P(`Expected exactly 1 Shape; got ${t.length}`)}else return t}function hh(t){let n=0;for(let e of t)e.shape.length===0?n+=1:n+=e.shape.reduce((r,o)=>r*o);return n}var _W="Variable",hg=class{constructor(n,e="float32",r=_W,o=!0,s=null){this.dtype=e??"float32",this.shape=n.shape,this.id=PC(),r=r??_W,this.originalName=LC(r),this.name=BC(this.originalName),this.trainable_=o,this.constraint=s,this.val=Ub(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),Rfe(this.val,n),this.val.id!==n.id&&(this.val.assign(n),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}};function Rfe(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}function mg(t){return t.map(n=>n.read())}function mh(t){t.forEach(n=>{n[0].write(n[1])})}var ht=class{constructor(n){this.dtype=n.dtype,this.shape=n.shape,n.shape!=null?this.ndim=n.shape.length:this.ndim=n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}},tr=class{constructor(n,e,r,o,s,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=PC(),i!=null&&(this.originalName=LC(i),this.name=BC(this.originalName)),this.rank=e.length}},_fe=0,ma=class{constructor(n,e){this.callArgs=e,this.id=_fe++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(let r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){let n=[];for(let e of this.inboundLayers)e!=null?n.push(e.name):n.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},Ofe=0,Ce=class extends q.Serializable{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Ofe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){let r=this.getClassName();e=Oo(r)+"_"+iu(r)}if(this.name=e,this.trainable_=n.trainable==null?!0:n.trainable,n.inputShape!=null||n.batchInputShape!=null){let r;if(n.batchInputShape!=null)r=n.batchInputShape;else if(n.inputShape!=null){let s=null;n.batchSize!=null&&(s=n.batchSize),r=[s].concat(n.inputShape)}this.batchInputShape=r;let o=n.dtype;o==null&&(o=n.inputDType),o==null&&(o="float32"),this.dtype=o}n.weights!=null?this.initialWeights=n.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(this.inboundNodes.length===0)throw new cr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new P(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return Nn(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return Nn(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new so(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new so(`Layer ${this.name} is not connected, no input to return.`);return Nn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new so(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new so(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Nn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){let e=ot(n);if(this.inputSpec==null||this.inputSpec.length===0)return;let r=ot(this.inputSpec);if(e.length!==r.length)throw new P(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${n}`);for(let o=0;o<e.length;o++){let s=e[o],i=r[o];if(i==null)continue;let a=s.rank;if(i.ndim!=null&&a!==i.ndim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&s.dtype!==i.dtype)throw new P(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){let l=s.shape;for(let u in i.axes){let c=Number(u),p=i.axes[u],f=c>=0?l[c]:l[l.length+c];if(p!=null&&[p,null].indexOf(f)===-1)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${p} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){let u=i.shape[l],c=s.shape[l];if(u!=null&&c!=null&&u!==c)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){this._callHook!=null&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();let r=ot(n),o=$fe(n),s=Pfe(n);if(o===s)throw new P("Arguments to apply() must be all SymbolicTensors or all Tensors");return as(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);let i=[];for(let a of ot(n))i.push(a.shape);this.build(Nn(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(n),s){let i=this.call(n,e);this.supportsMasking&&this.setMaskMetadata(n,i);let a=ot(i),l=[];for(let u of a)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=Nn(l),this.activityRegularizer!=null)throw new we("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=Ffe(n),a=this.computeOutputShape(i),l,u=Mfe(n);if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,p)=>new tr(u,c,this,ot(n),e,this.name,p)):l=new tr(u,a,this,ot(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new we("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(this.batchInputShape!=null)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,o)=>{r!=null&&n[o]!=null&&n[o]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new so(`The layer ${this.name} has never been called and thus has no defined output shape.`);let n=[];for(let e of this.inboundNodes){let r=JSON.stringify(e.outputShapes);n.indexOf(r)===-1&&n.push(r)}if(n.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new so(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new cr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return hh(this.weights)}build(n){this.built=!0}getWeights(n=!1){return mg(n?this.trainableWeights:this.weights)}setWeights(n){B(()=>{let e=this.weights;if(e.length!==n.length)throw new P(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(e.length===0)return;let r=[],o=mg(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],l=n[s];if(!b.arraysEqual(i.shape,l.shape))throw new P(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}mh(r)})}addWeight(n,e,r,o,s,i,a,l){if(this._addedWeightNames.indexOf(n)!==-1)throw new P(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(o=l!=null?l():pt("zeros"));let u=o.apply(e,r),c=new hg(u,r,n,i,a);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){n==null||Array.isArray(n)&&n.length===0||(n=ot(n),this._losses!==void 0&&this._losses!==null&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(n,e,r){if(!this.supportsMasking)return;let o=this.computeMask(n,r),s=ot(e),i=ot(o);if(s.length!==i.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=i[a]}addInboundNode(n,e,r,o,s,i,a=null){let l=ot(n);e=ot(e),r=ot(r),o=ot(o),s=dh(s),i=dh(i);let u=[],c=[],p=[];for(let f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),p.push(f.tensorIndex);new ma({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f}getConfig(){let n={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(n.batchInputShape=this.batchInputShape),this.dtype!=null&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return--this._refCount===0&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}};function Ffe(t){t=ot(t);let n=[];for(let e of t)n.push(e.shape);return Nn(n)}function Mfe(t){return"float32"}function GD(t,n,e){if((n==null||e!=null&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),n.inboundNodes.length===0)return[t];{let r=n.inboundNodes[e];if(r.inboundLayers.length===0)return r.inputTensors;{let o=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],a=r.inboundLayers[s],l=r.nodeIndices[s],u=GD(i,a,l);for(let c of u)o.indexOf(c)===-1&&o.push(c)}return o}}}function $fe(t){let n=!0;for(let e of ot(t))if(!(e instanceof tr)){n=!1;break}return n}function Pfe(t){let n=!0;for(let e of ot(t))if(e instanceof tr){n=!1;break}return n}var Uc=(()=>{class t extends Ce{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:iu("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new P("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(r==null){if(e.inputShape==null)throw new P("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new P("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=e.dtype||"float32";this.batchInputShape=r,this.dtype=o,this.inputSpec=[{shape:r}];let s=new tr(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new ma({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new P(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();q.registerClass(Uc);function WD(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new P("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;t.shape!=null&&n==null&&(n=[null].concat(t.shape));let e=t.dtype;return e==null&&(e="float32"),new Uc({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function Lfe(t,n){if(t.dtype==null||t.dtype===n.dtype)return n;try{return K(n,t.dtype)}catch{throw new P(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}var js=class t{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof t)for(let e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(n==null)return;for(let e of n)this.add(e.key,e.value)}}add(n,e,r){if(this.id2Value[n.id]==null)this.id2Value[n.id]=Lfe(n,e),this.name2Id[n.name]=n.id,r!=null&&(this.id2Mask[n.id]=r);else throw new P(`Duplicate key: name=${n.name}, id=${n.id}`);return this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return this.id2Value[n.id]!=null}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof tr){if(this.id2Value[n.id]==null)throw new P(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}else{let e=this.name2Id[n];if(e==null)throw new P(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof tr){if(this.id2Value[n.id]==null)throw new P(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}else{let e=this.name2Id[n];if(e==null)throw new P(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Ne(this.id2Mask)}},HC=new cg,qC=new cg;function FW(t){HC?.setMaxEntries(t),qC?.setMaxEntries(t)}function Gc(t,n,e,r){let o=e==null?!1:e.training,s=Array.isArray(t),i=s?t:[t],a=i.map(h=>h.name),l=[],u=n.names();for(let h of a)u.indexOf(h)!==-1?l.push(n.getValue(h)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=a.join(",")+"|"+n.names().sort().join(","),p=HC.get(c),f;if(p==null){let h=Bfe(i,n);p=h.sorted,f=h.recipientCounts,HC.put(c,p),qC.put(c,f)}f={},o||Object.assign(f,qC.get(c));let d=new js(n);for(let h=0;h<p.length;++h){if(r!=null){let M=km().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}let g=p[h],m=g.sourceLayer;if(m instanceof Uc)continue;let y=[],x=[],v=[],w=!1;for(let M of g.inputs){let L=d.getValue(M),V=d.getMask(M);y.push(L),x.push(V),V!=null&&(w=!0),o||(f[M.name]--,f[M.name]===0&&!n.hasKey(M)&&a.indexOf(M.name)===-1&&!L.isDisposed&&M.sourceLayer.stateful!==!0&&v.push(L))}w&&(e=e||{},e.mask=x[0]);let T=ot(m.apply(y,e)),k=null;m.supportsMasking&&(k=m.computeMask(y,x));let A=Vfe(g),O=Array.isArray(A)?A:[A];for(let M=0;M<O.length;++M){d.hasKey(O[M])||d.add(O[M],T[M],Array.isArray(k)?k[0]:k);let L=a.indexOf(O[M].name);L!==-1&&(l[L]=T[M])}o||Ne(v)}return d.disposeMasks(),s?l:l[0]}function Bfe(t,n){b.assert(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(t.length===1){let o=OW(t[0],n);e=o.sorted,r=o.recipientMap}else{let o=new Set;for(let s of t){let{sorted:i,recipientMap:a}=OW(s,n);for(let l of i)o.has(l.name)||(e.push(l),o.add(l.name));for(let l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:zfe(r)}}function zfe(t){let n={};for(let e in t)n[e]=t[e].size;return n}function OW(t,n){let e=new Set,r=[],o={};for(let a of n.names())e.add(a);let s=[],i=[];for(s.push(t);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(s.length-1);for(let u of a.inputs)o[u.name]==null&&(o[u.name]=new Set),o[u.name].add(a.name),!e.has(u.name)&&s.push(u)}}return{sorted:r,recipientMap:o}}function Vfe(t){let n;if(t.sourceLayer.inboundNodes.length===1)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(let o of t.sourceLayer.inboundNodes[r].outputTensors)if(o.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}var Ufe=$();Ufe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,FW);function jD(t,n){return B(()=>ct(ie(R(t,t),n,!0)))}var Wc=class extends q.Serializable{getConfig(){return{}}},PW=(()=>{class t extends Wc{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let r=jD(e,this.axis),o=vn(r,0,this.maxValue);return R(e,ne(o,W(sn(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})();q.registerClass(PW);var LW=(()=>{class t extends Wc{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>ne(e,W(sn(),jD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})();q.registerClass(LW);var BW=(()=>{class t extends Wc{apply(e){return Fn(e)}}return t.className="NonNeg",t})();q.registerClass(BW);var zW=(()=>{class t extends Wc{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let r=jD(e,this.axis),o=W(R(this.rate,vn(r,this.minValue,this.maxValue)),R(1-this.rate,r));return R(e,ne(o,W(sn(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})();q.registerClass(zW);var MW={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ut(t){return uh(t)}function $W(t,n={}){return Gs(t,q.SerializationMap.getMap().classNameMap,n,"constraint")}function Gt(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in MW?MW[t]:t,config:{}};return $W(e)}else return t instanceof Wc?t:$W(t)}function ga(t){return z(this,null,function*(){if(t==null)return;let n=[],e=[],r=[];for(let o in t){let s=t[o];if(typeof s!="number"){let i=s;n.push(i.data()),e.push(o),r.push(i)}}if(n.length>0){let o=yield Promise.all(n);for(let s=0;s<o.length;++s)t[e[s]]=o[s][0];Ne(r)}})}function KC(t){if(t!=null)for(let n in t){let e=t[n];typeof e!="number"&&e.dispose()}}var jfe=125,lu=class{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return z(this,null,function*(){})}onEpochEnd(n,e){return z(this,null,function*(){})}onBatchBegin(n,e){return z(this,null,function*(){})}onBatchEnd(n,e){return z(this,null,function*(){})}onTrainBegin(n){return z(this,null,function*(){})}onTrainEnd(n){return z(this,null,function*(){})}setModel(n){}},XC=class{constructor(n,e=10){n==null&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(let e of this.callbacks)e.setParams(n)}setModel(n){for(let e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochBegin(n,e)})}onEpochEnd(n,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochEnd(n,e)})}onBatchBegin(n,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchBegin(n,e)})}onBatchEnd(n,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchEnd(n,e)})}onTrainBegin(n){return z(this,null,function*(){n==null&&(n={});for(let e of this.callbacks)yield e.onTrainBegin(n)})}onTrainEnd(n){return z(this,null,function*(){n==null&&(n={});for(let e of this.callbacks)yield e.onTrainEnd(n)})}},HD=class extends lu{constructor(){super()}onEpochBegin(n){return z(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(n,e){return z(this,null,function*(){e==null&&(e={});let r=e.size==null?0:e.size;this.seen+=r;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*r;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=B(()=>W(this.totals[o],R(s,r)));this.totals[o]=a,i?.dispose()}}})}onEpochEnd(n,e){return z(this,null,function*(){if(e!=null)for(let r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?e[r]=this.totals[r]/this.seen:B(()=>{let o=R(ne(1,this.seen),this.totals[r]);e[r]=o,this.totals[r].dispose(),kt(e[r])}))})}},YC=class extends lu{onTrainBegin(n){return z(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(n,e){return z(this,null,function*(){e==null&&(e={}),this.epoch.push(n);for(let r in e)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(e[r])})}syncData(){return z(this,null,function*(){let n=[],e=[],r=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let l=i[a];n.push(l.data()),e.push(s),r.push(a)}}let o=yield Promise.all(n);for(let s=0;s<o.length;++s)this.history[e[s]][r[s]].dispose(),this.history[e[s]][r[s]]=o[s][0]})}},ZC=class extends lu{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||Nc,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=jfe),this.yieldEvery==="never"&&n.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=oW(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){return z(this,null,function*(){let o=[];this.yield!=null&&(yield ga(r),o.push(this.yield(n,e,r))),o.push(this.nextFrameFunc()),yield Promise.all(o)})}onEpochBegin(n,e){return z(this,null,function*(){this.currentEpoch=n,this.epochBegin!=null&&(yield ga(e),yield this.epochBegin(n,e))})}onEpochEnd(n,e){return z(this,null,function*(){let r=[];this.epochEnd!=null&&(yield ga(e),r.push(this.epochEnd(n,e))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),yield Promise.all(r)})}onBatchBegin(n,e){return z(this,null,function*(){this.batchBegin!=null&&(yield ga(e),yield this.batchBegin(n,e))})}onBatchEnd(n,e){return z(this,null,function*(){let r=[];this.batchEnd!=null&&(yield ga(e),r.push(this.batchEnd(n,e))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,n,e)),yield Promise.all(r)})}onTrainBegin(n){return z(this,null,function*(){this.trainBegin!=null&&(yield ga(n),yield this.trainBegin(n))})}onTrainEnd(n){return z(this,null,function*(){this.trainEnd!=null&&(yield ga(n),yield this.trainEnd(n))})}};function QC(t,n){return t==null&&(t={}),t instanceof lu?[t]:Array.isArray(t)&&t[0]instanceof lu?t:ot(t).map(r=>new ZC(r,n))}var VW=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),t.constructors[e]==null&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(let r in t.constructors)t.constructors[+r].forEach(s=>{if(s===e)throw new P("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){let r=[];for(let o in t.constructors){let s=+o;e>=s&&r.push(...t.constructors[s])}return r.map(o=>new o)}}return t.constructors={},t})();function JC(t,n,e,r,o,s,i,a,l){let u=new YC,c=[new HD,...VW.createCallbacks(n)];t!=null&&c.push(...t),c.push(u);let p=new XC(c);return p.setParams({epochs:e,initialEpoch:r,samples:o,steps:s,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:p,history:u}}function jr(t,n={},e=!1){return Gs(t,q.SerializationMap.getMap().classNameMap,n,"layer",e)}function gg(t,n){return B(()=>{t.dtype!=="float32"&&(t=K(t,"float32"));let e=ie(Vc(t),n,!0),r=Co(e.shape,sn()),o=ct(Cr(e,r));return ne(t,o)})}function jc(t,n){return B(()=>xt(Vc(te(n,t)),-1))}function xg(t,n){return B(()=>xt(St(te(n,t)),-1))}function bg(t,n){return B(()=>{let e=te(t,n),r=vn(St(t),sn(),Number.MAX_VALUE),o=St(ne(e,r));return R(100,xt(o,-1))})}function Hfe(t,n){return B(()=>{let e=vn(n,sn(),Number.MAX_VALUE),r=Cn(W(1,e)),o=vn(t,sn(),Number.MAX_VALUE),s=Cn(W(1,o));return xt(Vc(te(r,s)),-1)})}function qfe(t,n){return B(()=>{let e=Cr(0,te(1,R(t,n)));return xt(Vc(e),-1)})}function Kfe(t,n){return B(()=>{let e=Cr(0,te(1,R(t,n)));return xt(e,-1)})}function Xfe(t,n){return B(()=>{let e=ie(R(t,n),-1),r=wn(R(te(1,t),n),-1);return Cr(0,W(1,te(r,e)))})}function Yfe(t,n){return B(()=>{let e=Math.log(2),r=te(n,t),o=te(W(r,Yo(R(-2,r))),e);return xt(o,-1)})}function Hc(t,n,e=!1){return B(()=>{if(e)n=ql(n);else{let r=ie(n,n.shape.length-1,!0);n=ne(n,r)}return n=vn(n,sn(),1-sn()),$e(ie(R(K(t,"float32"),Cn(n)),n.shape.length-1))})}function gh(t,n,e=!1){return B(()=>{let r=K($s(mW(t)),"int32");n=vn(n,sn(),1-sn());let o=n.shape,s=_(mc(r,o[o.length-1]),o);return Hc(s,n,e)})}function Zfe(t,n){if(!b.arraysEqual(t.shape,n.shape))throw new P(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return B(()=>{let e=Fn(n),r=$e(St(n));return W(te(e,R(n,t)),Vl(Ht(r)))})}function yh(t,n){return B(()=>{let e;return e=vn(n,sn(),1-sn()),e=Cn(ne(e,te(1,e))),xt(Zfe(t,e),-1)})}function Qfe(t,n){return B(()=>{let e=vn(t,sn(),1),r=vn(n,sn(),1);return ie(R(t,Cn(ne(e,r))),-1)})}function Jfe(t,n){return B(()=>{let e=Cn(W(sn(),n));return xt(te(n,R(t,e)),-1)})}function e0(t,n){return B(()=>{let e=gg(t,-1),r=gg(n,-1),o=R(e,r);return $e(ie(o,-1))})}var yg={meanSquaredError:jc,meanAbsoluteError:xg,meanAbsolutePercentageError:bg,meanSquaredLogarithmicError:Hfe,squaredHinge:qfe,hinge:Kfe,categoricalHinge:Xfe,logcosh:Yfe,categoricalCrossentropy:Hc,sparseCategoricalCrossentropy:gh,binaryCrossentropy:yh,kullbackLeiblerDivergence:Qfe,poisson:Jfe,cosineProximity:e0};function t0(t){if(typeof t=="string"){if(t in yg)return yg[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new P(n)}else return t}function r0(t,n){return B(()=>{let e=R(.5,hn(n)),r=er(Lt(n,e),t.dtype);return xt(Zn(t,r),-1)})}function o0(t,n){return B(()=>er(Zn(As(t,-1),As(n,-1)),"float32"))}function ede(t,n){return B(()=>K(ie(Vn(Zn(t,1),Zn(n,1))),"float32"))}function tde(t,n){return B(()=>K(ie(Vn(Zn(t,0),Zn(n,1))),"float32"))}function GW(t,n){return B(()=>{let e=ede(t,n),r=tde(t,n),o=W(e,r);return K(yt(Lt(o,0),ne(e,o),0),"float32")})}function qD(t,n){return yh(t,n)}function KD(t,n){return t.rank===n.rank&&(t=Qn(t,[t.rank-1])),n=As(n,-1),n.dtype!==t.dtype&&(n=K(n,t.dtype)),K(Zn(t,n),"float32")}var nde=jc,rde=jc,ode=xg,sde=xg,ide=bg,ade=bg,s0=Hc,lde=e0,XD=gh,n0={binaryAccuracy:r0,categoricalAccuracy:o0,precision:GW,categoricalCrossentropy:s0,sparseCategoricalCrossentropy:XD,mse:nde,MSE:rde,mae:ode,MAE:sde,mape:ide,MAPE:ade,cosine:lde};function WW(t){if(typeof t=="string"&&t in n0)return n0[t];if(typeof t!="string"&&t!=null)return t;throw new P(`Unknown metric ${t}`)}function vg(t){if(io(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let n;for(let e of Object.keys(yg))if(yg[e]===t){n=e;break}if(n!==void 0)return n;for(let e of Object.keys(n0))if(n0[e]===t){n=e;break}return n!==void 0?n:t.name}}function HW(t){let n={Adagrad:()=>Tc.adagrad(.01),Adadelta:()=>Tc.adadelta(1,.95,sn()),Adam:()=>Tc.adam(.001,.9,.999,sn()),Adamax:()=>Tc.adamax(.002,.9,.999,sn(),0),RMSProp:()=>Tc.rmsprop(.001,.9,0,sn()),SGD:()=>Tc.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new P(`Unknown Optimizer ${t}`)}function ZD(t,n,e=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!YD(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function YD(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){let n=Object.keys(t);for(let e of n)if(typeof e!="string"||!YD(t[e]))return!1;return!0}else if(Array.isArray(t)){for(let n of t)if(!YD(n))return!1;return!0}else return!1;else{let n=typeof t;return n==="string"||n==="number"||n==="boolean"}}function qW(t,n,e,r=console.log){let o=pde(t),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(n*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(n)),i0(s,e,r),r("=".repeat(n));let a=t.layers;for(let c=0;c<a.length;++c)o?fde(a[c],e,r):dde(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();let l=cde(t),u=hh(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}function cde(t){let n;return t.collectedTrainableWeights!=null?n=hh(t.collectedTrainableWeights):n=hh(t.trainableWeights),n}function pde(t){let n=!0,e=[],r=[];for(let o in t.nodesByDepth)e.push(t.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){n=!1;break}r.push(...o)}if(n)for(let o of t.layers){let s=!1;for(let i of o.inboundNodes)if(r.indexOf(i)!==-1)if(s){n=!1;break}else s=!0;if(!n)break}return n}function i0(t,n,e=console.log){let r="";for(let o=0;o<t.length;++o)o>0&&(r=r.slice(0,r.length-1)+" "),r+=t[o],r=r.slice(0,n[o]),r+=" ".repeat(n[o]-r.length);e(r)}function fde(t,n,e){let r,o;try{o=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}let s=t.name,i=t.getClassName(),a=[`${s} (${i})`,o,r,t.countParams().toString()];i0(a,n,e)}function dde(t,n,e,r){let o,s;try{s=t.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(t.outputShape)}catch{o="multiple"}let i=[];for(let p of t.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let f=0;f<p.inboundLayers.length;++f){let d=p.inboundLayers[f].name,h=p.nodeIndices[f],g=p.tensorIndices[f];i.push(`${d}[${h}][${g}]`)}let a=t.name,l=t.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,s,o,t.countParams().toString(),u];i0(c,n,r);for(let p=1;p<i.length;++p)i0(["","","","",i[p]],n,r)}function KW(t,n,e){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&n===0&&typeof e=="string"}function wg(t,n){if(t===null)return null;if(typeof t=="string")return fa(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let e=[],r=t.length;for(let o=0;o<r;++o){let s=t[o];KW(n,o,s)?e.push(s):e.push(wg(s,n))}return e}else{let e={};for(let r of Object.keys(t)){let o=t[r];if(r==="name"&&typeof o=="string")e[r]=o;else{let s=fa(r);e[s]=wg(o,s)}}return e}}function a0(t,n){if(t==null)return null;if(typeof t=="string")return Oo(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let e=[],r=t.length;for(let o=0;o<r;++o){let s=t[o];KW(n,o,s)?e.push(s):e.push(a0(s,n))}return e}else{let e={};for(let r of Object.keys(t)){let o=t[r],s=Oo(r);(r==="name"||r==="className")&&typeof o=="string"?e[s]=o:e[s]=a0(o,r)}return e}}var xh="4.22.0";var hde=t=>{let n=Object.keys(t);if(n.length===0)return!1;let e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))},l0=class t extends Ce{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=iu(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(n.inputs)?this.inputs=n.inputs.slice():this.inputs=[n.inputs],Array.isArray(n.outputs)?this.outputs=n.outputs.slice():this.outputs=[n.outputs],Fo(this.inputs).length!==this.inputs.length)throw new P(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);Fo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let v=x.sourceLayer,w=x.nodeIndex,T=x.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(T)}for(let x of this.inputs){let v=x.sourceLayer,w=x.nodeIndex,T=x.tensorIndex;io(w===0,"input layer has >1 nodes"),io(T===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(T)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let v=this.inputLayers[x];if(!(v instanceof Uc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${x} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let e={},r={},o={},s={},i={},a=[],l=(x,v,w,T,k,A)=>{(T==null||k==null||A==null)&&(T=x.sourceLayer,k=x.nodeIndex,A=x.tensorIndex);let O=T.inboundNodes[k];if(w.indexOf(O)!==-1)throw new cr(`The tensor ${x.name} at layer "${T.name}" is part of a cycle.`);if(v.indexOf(O)!==-1)return;this.containerNodes.add(t.nodeKey(T,k)),T.id in i||(i[T.id]=Object.keys(i).length),w.indexOf(O)===-1&&w.push(O);let M=O.inboundLayers.length;for(let L=0;L<M;L++){let V=O.inputTensors[L],U=O.inboundLayers[L],G=O.nodeIndices[L],j=O.tensorIndices[L];l(V,v,w,U,G,j)}for(v.push(O);w.indexOf(O)>=0;)w.splice(w.indexOf(O),1);a.push(O)},u=[],c=[];for(let x of this.outputs)l(x,u,c);let p=a.slice().reverse();for(let x of p){r[x.id]=x,x.id in e||(e[x.id]=0);let v=e[x.id],w=o[x.outboundLayer.id]==null?0:o[x.outboundLayer.id];v=Math.max(v,w),o[x.outboundLayer.id]=v,s[x.outboundLayer.id]=x.outboundLayer,e[x.id]=v;for(let T=0;T<x.inboundLayers.length;T++){let k=x.inboundLayers[T],A=x.nodeIndices[T],O=k.inboundNodes[A],M=e[O.id]==null?0:e[O.id];e[O.id]=Math.max(v+1,M),r[O.id]=O}}let f={};for(let x in e){let v=e[x];v in f||(f[v]=[]),f[v].push(r[x])}let d={};for(let x in o){let v=o[x];v in d||(d[v]=[]),d[v].push(s[x])}let h=Object.keys(d).map(x=>parseInt(x,10)).sort(pg);this.layers=[];for(let x of h){let v=d[x];v.sort((w,T)=>{let k=i[w.id],A=i[T.id];return k<A?-1:k>A?1:0});for(let w of v)w instanceof t&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,h=Object.keys(f).map(x=>parseInt(x,10)).sort(pg);let g=this.inputs.slice(),m=[];for(let x of h)for(let v of f[x]){let w=v.outboundLayer;if(w!=null){for(let T of v.inputTensors)if(g.indexOf(T)===-1)throw new cr(`Graph disconnected: cannot obtain value for tensor ${T} at layer "${w.name}". The following previous layers were accessed without issue: ${m}`);for(let T of v.outputTensors)g.push(T);m.push(w.name)}}this.nodesByDepth=f;let y=this.layers.map(x=>x.name);for(let x of y){let v=y.filter(w=>w===x).length;if(v!==1)throw new cr(`The name "${x}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ma({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let n={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new P("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(let e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){let n=[];for(let e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){let r={},o=0,s=hde(n);s&&this.parseWeights(n);for(let a of this.layers)for(let[l,u]of a.weights.entries()){let c=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new P(`Duplicate weight name: ${c}`);r[c]=u,o++}let i=[];for(let a in n){let l=a;if(r[a]==null){let u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],n[a]]);else if(e)throw new P(`Provided weight data has no target variable: ${a}`);delete r[l]}if(e){let a=[];for(let l in r)a.push(l);if(a.length>0)throw new P(`${a.length} of ${o} weights are not set: ${a}`)}mh(i)}parseWeights(n){for(let e in Object.keys(n)){let r=e.split("/"),o=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!o.includes(i)).join("/");s!==e&&(n[s]=n[e],delete n[e])}}updatedConfig(){let n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion=`tfjs-layers ${xh}`,e.backend="TensorFlow.js",e}toJSON(n,e=!0){let r=a0(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return B(()=>{n=ot(n);let r=new js;for(let o=0;o<this.inputs.length;++o)r.add(this.inputs[o],n[o]);return Gc(this.outputs,r,e)})}computeMask(n,e){return B(()=>{n=ot(n);let r;return e==null?r=_o(null,n.length):r=ot(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){let e=dh(n);if(e.length!==this.inputLayers.length)throw new P(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let a=0;a<e.length;a++){let l=this.inputLayers[a],u=e[a],c=l.name+"_0_0";r[c]=u}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(pg);if(o.length>1)for(let a of o){let l=this.nodesByDepth[a];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;let p=[];for(let g=0;g<u.inboundLayers.length;g++){let m=u.inboundLayers[g],y=u.nodeIndices[g],x=u.tensorIndices[g],v=`${m.name}_${y}_${x}`,w=r[v];p.push(w)}let f=c.computeOutputShape(Nn(p)),d=dh(f),h=c.inboundNodes.indexOf(u);for(let g=0;g<d.length;g++){let m=`${c.name}_${h}_${g}`;r[m]=d[g]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${l.name}_${u}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let l=i[a];io(l in r),s.push(r[l])}return Nn(s)}runInternalGraph(n,e){e==null&&(e=_o(null,n.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=n[l],p=e[l];r[u.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(pg);for(let l of o){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,f=c.inputTensors,d=c.outputTensors,h=new Array;for(let g of f)g.id in r&&h.push(r[g.id]);if(h.length===f.length){let g={},m,y,x,v;if(c.callArgs!=null&&(g=c.callArgs),h.length===1){let[w,T]=h[0];g.mask==null&&(g.mask=T),x=ot(p.call(w,g)),v=ot(p.computeMask(w,T)),m=[w],y=[T]}else m=h.map(w=>w[0]),y=h.map(w=>w[1]),g.mask==null&&(g.mask=y),x=ot(p.call(m,g)),v=ot(p.computeMask(m,y));if(p.activityRegularizer)throw new we("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){let T=d[w],k=x[w],A=v[w];r[T.id]=[k,A]}}}}let s=[],i=[],a=[];for(let l of this.outputs){io(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];a.push(u.shape),s.push(u),i.push(c)}return[s,i,a]}buildNodeConversionMap(n){let e={},r;for(let o of this.layers){r=o instanceof t?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=t.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(e!=null)return this.findLayer(e);if(n==null)throw new P("Provide either a layer name or layer index");if(typeof n=="number")return this.findLayer(n);for(let r of this.layers)if(r.name===n)return r;throw new P(`No such layer: ${n}`)}findLayer(n){if(this.layers.length<=n)throw new P(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}calculateLosses(){return B(()=>{let n=[];for(let e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){let o=t.nodeKey(e,r);this.containerNodes.has(o)&&n.push(...e.calculateLosses())}return n})}getConfig(){let n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let a=i.getClassName(),l=i.getConfig(),u=[];for(let p=0;p<i.inboundNodes.length;p++){let f=i.inboundNodes[p],d=t.nodeKey(i,p),h={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),h=f.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(f.inboundLayers.length>0){let g=[];for(let m=0;m<f.inboundLayers.length;m++){let y=f.inboundLayers[m],x=f.nodeIndices[m],v=f.tensorIndices[m],w=t.nodeKey(y,x),T=e[w];T==null&&(T=0),g.push([y.name,T,v,h])}u.push(g)}}}let c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=t.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}n.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=t.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return n.outputLayers=s,n}static fromConfig(n,e,r={},o=!1){let s={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){let x=[],v;for(let w of y){let T=w[0],k=w[1],A=w[2];if(v=w[3]==null?{}:w[3],!(T in s)){a(m,y);return}let O=s[T];if(O.inboundNodes.length<=k){a(m,y);return}let M=O.inboundNodes[k];x.push(M.outputTensors[A])}x.length>0&&m.apply(Nn(x),v)}function u(m){let y=m.name,x=jr(m,e.customObjects!=null?e.customObjects:{});x.setFastWeightInitDuringBuild(o),s[y]=x,m.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new P(`Corrupted configuration, expected array for nodeData: ${w}`);a(x,w)})}let c=e.name,p=e.layers;for(let m of p)u(m);for(;!nW(i);)for(let m of p){let y=s[m.name];if(y.name in i){let x=i[y.name];delete i[y.name];for(let v of x)l(y,v)}}let f=[],d=[],h=e.inputLayers;for(let m of h){let y=m[0],x=m[1],v=m[2];io(y in s);let T=s[y].inboundNodes[x].outputTensors;f.push(T[v])}let g=e.outputLayers;for(let m of g){let y=m[0],x=m[1],v=m[2];io(y in s);let T=s[y].inboundNodes[x].outputTensors;d.push(T[v])}return new n({inputs:f,outputs:d,name:c})}get stateful(){if(this._stateful)throw new P("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let n of this.layers)if(n.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}};function mde(t,n,e){let r=n.length;if(t==null||Array.isArray(t)&&t.length===0)return n.map(o=>null);if(r===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){let o=[];return n.forEach(s=>{s in t?o.push(t[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}function u0(t,n){return mde(t,n,"classWeight")}function c0(t,n,e,r){return z(this,null,function*(){if(n!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=B(()=>{if(t.shape.length===1)return ir(t);if(t.shape.length===2){if(t.shape[1]>1)return As(t,1);if(t.shape[1]===1)return _(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield o.data());Ne(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Tt(i,"float32")}else return null})}function XW(t,n){return R(t,n)}var gde=32;function QW(t,n){let e,r,o=n;e=o.xs,r=o.ys,b.assert(e!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);let s=YW("input",t.inputNames,e),i=YW("output",t.outputNames,r),a=s[0].shape[0];b.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),b.assert(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<s.length;l++)b.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)b.assert(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:i}}function YW(t,n,e){if(e instanceof Pe)return[e];if(Array.isArray(e))return b.assert(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{let r=[];for(let o of n){if(e[o]==null)throw new P(`The feature data generated by the dataset lacks the required ${t} key '${o}'.`);r.push(e[o])}return r}}function yde(t){if(t.length===3)throw new we("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function JW(t,n,e){return z(this,null,function*(){let r=e.batchesPerEpoch!=null;if(b.assert(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),b.assert(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),b.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(ZW(e.validationData))b.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let m=yde(e.validationData);s=m.xs,i=m.ys}let a=t.makeTrainFunction(),l=t.getDedupedMetricsNames(),u;o?u=l.slice().concat(l.map(m=>"val_"+m)):u=l.slice();let c=QC(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:f,history:d}=JC(c,p,e.epochs,null,null,xde(n,e),null,o,u);f.setModel(t),t.history=d,yield f.onTrainBegin(),t.stopTraining_=!1;let h=e.initialEpoch==null?0:e.initialEpoch,g=yield n.iterator();for(;h<e.epochs;){let m={};yield f.onEpochBegin(h);let y=0,x=0;for(r||(g=yield n.iterator());!r||y<e.batchesPerEpoch;){let v=yield g.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){let{xs:w,ys:T}=QW(t,v.value),k={};k.batch=x,k.size=w[0].shape[0],yield f.onBatchBegin(x,k);let A=[];if(e.classWeight!=null){let L=u0(e.classWeight,t.outputNames);for(let V=0;V<L.length;++V)A.push(yield c0(T[V],null,L[V]))}let O=w.concat(T).concat(A),M=a(O);Ne(O);for(let L=0;L<l.length;++L){let V=l[L],U=M[L];k[V]=U,kt(U)}yield f.onBatchEnd(x,k),KC(k),x++,y++}if(r?y>=e.batchesPerEpoch:v.done){if(o){let w;ZW(e.validationData)?w=ot(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):w=ot(t.evaluate(s,i,{batchSize:e.validationBatchSize==null?gde:e.validationBatchSize,verbose:0}));for(let T=0;T<t.metricsNames.length;++T)m[`val_${t.metricsNames[T]}`]=w[T]}break}if(t.stopTraining_)break}if(yield f.onEpochEnd(h,m),h++,t.stopTraining_)break}return yield f.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})}function xde(t,n){let e=null;return n.batchesPerEpoch!=null?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}function ZW(t){return typeof t.iterator=="function"}function bde(t){return typeof t.next=="function"}function ej(t,n,e){return z(this,null,function*(){e=e||{};let r=e.batches!=null,o=t.testFunction,s=[];if(e.verbose>0)throw new we("Verbose mode is not implemented yet.");b.assert(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=bde(n)?n:yield n.iterator(),a=0,l=0;for(;!r||l<e.batches;){let u=yield i.next();if(s=B(()=>{if(u.value){let{xs:c,ys:p}=QW(t,u.value),f=c.concat(p),d=B(()=>o(f));if(Ne(f),l===0)for(let g=0;g<d.length;++g)s.push(se(0));let h=f[0].shape[0];for(let g=0;g<d.length;++g){let m=d[g],y=s[g];s[g]=B(()=>W(s[g],R(h,m))),l>0&&Ne(y)}Ne(d),a+=h,++l}return s}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=ne(s[u],a),Ne(c)}return Nn(s)})}function p0(t){b.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function bh(t,n,e){return t==null?[null]:Array.isArray(t)?t.map(r=>da(r,n,e-n)):da(t,n,e-n)}function f0(t,n){return B(()=>t==null?null:Array.isArray(t)?t.map(e=>f0(e,n)):UC(t,n.dtype==="int32"?n:K(n,"int32")))}function d0(t,n){let e=[],r=0,o=null;for(;r<t;)o=r+n,o>=t&&(o=t),e.push([r,o]),r=o;return e}function QD(t){let n=[];t instanceof Pe&&(t=[t]);for(let e=0;e<t.length;++e){let r=t[e];if(r.rank===1)n.push(ha(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Po(t,n){if(t==null)return;let e=[];if(n instanceof Pe)e.push(n.id);else if(Array.isArray(n))n.forEach(o=>e.push(o.id));else if(n!=null)for(let o in n){let s=n[o];e.push(s.id)}let r=[];if(t instanceof Pe)e.indexOf(t.id)===-1&&r.push(t);else if(Array.isArray(t))t.forEach(o=>{e.indexOf(o.id)===-1&&r.push(o)});else if(t!=null)for(let o in t){let s=t[o];e.indexOf(s.id)===-1&&r.push(s)}r.forEach(o=>{o.isDisposed||o.dispose()})}function vde(t){return t instanceof Pe}function JD(t){return Array.isArray(t)}function tj(t){return!vde(t)&&!JD(t)}function nj(t,n,e,r=!0,o=""){if(n==null||n.length===0){if(t!=null){let i=!1;if(JD(t)&&t.length>0)i=!0;else if(tj(t)){for(let a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new P(`Error when checking model ${o} expected no data, but got ${t}`)}return[]}if(t==null)return n.map(i=>null);let s;if(tj(t)){t=t,s=[];for(let i of n){if(t[i]==null)throw new P(`No data provided for "${i}". Need data for each key in: ${n}`);s.push(t[i])}}else if(JD(t)){if(t=t,t.length!==n.length)throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(t=t,n.length>1)throw new P(`The model ${o} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=QD(s),e!=null)for(let i=0;i<n.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new P(`Error when checking ${o}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c>=0&&u!==c)throw new P(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function wde(t,n,e){let r=Fo(t.map(s=>s.shape[0]));r.sort();let o=Fo(n.map(s=>s.shape[0]));if(o.sort(),r.length>1)throw new P(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(o.length>1)throw new P(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>0&&o.length>0&&!b.arraysEqual(r,o))throw new P(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${o[0]} target sample(s).`)}function Cde(t,n,e){let r=[jc,yh,Hc];for(let o=0;o<t.length;++o){let s=t[o],i=n[o],a=e[o];if(i!=null){if(i===Hc&&s.shape[s.shape.length-1]===1)throw new P(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){let p=l[c],f=u[c];if(f!=null&&p!==f)throw new P(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function rj(t,n,e,r=!0,o=""){let s;if(Array.isArray(t)){if(t.length!==n.length)throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(n.length>1)throw new P(`The model expects ${n.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(e!=null)for(let i=0;i<n.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new P(`Error when checking ${o}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c!==u)throw new P(`Error when checking ${o}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Ide(t,n){if(t==null||Array.isArray(t)&&t.length===0)return n.map(r=>[]);let e;if(typeof t=="string"||typeof t=="function")e=[t];else if(Array.isArray(t)||typeof t=="object")e=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(e))return n.map(r=>e);{let r=[];for(let o of n){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var Sde="layers-model",ya=(()=>{class t extends l0{constructor(e){super(e),this.isTraining=!1}summary(e,r,o=console.log){if(!this.built)throw new P("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");qW(this,e,r,o)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=HW(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Gn))throw new P("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new P(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(t0(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new P(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>t0(l))}else{let a=t0(e.loss);this.outputs.forEach(l=>{r.push(a)})}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let l=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}let o=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],as("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=Ide(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};as("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=s[a];(c=>{let p="",f,d,h;for(let g of c){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){let y=this.internalOutputShapes[a];y[y.length-1]===1||this.lossFunctions[a]===yh?["accuracy","acc"].indexOf(g)!==-1?d=r0:["crossentropy","ce"].indexOf(g)!==-1&&(d=qD):this.lossFunctions[a]===gh?["accuracy","acc"].indexOf(g)!==-1?d=KD:["crossentropy","ce"].indexOf(g)!==-1&&(d=XD):["accuracy","acc"].indexOf(g)!==-1?d=o0:["crossentropy","ce"].indexOf(g)!==-1&&(d=s0);let x;["accuracy","acc"].indexOf(g)!==-1?x="acc":["crossentropy","ce"].indexOf(g)!==-1&&(x="ce"),h=d,f=p+x}else h=WW(g),f=p+vg(g);let m;as(f,()=>{m=h}),i(a,f,m)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,o={}){let s=o.batchSize==null?32:o.batchSize;p0(s);let a=this.standardizeUserDataXY(e,r,!0,s);try{let l=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,c=this.testLoop(u,l,s,o.verbose,o.steps);return Nn(c)}finally{Po(a[0],e),Po(a[1],r)}}evaluateDataset(e,r){return z(this,null,function*(){return this.makeTestFunction(),ej(this,e,r)})}checkNumSamples(e,r,o,s="steps"){let i;if(o!=null){if(i=null,r!=null)throw new P(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new P(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,r){if(Array.isArray(r)&&r.length===0)throw new P("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(r),s=o?r:[r],i=this.retrieveSymbolicTensors(s),a=new js;if(e instanceof Pe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new P(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(let u of this.inputs){let c=e[u.name];if(c==null)throw new P(`No value is provided for the model's input ${u.name}`);a.add(u,c)}let l=Gc(i,a);return o?l:l[0]}retrieveSymbolicTensors(e){let r=_o(null,e.length),o=e.length;for(let s of this.layers){let i=Array.isArray(s.output)?s.output:[s.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){let u=a.indexOf(e[l]);if(u!==-1&&(r[l]=i[u],o--),o===0)break}if(o===0)break}if(o>0){let s=[];throw r.forEach((i,a)=>{i==null&&s.push(e[a])}),new P(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,o=!1){return B(()=>{let s=this.checkNumSamples(e);if(o)throw new we("Verbose predictLoop() is not implemented yet.");let i=d0(s,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)B(()=>{let c=i[l][0],p=i[l][1],f=bh(e,c,p),d=[];if(Array.isArray(f))for(let g=0;g<f.length;++g)d.push({key:this.inputs[g],value:f[g]});else d.push({key:this.inputs[0],value:f});let h=new js(d);return Gc(this.outputs,h)}).forEach((c,p)=>a[p].push(c));return Nn(a.map(l=>Je(l,0)))})}predict(e,r={}){let o=QD(e);rj(o,this.inputNames,this.feedInputShapes,!1);try{let s=r.batchSize==null?32:r.batchSize;return p0(s),this.predictLoop(o,s)}finally{Po(o,e)}}predictOnBatch(e){rj(e,this.inputNames,this.feedInputShapes,!0);let r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,o=!0,s){if(this.optimizer_==null)throw new cr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let a=0;a<this.feedOutputShapes.length;++a){let l=this.feedOutputShapes[a];this.feedLossFns[a]===gh?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=nj(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=nj(r,this.feedOutputNames,i,!1,"target"),wde(e,r,null),Cde(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new P(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,o,s,i=!0,a){return z(this,null,function*(){let[l,u]=this.standardizeUserDataXY(e,r,i,a);if(o!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){let p=u0(s,this.outputNames);c=[];for(let f=0;f<p.length;++f)c.push(yield c0(u[f],null,p[f]))}return[l,u,c]})}testLoop(e,r,o,s=0,i){return B(()=>{let a=this.checkNumSamples(r,o,i,"steps"),l=[];if(s>0)throw new we("Verbose mode is not implemented yet.");if(i!=null)throw new we("steps mode in testLoop() is not implemented yet");{let u=d0(a,o),c=Tt(fr(0,a));for(let p=0;p<u.length;++p){let f=u[p][0],d=u[p][1],h=da(c,f,d-f),g=f0(r,h),m=e(g);if(p===0)for(let y=0;y<m.length;++y)l.push(se(0));for(let y=0;y<m.length;++y){let x=m[y];l[y]=W(l[y],R(d-f,x))}}for(let p=0;p<l.length;++p)l[p]=ne(l[p],a)}return l})}getDedupedMetricsNames(){let e=this.metricsNames,r=[];for(let o=0;o<e.length;++o){let s=e[o],i=s;if(RD(e,s)>1){let a=RD(e.slice(0,o),s);i+=`_${a}`}r.push(i)}return r}makeTrainFunction(){return e=>{let r=[],o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],l=()=>{let f=[];for(let m=0;m<this.inputs.length;++m)f.push({key:this.inputs[m],value:o[m]});let d=new js(f),h=Gc(this.outputs,d,{training:!0}),g;for(let m=0;m<this.lossFunctions.length;++m){let y=this.lossFunctions[m],x=y(s[m],h[m]);i[m]!=null&&(x=XW(x,i[m]));let v=xt(x);r.push(v),m===0?g=x:g=W(g,x)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{let x=this.metricsTensors[m][0],v=this.metricsTensors[m][1];y=xt(x(s[v],h[v]))}kt(y),a.push(y)}return g=xt(g),this.calculateLosses().forEach(m=>{g=W(g,m)}),g},u=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(l,!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>B(()=>{let r=[],o,s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:s[c]});let l=new js(a),u=Gc(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){let p=this.lossFunctions[c],f=xt(p(i[c],u[c]));c===0?o=f:o=W(o,f),r.push(o)}for(let c=0;c<this.metricsTensors.length;++c){let p=this.metricsTensors[c][0],f=this.metricsTensors[c][1],d=xt(p(i[f],u[f]));r.push(d)}return r})}fit(s,i){return z(this,arguments,function*(e,r,o={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,l,u,c,p,f,d,h,g;try{let m=o.batchSize==null?32:o.batchSize;p0(m);let x=yield this.standardizeUserData(e,r,o.sampleWeight,o.classWeight,!1,m);a=x[0],l=x[1],g=x[2];let v=!1,w;if(o.validationData!=null&&o.validationData.length>0){if(v=!0,o.validationData.length===2)p=o.validationData[0],f=o.validationData[1];else throw o.validationData.length===3?new we("validationData including sample weights is not supported yet."):new P(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);let G=yield this.standardizeUserData(p,f,null,null,!0,m);d=G[0],h=G[1],w=d.concat(h)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){v=!0;let U=Math.floor(a[0].shape[0]*(1-o.validationSplit)),G=a[0].shape[0];d=bh(a,U,G),u=a,a=bh(a,0,U),h=bh(l,U,G),c=l,l=bh(l,0,U),w=d.concat(h)}else o.validationSteps!=null&&(v=!0);let T=a.concat(l).concat(g);this.checkTrainableWeightsConsistency();let k=this.makeTrainFunction(),A=this.getDedupedMetricsNames(),O,M;v?(this.makeTestFunction(),O=this.testFunction,M=A.slice().concat(A.map(U=>"val_"+U))):(O=null,w=[],M=A.slice());let L=QC(o.callbacks,o.yieldEvery);return yield this.fitLoop(k,T,A,m,o.epochs,o.verbose,L,O,w,o.shuffle,M,o.initialEpoch,null,null)}finally{this.isTraining=!1,Po(a,e),Po(l,r),Po(u,e),Po(c,r),Po(d,p),Po(h,f),g!=null&&Ne(g)}})}fitLoop(e,r,o,s,i,a,l,u,c,p,f,d,h,g){return z(this,null,function*(){s==null&&(s=32),i==null&&(i=1),p==null&&(p=!0),d==null&&(d=0);let m=!1;if(u!=null&&c!=null&&(m=!0),g!=null&&(m=!0,h==null))throw new P("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y=this.checkNumSamples(r,s,h,"steps_per_epoch"),x;y!=null&&(x=fr(0,y)),a==null&&(a=1);let{callbackList:v,history:w}=JC(l,a,i,d,y,h,s,m,f);v.setModel(this),this.history=w,yield v.onTrainBegin(),this.stopTraining_=!1;for(let T=d;T<i;++T){yield v.onEpochBegin(T);let k={};if(h!=null)throw new we("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new we("batch shuffling is not implemneted yet");p&&b.shuffle(x);let A=Tt(x),O=d0(y,s);for(let M=0;M<O.length;++M){let L={};if(yield v.onBatchBegin(M,L),B(()=>{let V=O[M][0],U=O[M][1],G=da(A,V,U-V);L.batch=M,L.size=U-V;let j=f0(r,G),H=e(j);for(let Y=0;Y<o.length;++Y){let Q=o[Y],X=H[Y];L[Q]=X,kt(X)}if(M===O.length-1&&m){let Y=this.testLoop(u,c,s);for(let Q=0;Q<o.length;++Q){let X=o[Q],J=Y[Q];kt(J),k["val_"+X]=J}}}),yield v.onBatchEnd(M,L),KC(L),this.stopTraining_)break}A.dispose()}if(yield v.onEpochEnd(T,k),this.stopTraining_)break}return yield v.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(e,r){return z(this,null,function*(){return JW(this,e,r)})}trainOnBatch(e,r){return z(this,null,function*(){let o=yield this.standardizeUserData(e,r),s=o[0],i=o[1],l=this.makeTrainFunction()(s.concat(i)),u=[];for(let c of l){let p=yield c.data();u.push(p[0])}return Ne(l),Po(o[0],e),Po(o[1],r),Nn(u)})}getNamedWeights(e){let r=[],o=e!=null&&e.trainableOnly,s=o?this.trainableWeights:this.weights,i=this.getWeights(o);for(let a=0;a<s.length;++a)o&&!s[a].trainable||r.push({name:s[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let r=km().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-km().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Oo(this.loss);else if(Array.isArray(this.loss)){for(let r of this.loss)if(typeof r!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Oo(r))}else{let r=Object.keys(this.loss);e={};let o=this.loss;for(let s of r)if(typeof o[s]=="string")e[s]=Oo(o[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Oo(vg(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Oo(vg(e)));{let e={};for(let r in this.metrics)e[r]=Oo(vg(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let r=wg(e.optimizer_config),o=jr(r),s;if(typeof e.loss=="string")s=fa(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>fa(a));else if(e.loss!=null){s={};for(let a in e.loss)s[a]=fa(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>fa(a));else if(e.metrics!=null){i={};for(let a in e.metrics)i[a]=fa(e.metrics[a])}this.compile({loss:s,metrics:i,optimizer:o})}save(e,r){return z(this,null,function*(){if(typeof e=="string"){let c=Jo.getSaveHandlers(e);if(c.length===0)throw new P(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new P(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new P("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=yield Jo.encodeWeights(this.getNamedWeights(r)),l={modelTopology:this.toJSON(null,!1),format:Sde,generatedBy:`TensorFlow.js tfjs-layers v${xh}`,convertedBy:null};if((r==null?!1:r.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();let c="optimizer",{data:p,specs:f}=yield Jo.encodeWeights(yield this.optimizer.getWeights(),c);o.specs.push(...f),o.data=Jo.concatenateArrayBuffers([o.data,p])}return this.userDefinedMetadata!=null&&(ZD(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=o.data,l.weightSpecs=o.specs,e.save(l)})}setUserDefinedMetadata(e){ZD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();q.registerClass(ya);var Tde=(()=>{class t extends ya{}return t.className="Functional",t})();q.registerClass(Tde);var e1=(()=>{class t extends ya{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:iu("sequential_"),e.layers!=null)for(let r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new P(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let r=e instanceof t||e instanceof ya,o;if(r){if(o=e,o.outputs.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new P("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new P("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=WD({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=o.outputs,this.inputs=o.inputs;else{if(e.inboundNodes.length!==1)throw new P(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=GD(this.outputs[0])}this.inboundNodes=[],new ma({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:_o(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return this.model==null&&this.build(),this.model.call(e,r)}build(e){if(Re(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ya({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,o=console.log){this.built||this.build(),super.summary(e,r,o)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,r,o={}){if(!this.built)throw new cr("The model needs to be compiled before being used.");return this.model.evaluate(e,r,o)}evaluateDataset(e,r){return z(this,null,function*(){if(!this.built)throw new cr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,r)})}predict(e,r={}){return this.model==null&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(s,i){return z(this,arguments,function*(e,r,o={}){if(!this.built)throw new cr("The model needs to be compiled before being used.");return this.model.fit(e,r,o)})}fitDataset(e,r){return z(this,null,function*(){if(!this.built)throw new cr("The model needs to be compiled before being used.");return this.model.fitDataset(e,r)})}trainOnBatch(e,r){return z(this,null,function*(){return this.model.trainOnBatch(e,r)})}static fromConfig(e,r,o={},s=!1){let i,a={};if(r instanceof Array){if(r[0].className==null||r[0].className==="Merge")throw new P("Legacy serialization format not supported yet.");i=r}else b.assert(r.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;let l=new e(a);if(!(l instanceof t))throw new we(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(let u of i){let p=jr(u,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),l.add(p)}return l}set stopTraining(e){if(this.model==null)throw new P("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new P("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let r of this.layers){let o={};o.className=r.getClassName(),o.config=r.getConfig(),e.push(o)}return{name:this.name,layers:e}}}return t.className="Sequential",t})();q.registerClass(e1);var $n=class extends q.Serializable{getConfig(){return{}}},Ede=(()=>{class t extends $n{apply(e,r=1){return yW(e,r)}}return t.className="elu",t})();q.registerClass(Ede);var Dde=(()=>{class t extends $n{apply(e){return bd(e)}}return t.className="selu",t})();q.registerClass(Dde);var kde=(()=>{class t extends $n{apply(e){return Fn(e)}}return t.className="relu",t})();q.registerClass(kde);var Ade=(()=>{class t extends $n{apply(e){return B(()=>ro(6,Fn(e)))}}return t.className="relu6",t})();q.registerClass(Ade);var Rde=(()=>{class t extends $n{apply(e){return e}}return t.className="linear",t})();q.registerClass(Rde);var _de=(()=>{class t extends $n{apply(e){return _n(e)}}return t.className="sigmoid",t})();q.registerClass(_de);var Ode=(()=>{class t extends $n{apply(e){return bW(e)}}return t.className="hardSigmoid",t})();q.registerClass(Ode);var Fde=(()=>{class t extends $n{apply(e){return Yo(e)}}return t.className="softplus",t})();q.registerClass(Fde);var Mde=(()=>{class t extends $n{apply(e){return xW(e)}}return t.className="softsign",t})();q.registerClass(Mde);var $de=(()=>{class t extends $n{apply(e){return Xo(e)}}return t.className="tanh",t})();q.registerClass($de);var n1=(()=>{class t extends $n{apply(e,r=-1){return ql(e,r)}}return t.className="softmax",t})();q.registerClass(n1);var Pde=(()=>{class t extends $n{apply(e,r=-1){return hd(e,r)}}return t.className="logSoftmax",t})();q.registerClass(Pde);var Lde=(()=>{class t extends $n{apply(e){return B(()=>B(()=>{let r=Math.sqrt(2),o=R(.5,W(1,dd(ne(e,r))));return R(e,o)}))}}return t.className="gelu",t})();q.registerClass(Lde);var Bde=(()=>{class t extends $n{apply(e){return B(()=>R(.5,R(e,W(1,Xo(R(ct(ne(2,Math.PI)),W(e,R(.044715,zn(e,3)))))))))}}return t.className="gelu_new",t})();q.registerClass(Bde);var zde=(()=>{class t extends $n{apply(e){return B(()=>R(e,Xo(Yo(e))))}}return t.className="mish",t})();q.registerClass(zde);var Vde=(()=>{class t extends $n{apply(e,r=1){return B(()=>R(_n(R(e,r)),e))}}return t.className="swish",t})();q.registerClass(Vde);function us(t){return t.getClassName()}function t1(t,n={}){return Gs(t,q.SerializationMap.getMap().classNameMap,n,"activation")}function cs(t){if(t==null){let n={};return n.className="linear",n.config={},t1(n)}if(typeof t=="string"){let n={};return n.className=t,n.config={},t1(n)}else return t instanceof $n?t:t1(t)}function Ude(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}var h0=class extends q.Serializable{},ij=(()=>{class t extends h0{constructor(e){super(),Ude(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let r=bt([1]);return this.hasL1&&(r=W(r,ie(R(this.l1,St(e))))),this.hasL2&&(r=W(r,ie(R(this.l2,Vc(e))))),_(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})();q.registerClass(ij);var oj={l1l2:"L1L2"};function it(t){return uh(t)}function sj(t,n={}){return Gs(t,q.SerializationMap.getMap().classNameMap,n,"regularizer")}function mt(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in oj?oj[t]:t,config:{}};return sj(e)}else return t instanceof h0?t:sj(t)}var aj=(()=>{class t extends Ce{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,r){e=xe(e);let o=Fn(e);return this.maxValue!=null&&(o=vn(o,0,this.maxValue)),o}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})();q.registerClass(aj);var lj=(()=>{class t extends Ce{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=xe(e);return zl(o,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})();q.registerClass(lj);var uj=(()=>{class t extends Ce{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=pt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=mt(e.alphaRegularizer),this.alphaConstraint=Gt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new P(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Re(e);let r=e.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)o[s]=e[s];this.inputSpec=[new ht({ndim:e.length,axes:o})],this.built=!0}call(e,r){return e=xe(e),Hl(e,this.alpha.read())}getConfig(){let e={alphaInitializer:vt(this.alphaInitializer),alphaRegularizer:it(this.alphaRegularizer),alphaConstraint:Ut(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})();q.registerClass(uj);var cj=(()=>{class t extends Ce{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new we(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=xe(e);return Ms(o)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})();q.registerClass(cj);var pj=(()=>{class t extends Ce{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,r){let o=xe(e);return R(o,K(Lt(o,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})();q.registerClass(pj);var fj=(()=>{class t extends Ce{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new n1().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,r){return B(()=>{let o=xe(e),s=r.mask;if(s!=null){let i=R(te(en(o.shape),K(s,o.dtype)),se(-1e9));o=W(o,i)}return this.axis instanceof Array?this.axis.length>1?Ht(te(o,Ul(o,this.axis,!0))):this.softmax(o,this.axis[0]):this.softmax(o,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})();q.registerClass(fj);function uu(t,n,e){if(typeof t=="number")return _o(t,n);if(t.length!==n)throw new P(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){let o=t[r];if(!dW(o))throw new P(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${o}`)}return t}function Er(t,n,e,r,o=1){if(t==null)return t;let s=n+(n-1)*(o-1),i;return e==="same"?i=t:i=t-s+1,Math.floor((i+r-1)/r)}function ps(t,n,e,r){if(t==null)return null;if(r==="valid")t=t*n+ls([e-n,0]);else if(r==="same")t=t*n;else throw new P(`Unsupport padding mode: ${r}.`);return t}function Ig(t,n){return B(()=>(Rt(n),n==="channelsFirst"?Me(t,[0,2,3,1]):t))}function r1(t,n){return B(()=>(Rt(n),n==="channelsFirst"?Me(t,[0,2,3,4,1]):t))}function Wde(t,n,e,r=1,o="valid",s,i=1){return B(()=>{if(s==null&&(s=dr()),Rt(s),t.shape.length!==3)throw new P(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(n.shape.length!==3)throw new P(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new P(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(t=Me(t,[0,2,1])),o==="causal")throw new we("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=ld(t,n,r,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=hr(a,e)),a})}function dj(t,n,e,r=[1,1],o="valid",s,i,a=null){return B(()=>{if(s==null&&(s=dr()),Rt(s),t.rank!==3&&t.rank!==4)throw new P(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(n.rank!==3&&n.rank!==4)throw new P(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=Ig(t,s);if(o==="causal")throw new we("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Yl.conv2d({x:l,filter:n,strides:r,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(l=Me(l,[0,3,1,2])),l})}function jde(t,n,e,r=[1,1,1],o="valid",s,i){return B(()=>{if(s==null&&(s=dr()),Rt(s),t.rank!==4&&t.rank!==5)throw new P(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(n.rank!==4&&n.rank!==5)throw new P(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=r1(t,s);if(o==="causal")throw new we("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=cb(a,n,r,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=hr(a,e)),s==="channelsFirst"&&(a=Me(a,[0,4,1,2,3])),a})}var Cg=class t extends Ce{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyArgs(e),this.rank=n,Qt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new we(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=uu(e.kernelSize,n,"kernelSize"),this.strides=uu(e.strides==null?1:e.strides,n,"strides"),this.padding=e.padding==null?"valid":e.padding,pr(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Rt(this.dataFormat),this.activation=cs(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Gt(e.biasConstraint),this.biasRegularizer=mt(e.biasRegularizer),this.activityRegularizer=mt(e.activityRegularizer),this.dilationRate=uu(e.dilationRate==null?1:e.dilationRate,n,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new P(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new P(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new P(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(n){if(io("kernelSize"in n,"required key 'kernelSize' not in config"),typeof n.kernelSize!="number"&&!FC(n.kernelSize,"number",1,3))throw new P(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){let n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:us(this.activation),useBias:this.useBias,biasInitializer:vt(this.biasInitializer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),biasConstraint:Ut(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}},vh=class t extends Cg{constructor(n,e){super(n,e),this.kernel=null,t.verifyArgs(e),this.filters=e.filters,Qt(this.filters,"filters"),this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Gt(e.kernelConstraint),this.kernelRegularizer=mt(e.kernelRegularizer)}build(n){n=Re(n);let e=this.dataFormat==="channelsFirst"?1:n.length-1;if(n[e]==null)throw new P(`The channel dimension of the input should be defined. Found ${n[e]}`);let r=n[e],o=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return B(()=>{n=xe(n);let r,o=this.bias==null?null:this.bias.read(),s=MC(this.activation.getClassName());if(s!=null&&this.rank===2)r=dj(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=Wde(n,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=dj(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=jde(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new we("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=Re(n);let e=[],r=this.dataFormat==="channelsLast"?n.slice(1,n.length-1):n.slice(2);for(let s=0;s<r.length;++s){let i=Er(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[n[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let n={filters:this.filters,kernelInitializer:vt(this.kernelInitializer),kernelRegularizer:it(this.kernelRegularizer),kernelConstraint:Ut(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||typeof n.filters!="number"||n.filters<1)throw new P(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}},o1=(()=>{class t extends vh{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!FC(e.kernelSize,"number",1,2))throw new P(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();q.registerClass(o1);var s1=(()=>{class t extends vh{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new P(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();q.registerClass(s1);var hj=(()=>{class t extends o1{constructor(e){if(super(e),this.inputSpec=[new ht({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Re(e),e.length!==4)throw new P("Input should have rank 4; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ht({ndim:4,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{let o=xe(e);if(o.shape.length!==4)throw new P(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l;this.dataFormat==="channelsFirst"?(a=2,l=3):(a=1,l=2);let u=s[a],c=s[l],p=this.kernelSize[0],f=this.kernelSize[1],d=this.strides[0],h=this.strides[1],g=ps(u,d,p,this.padding),m=ps(c,h,f,this.padding),y=[i,g,m,this.filters];this.dataFormat!=="channelsLast"&&(o=Me(o,[0,2,3,1]));let x=cd(o,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=Me(x,[0,3,1,2])),this.bias!=null&&(x=hr(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Re(e);let r=e.slice(),o,s,i;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3):(o=3,s=1,i=2);let a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[o]=this.filters,r[s]=ps(r[s],u,a,this.padding),r[i]=ps(r[i],c,l,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})();q.registerClass(hj);var mj=(()=>{class t extends s1{constructor(e){if(super(e),this.inputSpec=[new ht({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Re(e),e.length!==5)throw new P("Input should have rank 5; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ht({ndim:5,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{let o=xe(e);if(o.shape.length!==5)throw new P(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l,u;this.dataFormat==="channelsFirst"?(u=2,a=3,l=4):(u=1,a=2,l=3);let c=s[u],p=s[a],f=s[l],d=this.kernelSize[0],h=this.kernelSize[1],g=this.kernelSize[2],m=this.strides[0],y=this.strides[1],x=this.strides[2],v=ps(c,m,d,this.padding),w=ps(p,y,h,this.padding),T=ps(f,x,g,this.padding),k=[i,v,w,T,this.filters];this.dataFormat!=="channelsLast"&&(o=Me(o,[0,2,3,4,1]));let A=fb(o,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=Me(A,[0,4,1,2,3])),this.bias!==null&&(A=hr(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=Re(e);let r=e.slice(),o,s,i,a;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3,a=4):(o=4,s=1,i=2,a=3);let l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],p=this.strides[0],f=this.strides[1],d=this.strides[2];return r[o]=this.filters,r[s]=ps(r[s],p,l,this.padding),r[i]=ps(r[i],f,u,this.padding),r[a]=ps(r[a],d,c,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})();q.registerClass(mj);var Hde=(()=>{class t extends vh{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,r.filters==null)throw new P("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(r.kernelInitializer!=null||r.kernelRegularizer!=null||r.kernelConstraint!=null)throw new P("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(r.padding!=null&&r.padding!=="same"&&r.padding!=="valid")throw new P(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier==null?1:r.depthMultiplier,this.depthwiseInitializer=pt(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=mt(r.depthwiseRegularizer),this.depthwiseConstraint=Gt(r.depthwiseConstraint),this.pointwiseInitializer=pt(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=mt(r.pointwiseRegularizer),this.pointwiseConstraint=Gt(r.pointwiseConstraint)}build(e){if(e=Re(e),e.length<this.rank+2)throw new P(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null||e[r]<0)throw new P(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);let o=e[r],s=this.kernelSize.concat([o,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(o*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ht({ndim:this.rank+2,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{e=xe(e);let o;if(this.rank===1)throw new we("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Me(e,[0,2,3,1])),o=vd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=hr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=Me(o,[0,3,1,2])),o})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=vt(this.depthwiseInitializer),e.pointwiseInitializer=vt(this.pointwiseInitializer),e.depthwiseRegularizer=it(this.depthwiseRegularizer),e.pointwiseRegularizer=it(this.pointwiseRegularizer),e.depthwiseConstraint=Ut(this.depthwiseConstraint),e.pointwiseConstraint=Ut(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();var gj=(()=>{class t extends Hde{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})();q.registerClass(gj);var yj=(()=>{class t extends vh{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!FC(e.kernelSize,"number",1,1))throw new P(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})();q.registerClass(yj);var xj=(()=>{class t extends Ce{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return B(()=>{if(e=xe(e),this.dataFormat==="channelsLast"){let o=dg(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return dg(o,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=dg(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return dg(o,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})();q.registerClass(xj);var bj=(()=>{class t extends Ce{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Rt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,pW(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let r=e[2]==null?null:this.size[0]*e[2],o=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],r,o]}else{let r=e[1]==null?null:this.size[0]*e[1],o=e[2]==null?null:this.size[1]*e[2];return[e[0],r,o,e[3]]}}call(e,r){return B(()=>{let o=xe(e),s=o.shape;if(this.dataFormat==="channelsFirst"){o=Me(o,[0,2,3,1]);let i=this.size[0]*s[2],a=this.size[1]*s[3],l=this.interpolation==="nearest"?In.resizeNearestNeighbor(o,[i,a]):In.resizeBilinear(o,[i,a]);return Me(l,[0,3,1,2])}else{let i=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?In.resizeNearestNeighbor(o,[i,a]):In.resizeBilinear(o,[i,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})();q.registerClass(bj);function qde(t,n,e=[1,1],r="valid",o,s){return B(()=>{o==null&&(o=dr()),Rt(o);let i=Ig(t,o);if(t.rank!==4)throw new P(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(n.rank!==4)throw new P(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=Fs(i,n,e,r==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}var vj=(()=>{class t extends Cg{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=pt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Gt(e.depthwiseConstraint),this.depthwiseRegularizer=mt(e.depthwiseRegularizer)}build(e){if(e=Re(e),e.length<4)throw new P(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let r=this.dataFormat==="channelsFirst"?1:3;if(e[r]==null||e[r]<0)throw new P(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);let o=e[r],s=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{e=xe(e);let o=qde(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=hr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(e){e=Re(e);let r=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Er(r,this.kernelSize[0],this.padding,this.strides[0]),a=Er(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,a]:[e[0],i,a,s]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=vt(this.depthwiseInitializer),e.depthwiseRegularizer=it(this.depthwiseRegularizer),e.depthwiseConstraint=Ut(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})();q.registerClass(vj);function i1(t,n,e,r){if(Array.isArray(t)){if(n!=null||e!=null)throw new P("When inputs is an array, neither initialState or constants should be provided");r!=null&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return n=o(n),e=o(e),{inputs:t,initialState:n,constants:e}}function a1(t,n,e,r=!1,o,s,i=!1,a=!1){return B(()=>{let l=n.shape.length;if(l<3)throw new P(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(fr(2,l));if(n=Me(n,u),s!=null)throw new we("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=K(K(o,"bool"),"float32"),o.rank===l-1&&(o=Pt(o,-1)),o=Me(o,u)),r&&(n=un(n,0),o!=null&&(o=un(o,0)));let c=[],p,f=e,d=n.shape[0],h=pn(n),g;o!=null&&(g=pn(o));for(let y=0;y<d;++y){let x=h[y],v=B(()=>t(x,f));if(o==null)p=v[0],f=v[1];else{let w=B(()=>{let T=g[y],k=te(hn(T),T),A=W(R(v[0],T),R(f[0],k)),O=f.map((M,L)=>W(R(v[1][L],T),R(M,k)));return{output:A,newStates:O}});p=w.output,f=w.newStates}a&&c.push(p)}let m;return a&&(m=Bt(c,1)),[p,m,f]})}var pu=(()=>{class t extends Ce{constructor(e){super(e);let r;if(e.cell==null)throw new P("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?r=new c1({cells:e.cell}):r=e.cell,r.stateSize==null)throw new P("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ht({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return fr(0,e).map(r=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){jC(e)&&(e=e[0]),e=e;let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let o=r[0],s;if(this.returnSequences?s=[e[0],e[1],o]:s=[e[0],o],this.returnState){let i=[];for(let a of r)i.push([e[0],a]);return[s].concat(i)}else return s}computeMask(e,r){return B(()=>{Array.isArray(r)&&(r=r[0]);let o=this.returnSequences?r:null;if(this.returnState){let s=this.states.map(i=>null);return[o].concat(s)}else return o})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let o=0;o<e;++o)r.push(null);return r}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new we("Constants support is not implemented in RNN yet.");jC(e)&&(e=e[0]),e=e;let o=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new ht({shape:[o,null,...s]});let i=[e[0]].concat(e.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new P(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new ht({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new so("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>bt([o,s])):this.states_=[bt([o,this.cell.stateSize])];else if(e==null)Ne(this.states_),this.keptStates!=null&&(Ne(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>bt([o,s])):this.states_[0]=bt([o,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r===!0?this.keptStates.push(this.states_.slice()):Ne(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[o,a];if(!b.arraysEqual(i.shape,l))throw new P(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>kt(s.clone()))})}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=i1(e,o,s,this.numConstants);e=i.inputs,o=i.initialState,s=i.constants;let a=[],l=[];if(o!=null){r.initialState=o,a=a.concat(o),this.stateSpec=[];for(let c of o)this.stateSpec.push(new ht({shape:c.shape}));l=l.concat(this.stateSpec)}if(s!=null&&(r.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof tr){let c=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(c,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return B(()=>{let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;e=xe(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new P(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let l={training:s},c=a1((g,m)=>{let y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,o,null,this.unroll,this.returnSequences),p=c[0],f=c[1],d=c[2];this.stateful&&this.resetStates(d,s);let h=this.returnSequences?f:p;return this.returnState?[h].concat(d):h})}getInitialState(e){return B(()=>{let r=bt(e.shape);return r=ie(r,[1,2]),r=ha(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?VC(r,[1,o]):r):this.cell.stateSize>1?[VC(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(r.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:o}),Object.assign(Object.assign(Object.assign({},o),e),r)}static fromConfig(e,r,o={}){let s=r.cell,i=jr(s,o);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();q.registerClass(pu);var cu=class extends Ce{},l1=(()=>{class t extends cu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Qt(this.units,"units"),this.activation=cs(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=zc([1,ls([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zc([1,ls([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Re(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{if(e=e,e.length!==2)throw new P(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let o=e[1];e=e[0];let s=r.training==null?!1:r.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>hn(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>hn(o),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,l=this.recurrentDropoutMask;a!=null?i=$o(R(e,a),this.kernel.read()):i=$o(e,this.kernel.read()),this.bias!=null&&(i=hr(i,this.bias.read())),l!=null&&(o=R(o,l));let u=W(i,$o(o,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:us(this.activation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();q.registerClass(l1);var wj=(()=>{class t extends pu{constructor(e){e.cell=new l1(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Ne(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ne(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})();q.registerClass(wj);var u1=(()=>{class t extends cu{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new P("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Qt(this.units,"units"),this.activation=cs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=zc([1,ls([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zc([1,ls([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Re(e);let r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{if(e=e,e.length!==2)throw new P(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training==null?!1:r.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>hn(e),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>hn(s),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,l,u,c;0<this.dropout&&this.dropout<1&&(e=R(e,i[0]));let p=$o(e,this.kernel.read());this.useBias&&(p=hr(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=R(s,a[0]));let f=this.recurrentKernel.read(),[d,h]=cn(f,[2*this.units,this.units],f.rank-1),g=$o(s,d),[m,y,x]=cn(p,3,p.rank-1),[v,w]=cn(g,2,g.rank-1);l=this.recurrentActivation.apply(W(m,v)),u=this.recurrentActivation.apply(W(y,w));let T=$o(R(u,s),h);c=this.activation.apply(W(x,T));let k=W(R(l,s),R(W(1,$e(l)),c));return[k,k]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:us(this.activation),recurrentActivation:us(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();q.registerClass(u1);var Cj=(()=>{class t extends pu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new u1(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Ne(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ne(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return t.className="GRU",t})();q.registerClass(Cj);var Sg=(()=>{class t extends cu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Qt(this.units,"units"),this.activation=cs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=zc([1,ls([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zc([1,ls([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;e=Re(e);let o=e[e.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,a=this.units;s=new(r=class extends mr{apply(u,c){let p=i.apply([a]),f=new WC().apply([a]),d=i.apply([a*2]);return $D($D(p,f),d)}},r.className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return B(()=>{let o=r.training==null?!1:r.training;if(e=e,e.length!==3)throw new P(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>hn(e),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>hn(s),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,l=this.recurrentDropoutMask,u,c,p,f;0<this.dropout&&this.dropout<1&&(e=R(e,a[0]));let d=$o(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=R(s,l[0])),d=W(d,$o(s,this.recurrentKernel.read())),this.useBias&&(d=hr(d,this.bias.read()));let[h,g,m,y]=cn(d,4,d.rank-1);u=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(g),p=W(R(c,i),R(u,this.activation.apply(m))),f=this.recurrentActivation.apply(y);let x=R(f,this.activation.apply(p));return[x,x,p]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:us(this.activation),recurrentActivation:us(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();q.registerClass(Sg);var Ij=(()=>{class t extends pu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Sg(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Ne(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ne(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})();q.registerClass(Ij);var c1=(()=>{class t extends cu{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return B(()=>{e=e;let o=e.slice(1),s=[];for(let l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(o.splice(0,l.stateSize.length)):s.push(o.splice(0,1));s.reverse();let i=[],a;for(let l=0;l<this.cells.length;++l){let u=this.cells[l];o=s[l],l===0?a=[e[0]].concat(o):a=[a[0]].concat(o),a=u.call(a,r),i.push(a.slice(1))}o=[];for(let l of i.slice().reverse())o.push(...l);return[a[0]].concat(o)})}build(e){jC(e)&&(e=e[0]),e=e;let r;this.cells.forEach((o,s)=>{as(`RNNCell_${s}`,()=>{o.build(e),Array.isArray(o.stateSize)?r=o.stateSize[0]:r=o.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){let e=super.getConfig(),r=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(r)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,o={}){let s=[];for(let i of r.cells)s.push(jr(i,o));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){let r=[];for(let o of this.cells)r.push(...o.trainableWeights);return r.concat(e)}return e}getWeights(){let e=[];for(let r of this.cells)e.push(...r.weights);return mg(e)}setWeights(e){let r=[];for(let o of this.cells){let s=o.weights.length,i=e.splice(s);for(let a=0;a<o.weights.length;++a)r.push([o.weights[a],i[a]])}mh(r)}}return t.className="StackedRNNCells",t})();q.registerClass(c1);function xa(t){let{ones:n,rate:e,training:r=!1,count:o=1,dropoutFunc:s}=t,i=()=>s!=null?s(n(),e):GC(n(),e),a=()=>au(i,n,r);return!o||o<=1?kt(a().clone()):Array(o).fill(void 0).map(a).map(u=>kt(u.clone()))}var Kde=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,r=Object.getOwnPropertySymbols(t);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(e[r[o]]=t[r[o]]);return e};var Xde=(()=>{class t extends pu{constructor(e){if(e.unroll)throw new we("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new we("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ht({ndim:5})]}call(e,r){return B(()=>{if(this.cell.dropoutMask!=null&&(Ne(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ne(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new P("ConvRNN2D cell does not support constants");let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return B(()=>{let{stateSize:r}=this.cell,o=e.shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)],a=bt(i);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new so("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)];if(o[0]==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>bt(i)):this.states_=[bt(i)];else if(e==null)Ne(this.states_),this.keptStates!=null&&(Ne(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>bt(i)):this.states_[0]=bt(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Ne(this.states_);for(let l=0;l<this.states_.length;++l){let u=e[l],c=i;if(!b.arraysEqual(u.shape,c))throw new P(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>kt(l.clone()))})}computeSingleOutputShape(e){let{dataFormat:r,filters:o,kernelSize:s,padding:i,strides:a,dilationRate:l}=this.cell,u=r==="channelsFirst",c=e[u?3:2],p=e[u?4:3],f=Er(c,s[0],i,a[0],l[0]),d=Er(p,s[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[o,f,d]:[f,d,o]]}}return t.className="ConvRNN2D",t})(),p1=(()=>{class t extends Sg{constructor(e){let{filters:r,kernelSize:o,strides:s,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Qt(this.filters,"filters"),this.kernelSize=uu(o,2,"kernelSize"),this.kernelSize.forEach(u=>Qt(u,"kernelSize")),this.strides=uu(s||1,2,"strides"),this.strides.forEach(u=>Qt(u,"strides")),this.padding=i||"valid",pr(this.padding),this.dataFormat=a||"channelsLast",Rt(this.dataFormat),this.dilationRate=uu(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Qt(u,"dilationRate"))}build(e){var r;e=Re(e);let o=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[o]==null)throw new P(`The channel dimension of the input should be defined. Found ${e[o]}`);let s=e[o],i=4,a=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let c=this.biasInitializer,p=this.filters;u=new(r=class extends mr{apply(d,h){let g=c.apply([p]),m=en([p]),y=c.apply([p*2]);return ph([g,m,y])}},r.className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return B(()=>{if(e.length!==3)throw new P(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training||!1,s=e[0],i=e[1],a=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xa({ones:()=>hn(s),rate:this.dropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,c=(oe,le,ae)=>!le||!le[ae]?oe:R(le[ae],oe),p=c(s,u,0),f=c(s,u,1),d=c(s,u,2),h=c(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xa({ones:()=>hn(i),rate:this.recurrentDropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,m=c(i,g,0),y=c(i,g,1),x=c(i,g,2),v=c(i,g,3),w=3,[T,k,A,O]=cn(this.kernel.read(),l,w),[M,L,V,U]=this.useBias?cn(this.bias.read(),l):[null,null,null,null];p=this.inputConv(p,T,M,this.padding),f=this.inputConv(f,k,L,this.padding),d=this.inputConv(d,A,V,this.padding),h=this.inputConv(h,O,U,this.padding);let[G,j,H,Y]=cn(this.recurrentKernel.read(),l,w);m=this.recurrentConv(m,G),y=this.recurrentConv(y,j),x=this.recurrentConv(x,H),v=this.recurrentConv(v,Y);let Q=this.recurrentActivation.apply(W(p,m)),X=this.recurrentActivation.apply(W(f,y)),J=W(R(X,a),R(Q,this.activation.apply(W(d,x)))),re=R(this.recurrentActivation.apply(W(h,v)),this.activation.apply(J));return[re,re,J]})}getConfig(){let e=super.getConfig(),{units:r}=e,o=Kde(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},o),s)}inputConv(e,r,o,s){let i=vr(e,r,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?hr(i,o,this.dataFormat):i}recurrentConv(e,r){return vr(e,r,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();q.registerClass(p1);var Sj=(()=>{class t extends Xde{constructor(e){let r=new p1(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})();q.registerClass(Sj);var f1=(()=>{class t extends Ce{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let r=e.shape,o=[];for(let s=0;s<this.noiseShape.length;++s)o.push(this.noiseShape[s]==null?r[s]:this.noiseShape[s]);return o}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);if(0<this.rate&&this.rate<1){let s=r.training==null?!1:r.training,i=this.getNoiseShape(o);return au(()=>GC(o,this.rate,i,this.seed),()=>o,s)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();q.registerClass(f1);var Tj=(()=>{class t extends f1{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})();q.registerClass(Tj);var Nj=(()=>{class t extends Ce{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Qt(this.units,"units"),this.activation=cs(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Gt(e.kernelConstraint),this.biasConstraint=Gt(e.biasConstraint),this.kernelRegularizer=mt(e.kernelRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.activityRegularizer=mt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Re(e);let r=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){e=Re(e);let r=e.slice();return r[r.length-1]=this.units,r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),s=MC(this.activation.getClassName()),i;return s!=null?i=$o(o,this.kernel.read(),s,this.bias?this.bias.read():null):(i=$o(o,this.kernel.read()),this.bias!=null&&(i=hr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let e={units:this.units,activation:us(this.activation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),biasConstraint:Ut(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})();q.registerClass(Nj);var Ej=(()=>{class t extends Ce{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Re(e);for(let r of e.slice(1))if(r==null)throw new P(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Mo(e,1)]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);if(this.dataFormat==="channelsFirst"&&o.rank>1){let s=[0];for(let i=2;i<o.rank;++i)s.push(i);s.push(1),o=Me(o,s)}return gW(o)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})();q.registerClass(Ej);var Dj=(()=>{class t extends Ce{constructor(e){super(e),this.supportsMasking=!0,this.activation=cs(e.activation)}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return this.activation.apply(o)})}getConfig(){let e={activation:us(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})();q.registerClass(Dj);var kj=(()=>{class t extends Ce{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return B(()=>(e=xe(e),hW(e,this.n)))}getConfig(){let e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})();q.registerClass(kj);var Aj=(()=>{class t extends Ce{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,r){let o="Total size of new array must be unchanged.",s=r.slice(),i=1,a=null;for(let u=0;u<s.length;++u){let c=s[u];if(this.isUnknown(c))if(a===null)a=u;else throw new P("Can only specifiy one unknown dimension.");else i*=c}let l=Mo(e);if(a!==null){if(i===0||l%i!==0)throw new P(o);s[a]=l/i}else if(l!==i)throw new P(o);return s}computeOutputShape(e){let r=!1;for(let o=0;o<e.length;++o)if(this.isUnknown(e[o])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),s=o.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return _(o,i)})}getConfig(){let e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})();q.registerClass(Aj);var Rj=(()=>{class t extends Ce{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let r=fr(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ht({ndim:this.dims.length+1})]}computeOutputShape(e){e=Re(e);let r=e.slice();return this.dims.forEach((o,s)=>{r[s+1]=e[o]}),r}call(e,r){return Me(xe(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})();q.registerClass(Rj);var _j=(()=>{class t extends Ce{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){let o=xe(e);return cc(Zo(o,this.maskValue),-1)}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),a=cc(Zo(o,this.maskValue),-1,!0);return R(o,K(a,o.dtype))})}}return t.className="Masking",t})();q.registerClass(_j);var Oj=(()=>{class t extends Ce{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let r=null;e.batchSize!=null&&(r=e.batchSize),e.inputLength==null?this.batchInputShape=[r,null]:this.batchInputShape=[r].concat(ot(e.inputLength))}this.inputDim=e.inputDim,Qt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Qt(this.outputDim,"outputDim"),this.embeddingsInitializer=pt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=mt(e.embeddingsRegularizer),this.activityRegularizer=mt(e.activityRegularizer),this.embeddingsConstraint=Gt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return B(()=>this.maskZero?(e=xe(e),Zo(e,ye(e))):null)}computeOutputShape(e){if(e=Re(e),this.inputLength==null)return[...e,this.outputDim];let r=ot(this.inputLength);if(r.length!==e.length-1)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let o=0;for(let s=0;s<r.length;++s){let i=r[s],a=e[s+1];if(i!=null&&a!=null&&i!==a)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(r[o]=a),o++}}return[e[0],...r,this.outputDim]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);o.dtype!=="int32"&&(o=er(o,"int32"));let s=UC(this.embeddings.read(),_(o,[o.size]));return _(s,Re(this.computeOutputShape(o.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:vt(this.embeddingsInitializer),embeddingsRegularizer:it(this.embeddingsRegularizer),activityRegularizer:it(this.activityRegularizer),embeddingsConstraint:Ut(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})();q.registerClass(Oj);var ba=class extends Ce{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new we}computeElementwiseOpOutputShape(n,e){if(n==null||e==null)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(e.length===0)return n;let r=n.slice(0,n.length-e.length);for(let o=0;o<e.length;++o){let s=n[n.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)r.push(null);else if(s===1)r.push(i);else if(i===1)r.push(s);else{if(s!==i)throw new P("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(s)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[Re(n)]),n=n,n.length<2)throw new P(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(let s of n)s!=null&&s[0]!==null&&e.push(s[0]);if(e=Fo(e),e.length>1)throw new P(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=n[0]==null?null:n[0].slice(1);for(let s=1;s<n.length;++s){let i=n[s]==null?null:n[s].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}let o=n.map(s=>s.length);n.indexOf(null)===-1&&Fo(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(n,e){return B(()=>{if(n=n,this.reshapeRequired){let r=[],o=n.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ls(o);for(let i of n){let a=i.rank;for(let l=0;l<s-a;++l)i=ha(i,1);r.push(i)}return this.mergeFunction(r)}else{let s=!1;for(let l of n){let u=l.rank;if(u==null){let c=l.shape,p=c[0],f=c.slice(1).concat([p]),d=_(l,[p].concat(Mo(c.slice(1))));d=Me(d,[1,0]),d=_(d,f),r.push(d),s=!0}else if(u>1){let c=fr(1,u).concat([0]);r.push(Me(l,c)),s=!0}else r.push(l)}let i=this.mergeFunction(r),a=i.rank;if(s){if(a==null){let l=i.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));i=_(Me(_(i,[-1,c]),[1,0]),p)}else if(a>1){let l=[a-1].concat(fr(0,a-1));i=Me(i,l)}}return i}}else return this.mergeFunction(n)})}computeOutputShape(n){n=n;let e;n[0]==null?e=null:e=n[0].slice(1);for(let o=1;o<n.length;++o){let s=n[o]==null?null:n[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(let o of n)o!=null&&o[0]!==null&&r.push(o[0]);return r=Fo(r),r.length===1?e=r.concat(e):e=[null].concat(e),e}computeMask(n,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new P("`mask` should be an Array");if(!Array.isArray(n))throw new P("`inputs` should be an Array");if(e.length!==n.length)throw new P(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:Pt(o,0));let r=e[0];for(let o=1;o<e.length-1;++o)r=Vn(r,e[o]);return r})}},Fj=(()=>{class t extends ba{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=W(r,e[o]);return r})}}return t.className="Add",t})();q.registerClass(Fj);var Mj=(()=>{class t extends ba{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=R(r,e[o]);return r})}}return t.className="Multiply",t})();q.registerClass(Mj);var $j=(()=>{class t extends ba{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=W(r,e[o]);return R(1/e.length,r)})}}return t.className="Average",t})();q.registerClass($j);var Pj=(()=>{class t extends ba{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=Cr(r,e[o]);return r})}}return t.className="Maximum",t})();q.registerClass(Pj);var Lj=(()=>{class t extends ba{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=ro(r,e[o]);return r})}}return t.className="Minimum",t})();q.registerClass(Lj);var Bj=(()=>{class t extends ba{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new P("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let r=!0;for(let s of e)if(s!=null){r=!1;break}if(r)return;let o=[];for(let s=0;s<e.length;++s){let i=e[s].slice();i.splice(this.axis,1);let a=!1;for(let l of o)if(b.arraysEqual(l,i)){a=!0;break}a||o.push(i)}if(o.length>1)throw new P("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>ph(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new P("A `Concatenate` layer should be called on a list of inputs.");let r=e,o=r[0].slice(),s=this.axis<0?o.length+this.axis:this.axis;for(let i of r.slice(1)){if(o[s]==null||i[s]==null){o[s]=null;break}o[s]+=i[s]}return o}computeMask(e,r){if(r==null)return null;if(!Array.isArray(r))throw new P("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new P("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new P(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return B(()=>{let o=!0;if(r.forEach(a=>{if(a!=null){o=!1;return}}),o)return null;let s=[];for(let a=0;a<e.length;++a)r[a]==null?s.push(K(hn(e[a]),"bool")):r[a].rank<e[a].rank?s.push(Pt(r[a],-1)):s.push(r[a]);let i=Je(s,this.axis);return sd(i,-1,!1)})}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})();q.registerClass(Bj);function Tg(t,n){for(;t<0;)t+=n;return t}function Yde(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new we("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),b.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),typeof e=="number"&&(e=[e,e]),t.dtype==="complex64"||n.dtype==="complex64")throw new we("batchDot is not implemented for complex64-type Tensors yet.");let r=t.shape.length,o=n.shape.length;e==null&&(e=[r-1,o-2]);let s=e;return B(()=>{let i;if(r>o){i=r-o;let l=[];for(let u=0;u<i;++u)l.push(1);n=_(n,n.shape.concat(l))}else if(o>r){i=o-r;let l=[];for(let u=0;u<i;++u)l.push(1);t=_(t,t.shape.concat(l))}else i=0;let a;if(t.shape.length===2&&n.shape.length===2)s[0]===s[1]?a=ie(R(t,n),s[0]):a=ie(R(Me(t,[1,0]),n),s[1]);else{let l=s[0]!==t.shape.length-1,u=s[1]===n.shape.length-1;a=Fe(t,n,l,u)}if(i>0){let l;r>o?l=r+o-3:l=r-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);a=Qn(a,u)}return a.shape.length===1&&(a=Pt(a,1)),a})}var zj=(()=>{class t extends ba{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0],o=e[1];if(r.length>3||o.length>3)throw new we("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);if(r[s[0]]!==o[s[1]])throw new P(`Dimension incompatibility: ${r[s[0]]} !== ${o[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new P(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let r=e[0],o=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,a)=>Tg(i,e[a].shape.length)):s=[Tg(this.axes,r.shape.length),Tg(this.axes,o.shape.length)],this.normalize&&(r=gg(r,s[0]),o=gg(o,s[1])),Yde(r,o,s)}interpretAxes(e,r){let o;return Array.isArray(this.axes)?o=this.axes:o=[Tg(this.axes,e.length),Tg(this.axes,r.length)],o}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0].slice(),o=e[1].slice();if(r.length>3||o.length>3)throw new we("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);r.splice(s[0],1),o.splice(s[1],1),o.splice(0,1);let i=r.concat(o);return i.length===1&&i.push(1),i}computeMask(e,r){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})();q.registerClass(zj);var Vj=(()=>{class t extends Ce{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return au(()=>W(fh(o.shape,0,this.stddev),o),()=>o,r.training||!1)})}}return t.className="GaussianNoise",t})();q.registerClass(Vj);var Uj=(()=>{class t extends Ce{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return this.rate>0&&this.rate<1?au(()=>{let i=Math.sqrt(this.rate/(1-this.rate));return R(o,fh(o.shape,1,i))},()=>o,r.training||!1):o})}}return t.className="GaussianDropout",t})();q.registerClass(Uj);var Gj=(()=>{class t extends Ce{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||xe(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(e);return au(()=>{let i=xe(e),u=-1.6732632423543772*1.0507009873554805,c=ar(Pr(o),this.rate);c=er(c,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,f=-p*u*this.rate,d=W(R(i,c),R(W(c,-1),u));return W(R(d,p),f)},()=>xe(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})();q.registerClass(Gj);function Ng(t,n,e,r,o,s=.001){let i;if(t.rank===2)i=nb(t,n,e,r,o,s);else if(t.rank===3)i=rb(t,n,e,r,o,s);else if(t.rank===4)i=ob(t,n,e,r,o,s);else throw new we(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function Zde(t,n,e,r,o=.001){return B(()=>{let s=hc(t,r),i=s.mean,a=s.variance;return[Ng(t,i,a,e,n,o),i,a]})}function Qde(t,n,e,r,o=.001){return B(()=>{let s=hc(t,r),i=s.mean,a=s.variance,l=[];for(let h of fr(0,t.rank))r.indexOf(h)!==-1?l.push(1):l.push(t.shape[h]);let u=_(i,l),c=_(a,l),p=n==null?null:_(n,l),f=e==null?null:_(e,l);return[Ng(t,u,c,f,p,o),i,a]})}function Jde(t,n,e,r,o=.001){return b.arraysEqual(r.slice().sort(),fr(0,t.rank-1))?Zde(t,n,e,r,o):Qde(t,n,e,r,o)}var Wj=(()=>{class t extends Ce{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pt(e.betaInitializer||"zeros"),this.gammaInitializer=pt(e.gammaInitializer||"ones"),this.movingMeanInitializer=pt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=pt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Gt(e.betaConstraint),this.gammaConstraint=Gt(e.gammaConstraint),this.betaRegularizer=mt(e.betaRegularizer),this.gammaRegularizer=mt(e.gammaRegularizer)}build(e){e=Re(e);let r=this.axis>=0?this.axis:this.axis+e.length,o=e[r];if(o==null)throw new P(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ht({ndim:e.length,axes:{[r]:o}})];let s=[o];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return B(()=>{let o=r.training==null?!1:r.training,s=xe(e),i=s.shape,a=i.length,l=fr(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);let c=_o(1,a);c[u]=i[u];let p=l.slice();p.sort();let f=!b.arraysEqual(p,fr(0,a).slice(0,a-1)),d=()=>{if(f){let v=_(this.movingMean.read(),c),w=_(this.movingVariance.read(),c),T=this.center?_(this.beta.read(),c):null,k=this.scale?_(this.gamma.read(),c):null;return Ng(s,v,w,T,k,this.epsilon)}else return Ng(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return d();let[h,g,m]=Jde(s,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,w,T)=>{B(()=>{let k=1-T,A=v.read(),O=R(te(A,w),k);v.write(te(A,O))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vt(this.betaInitializer),gammaInitializer:vt(this.gammaInitializer),movingMeanInitializer:vt(this.movingMeanInitializer),movingVarianceInitializer:vt(this.movingVarianceInitializer),betaRegularizer:it(this.betaRegularizer),gammaRegularizer:it(this.gammaRegularizer),betaConstraint:Ut(this.betaConstraint),gammaConstraint:Ut(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})();q.registerClass(Wj);var jj=(()=>{class t extends Ce{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pt(e.betaInitializer||"zeros"),this.gammaInitializer=pt(e.gammaInitializer||"ones"),this.betaRegularizer=mt(e.betaRegularizer),this.gammaRegularizer=mt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Re(e);let r=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(let i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Fo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,r){let o=xe(e),s=o.shape,i=s.length;return B(()=>{let{mean:l,variance:u}=hc(o,this.axis,!0),c=_o(1,i);for(let m of this.axis)c[m]=s[m];let p=m=>m!=null&&m.shape.length!==i?_(m,c):m,f=this.scale?p(this.gamma.read()):null,d=this.center?p(this.beta.read()):null,h=[],g=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(h.push(s[m]),g.push(1)):(h.push(1),g.push(s[m]));return l=On(l,h),u=On(u,h),f!=null&&(f=On(f,g)),d!=null&&(d=On(d,g)),Ng(o,l,u,d,f,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vt(this.betaInitializer),gammaInitializer:vt(this.gammaInitializer),betaRegularizer:it(this.betaRegularizer),gammaRegularizer:it(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})();q.registerClass(jj);function ehe(t,n,e){return B(()=>{if(t.rank!==4)throw new P(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(n==null&&(n=[[1,1],[1,1]]),n.length!==2||n[0].length!==2||n[1].length!==2)throw new P("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=dr()),e!=="channelsLast"&&e!=="channelsFirst")throw new P(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return e==="channelsFirst"?r=[[0,0],[0,0],n[0],n[1]]:r=[[0,0],n[0],n[1],[0,0]],lr(t,r)})}var Hj=(()=>{class t extends Ce{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?dr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new P(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,o;if(typeof e.padding[0]=="number")r=[e.padding[0],e.padding[0]],o=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new P(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],e.padding[1].length!==2)throw new P(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);o=e.padding[1]}this.padding=[r,o]}this.inputSpec=[new ht({ndim:4})]}computeOutputShape(e){e=Re(e);let r,o;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?r=e[2]+this.padding[0][0]+this.padding[0][1]:r=null,e[3]!=null&&e[3]>=0?o=e[3]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],e[1],r,o]):(e[1]!=null&&e[1]>=0?r=e[1]+this.padding[0][0]+this.padding[0][1]:r=null,e[2]!=null&&e[2]>=0?o=e[2]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],r,o,e[3]])}call(e,r){return B(()=>ehe(xe(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})();q.registerClass(Hj);function v0(t,n,e,r,o,s){return B(()=>{Rt(o),_D(s),pr(r),e==null&&(e=[1,1]),r==null&&(r="valid"),o==null&&(o=dr()),s==null&&(s="max"),t=Ig(t,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=Wl(t,n,e,a):i=Ml(t,n,e,a),o==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}function qj(t,n,e,r,o,s){return B(()=>{Rt(o),_D(s),pr(r),e==null&&(e=[1,1,1]),r==null&&(r="valid"),o==null&&(o=dr()),s==null&&(s="max"),t=r1(t,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=Nb(t,n,e,a):i=tb(t,n,e,a),o==="channelsFirst"&&(i=Me(i,[0,4,1,2,3])),i})}var m0=class extends Ce{constructor(n){if(n.poolSize==null&&(n.poolSize=2),super(n),typeof n.poolSize=="number")this.poolSize=[n.poolSize];else if(Array.isArray(n.poolSize)&&n.poolSize.length===1&&typeof n.poolSize[0]=="number")this.poolSize=n.poolSize;else throw new P(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);if(Qt(this.poolSize,"poolSize"),n.strides==null)this.strides=this.poolSize;else if(typeof n.strides=="number")this.strides=[n.strides];else if(Array.isArray(n.strides)&&n.strides.length===1&&typeof n.strides[0]=="number")this.strides=n.strides;else throw new P(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);Qt(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,pr(this.padding),this.inputSpec=[new ht({ndim:3})]}computeOutputShape(n){n=Re(n);let e=Er(n[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return B(()=>{this.invokeCallHook(n,e),n=ha(xe(n),2);let r=this.poolingFunction(xe(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Qn(r,[2])})}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}},Kj=(()=>{class t extends m0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),v0(e,r,o,s,i,"max")}}return t.className="MaxPooling1D",t})();q.registerClass(Kj);var Xj=(()=>{class t extends m0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),v0(e,r,o,s,i,"avg")}}return t.className="AveragePooling1D",t})();q.registerClass(Xj);var g0=class extends Ce{constructor(n){if(n.poolSize==null&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],n.strides==null)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(n.strides.length!==2)throw new P(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];Qt(this.poolSize,"poolSize"),Qt(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Rt(this.dataFormat),pr(this.padding),this.inputSpec=[new ht({ndim:4})]}computeOutputShape(n){n=Re(n);let e=this.dataFormat==="channelsFirst"?n[2]:n[1],r=this.dataFormat==="channelsFirst"?n[3]:n[2];return e=Er(e,this.poolSize[0],this.padding,this.strides[0]),r=Er(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return B(()=>(this.invokeCallHook(n,e),this.poolingFunction(xe(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},Yj=(()=>{class t extends g0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),v0(e,r,o,s,i,"max")}}return t.className="MaxPooling2D",t})();q.registerClass(Yj);var Zj=(()=>{class t extends g0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),v0(e,r,o,s,i,"avg")}}return t.className="AveragePooling2D",t})();q.registerClass(Zj);var y0=class extends Ce{constructor(n){if(n.poolSize==null&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],n.strides==null)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(n.strides.length!==3)throw new P(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];Qt(this.poolSize,"poolSize"),Qt(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Rt(this.dataFormat),pr(this.padding),this.inputSpec=[new ht({ndim:5})]}computeOutputShape(n){n=Re(n);let e=this.dataFormat==="channelsFirst"?n[2]:n[1],r=this.dataFormat==="channelsFirst"?n[3]:n[2],o=this.dataFormat==="channelsFirst"?n[4]:n[3];return e=Er(e,this.poolSize[0],this.padding,this.strides[0]),r=Er(r,this.poolSize[1],this.padding,this.strides[1]),o=Er(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[n[0],n[1],e,r,o]:[n[0],e,r,o,n[4]]}call(n,e){return B(()=>(this.invokeCallHook(n,e),this.poolingFunction(xe(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},Qj=(()=>{class t extends y0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),qj(e,r,o,s,i,"max")}}return t.className="MaxPooling3D",t})();q.registerClass(Qj);var Jj=(()=>{class t extends y0{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return Rt(i),pr(s),qj(e,r,o,s,i,"avg")}}return t.className="AveragePooling3D",t})();q.registerClass(Jj);var x0=class extends Ce{constructor(n){super(n),this.inputSpec=[new ht({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new we}},e4=(()=>{class t extends x0{constructor(e){super(e||{})}call(e,r){return B(()=>{let o=xe(e);return xt(o,1)})}}return t.className="GlobalAveragePooling1D",t})();q.registerClass(e4);var t4=(()=>{class t extends x0{constructor(e){super(e||{})}call(e,r){return B(()=>{let o=xe(e);return wn(o,1)})}}return t.className="GlobalMaxPooling1D",t})();q.registerClass(t4);var b0=class extends Ce{constructor(n){super(n),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Rt(this.dataFormat),this.inputSpec=[new ht({ndim:4})]}computeOutputShape(n){return n=n,this.dataFormat==="channelsLast"?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new we}getConfig(){let n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},n4=(()=>{class t extends b0{call(e,r){return B(()=>{let o=xe(e);return this.dataFormat==="channelsLast"?xt(o,[1,2]):xt(o,[2,3])})}}return t.className="GlobalAveragePooling2D",t})();q.registerClass(n4);var r4=(()=>{class t extends b0{call(e,r){return B(()=>{let o=xe(e);return this.dataFormat==="channelsLast"?wn(o,[1,2]):wn(o,[2,3])})}}return t.className="GlobalMaxPooling2D",t})();q.registerClass(r4);var w0=class extends Ce{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(n){this.layer!=null&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){let n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){let o=e.layer,s=jr(o,r);delete e.layer;let i={layer:s};return Object.assign(i,e),new n(i)}},o4=(()=>{class t extends w0{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Re(e),e.length<3)throw new P(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Re(e);let r=[e[0]].concat(e.slice(2)),o=this.layer.computeOutputShape(r),s=e[1];return[o[0],s].concat(o.slice(1))}call(e,r){return B(()=>(e=xe(e),a1((a,l)=>[xe(this.layer.call(a,r)),[]],e,[],!1,null,null,!1,!0)[1]))}}return t.className="TimeDistributed",t})();q.registerClass(o4);function the(t){Ws(uW,"BidirectionalMergeMode",t)}var nhe="concat",s4=(()=>{class t extends w0{constructor(e){super(e);let r=e.layer.getConfig(),o={};o.className=e.layer.getClassName(),o.config=r,this.forwardLayer=jr(o),r.goBackwards=r.goBackwards!==!0;let s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=jr(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?nhe:e.mergeMode,the(this.mergeMode),e.weights)throw new we("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let r=e.length,o=Math.floor(r/2);this.forwardLayer.setWeights(e.slice(0,o)),this.backwardLayer.setWeights(e.slice(o))}computeOutputShape(e){let r=this.forwardLayer.computeOutputShape(e);Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r;let o,s,i;return this.returnState&&(i=r.slice(1)),o=r[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,s=[o]):this.mergeMode==null?s=[o,o.slice()]:s=[o],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[o].concat(i).concat(i.slice()):Nn(s)}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=i1(e,o,s,this.numConstants);if(e=i.inputs,o=i.initialState,s=i.constants,Array.isArray(e)&&(o=e.slice(1),e=e[0]),(o==null||o.length===0)&&s==null)return super.apply(e,r);let a=[],l=[];if(o!=null){let c=o.length;if(c%2>0)throw new P("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=o,a.push(...o);let p=o.map(f=>new ht({shape:f.shape}));this.forwardLayer.stateSpec=p.slice(0,c/2),this.backwardLayer.stateSpec=p.slice(c/2),l.push(...p)}if(s!=null)throw new we("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof tr;for(let c of a)if(c instanceof tr!==u)throw new P("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let c=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(c,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return B(()=>{let o=r.initialState,s,i;if(o==null)s=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{let u=o.slice(0,o.length/2),c=o.slice(o.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=un(i,1));let l;return this.mergeMode==="concat"?l=ph([s,i]):this.mergeMode==="sum"?l=W(s,i):this.mergeMode==="ave"?l=R(.5,W(s,i)):this.mergeMode==="mul"?l=R(s,i):this.mergeMode==null&&(l=[s,i]),this.returnState?this.mergeMode==null?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){as(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),as(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){Array.isArray(r)&&(r=r[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[r,r]:o=r:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let i=this.forwardLayer.states.map(a=>null);return Array.isArray(o)?o.concat(i).concat(i):[o].concat(i).concat(i)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){let o=jr(r.layer);if(delete r.layer,r.numConstants!=null)throw new we("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=r;return s.layer=o,new e(s)}}return t.className="Bidirectional",t})();q.registerClass(s4);var i4=(()=>{class t extends Ce{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>(e=xe(e),e.dtype!=="float32"&&(e=er(e,"float32")),W(R(e,this.scale),this.offset)))}}return t.className="Rescaling",t})();q.registerClass(i4);var{resizeBilinear:rhe,cropAndResize:ohe}=In,a4=(()=>{class t extends Ce{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,o,s,i,a,l,u){return B(()=>{let c,p=!1,f=r/a,d=o/l,h=(s+r)/a,g=(i+o)/l,m=[f,d,h,g],y=[];e.rank===3?(p=!0,c=Bt([e])):c=e;for(let k=0;k<c.shape[0];k++)y.push(m);let x=xn(y,[y.length,4]),v=Ls(0,y.length,1,"int32"),T=ohe(c,x,v,[s,i],"nearest");return p?er(xe(pn(T)),u):er(T,u)})}upsize(e,r,o,s){return B(()=>{let i=rhe(e,[r,o]);return er(i,s)})}call(e,r){return B(()=>{let o=xe(e),s=o.dtype,i=o.shape,a=i[i.length-3],l=i[i.length-2],u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(o,u,c,this.height,this.width,a,l,s):this.upsize(e,this.height,this.width,s)})}getConfig(){let e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=Re(e);let r=e.length-3,o=e.length-2;return e[r]=this.height,e[o]=this.width,e}}return t.className="CenterCrop",t})();q.registerClass(a4);function l4(t,n,e,r){let o=xe(t);if(o.dtype!=="int32"&&(o=er(o,"int32")),n==="int")return o;let s=o.shape;if(o.rank===0&&(o=Pt(o,-1)),n==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=Pt(o,-1)),o.rank>2)throw new P(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${s} which would result in output rank ${o.rank}.`);let i=["multiHot","oneHot"].includes(n),a=o,l;if(typeof r<"u"&&n==="count"?l=Fm(a,r,e,i):l=Fm(a,[],e,i),n!=="tfIdf")return l;if(r)return R(l,r);throw new P("When outputMode is 'tfIdf', weights must be provided.")}var u4=(()=>{class t extends Ce{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=Re(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return B(()=>{e=xe(e),e.dtype!=="int32"&&(e=er(e,"int32"));let o;if(typeof r.countWeights<"u"){if(this.outputMode!=="count")throw new P(`countWeights is not used when outputMode !== count.
              Received countWeights=${r.countWeights}`);o=xe(r.countWeights)}let s=wn(e),i=na(e),a=Lt(this.numTokens,s).bufferSync().get(0),l=ar(i,0).bufferSync().get(0);if(!(a&&l))throw new P(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return l4(e,this.outputMode,this.numTokens,o)})}}return t.className="CategoryEncoding",t})();q.registerClass(u4);var ihe=["bilinear","nearest"],c4=new Set(ihe),p4=(()=>{class t extends Ce{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(c4.has(e.interpolation))this.interpolation=e.interpolation;else throw new P(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Re(e);let r=e[2];return[this.height,this.width,r]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>{let o=[this.height,this.width];if(this.interpolation==="bilinear")return In.resizeBilinear(e,o,!this.cropToAspectRatio);if(this.interpolation==="nearest")return In.resizeNearestNeighbor(e,o,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...c4]} are supported`)})}}return t.className="Resizing",t})();q.registerClass(p4);var f4=(()=>{class t{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}return t.className="RandomSeed",t})();var d4=(()=>{class t extends Ce{constructor(e){super(e),this.randomGenerator=new f4(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BaseRandomLayer",t})();var ahe=["bilinear","nearest"],h4=new Set(ahe),m4=(()=>{class t extends d4{constructor(e){super(e);let{factor:r,interpolation:o="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new P(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new P(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new P(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(o)if(h4.has(o))this.interpolation=o;else throw new P(`Invalid interpolation parameter: ${o} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=Re(e);let r=e[2];return[this.imgHeight,-1,r]}call(e,r){return B(()=>{let o=xe(e);this.imgHeight=o.shape[o.shape.length-3];let s=o.shape[o.shape.length-2];this.widthFactor=Pr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);let a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return In.resizeBilinear(e,a);case"nearest":return In.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...h4]} are supported`)}})}}return t.className="RandomWidth",t})();q.registerClass(m4);var xhe=Sh(Pm());var ghe=Sh(Pm());var pKt=Symbol("out"),fKt=Symbol("field"),dKt=Symbol("quote"),hKt=Symbol("quoteafterquote"),mKt=Symbol("quoteinquote");var khe=Wn.whereImpl,y4=(()=>{class t extends si{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new $u(this,wo())}write(e,r,o){this.firstUse&&(this.firstUse=!1,$().get("IS_NODE")&&N.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:o,refCount:1}),s}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let r=this.data.get(e);r.refCount++}decRef(e){if(this.data.has(e)){let r=this.data.get(e);r.refCount--}}move(e,r,o,s,i){this.data.set(e,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){return z(this,null,function*(){return this.readSync(e)})}readSync(e){let{dtype:r,complexTensorInfos:o}=this.data.get(e);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return N.mergeRealAndImagArrays(s,i)}return b.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return he(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return he(e.shape,e.dtype,r)}makeOutput(e,r,o){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return z(this,null,function*(){let r=b.now();return e(),{kernelMs:b.now()-r}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Z([e],"where");let r=this.readSync(e.dataId);return khe(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();Lx("cpu",()=>new y4,1);var h1=Ie(bi,t=>t>=0?t:Math.exp(t)-1),x4={kernelName:bi,backendName:"cpu",kernelFunc:h1};function m1(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{alpha:s}=r;Z([o],"leakyRelu");let i=b.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,l=b.getTypedArrayFromDType("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?s*a[u]:a[u];return e.makeTensorInfo(o.shape,"float32",l)}var b4={kernelName:nl,backendName:"cpu",kernelFunc:m1};var Ahe=We((t,n)=>t<0?n*t:t);function g1(t){let{inputs:n,backend:e}=t,{x:r,alpha:o}=n;Z([r,o],"prelu");let s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,[a,l]=Ahe(r.shape,o.shape,s,i,"float32");return e.makeTensorInfo(l,"float32",a)}var v4={kernelName:ml,backendName:"cpu",kernelFunc:g1};var y1=Ie(Pi,t=>Math.max(0,t)),w4={kernelName:Pi,backendName:"cpu",kernelFunc:y1};var x1=Ie(Li,t=>Math.min(Math.max(0,t),6)),C4={kernelName:Li,backendName:"cpu",kernelFunc:x1};function qc(t,n,e,r,o){if(e==="linear")return Hn({inputs:{x:n},backend:t});if(e==="relu")return y1({inputs:{x:n},backend:t});if(e==="elu")return h1({inputs:{x:n},backend:t});if(e==="relu6")return x1({inputs:{x:n},backend:t});if(e==="prelu")return g1({inputs:{x:n,alpha:r},backend:t});if(e==="leakyrelu")return m1({inputs:{x:n},backend:t,attrs:{alpha:o}});if(e==="sigmoid")return ZE({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function je(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{shape:s}=r,i=b.sizeFromShape(o.shape),a=b.inferFromImplicitShape(s,i),l=b.sizeFromShape(a);b.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let u=e.data.get(o.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var I4={kernelName:yl,backendName:"cpu",kernelFunc:je};function b1(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;Z([o,s],"matMul");let l=o.shape.length,u=s.shape.length,c=i?o.shape[l-2]:o.shape[l-1],p=a?s.shape[u-1]:s.shape[u-2],f=i?o.shape[l-1]:o.shape[l-2],d=a?s.shape[u-2]:s.shape[u-1],h=o.shape.slice(0,-2),g=s.shape.slice(0,-2),m=b.sizeFromShape(h),y=b.sizeFromShape(g),v=Mr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,d]);b.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let w=i?[m,c,f]:[m,f,c],T=a?[y,d,p]:[y,p,d],k=je({inputs:{x:o},backend:e,attrs:{shape:w}}),A=je({inputs:{x:s},backend:e,attrs:{shape:T}}),O=i?k.shape[1]:k.shape[2],M=i?k.shape[2]:k.shape[1],L=a?A.shape[1]:A.shape[2],V=Math.max(m,y),U=e.data.get(k.dataId).values,G=e.data.get(A.dataId).values,j=b.computeStrides(k.shape),H=b.computeStrides(A.shape),[Y,Q,X]=i?[j[0],1,j[1]]:[j[0],j[1],1],[J,re,oe]=a?[1,H[1],H[0]]:[H[1],1,H[0]],le=M*L,ae=he([V,M,L],k.dtype),fe=ae.values,ce=e.blockSize;for(let me=0;me<V;me++){let Te=me%m,Ae=me%y;for(let Ee=0;Ee<M;Ee+=ce){let qe=Math.min(Ee+ce,M);for(let Ke=0;Ke<L;Ke+=ce){let wt=Math.min(Ke+ce,L);for(let _t=0;_t<O;_t+=ce){let tn=Math.min(_t+ce,O);for(let Ot=Ee;Ot<qe;Ot++)for(let Nt=Ke;Nt<wt;Nt++){let Jt=0;for(let qt=_t;qt<tn;qt++){let qs=U[Te*Y+Ot*Q+qt*X],Pn=G[qt*J+Nt*re+Ae*oe];Jt+=qs*Pn}fe[me*le+(Ot*L+Nt)]+=Jt}}}}}return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(v,ae.dtype,ae.values)}var S4={kernelName:Ga,backendName:"cpu",kernelFunc:b1};function Rhe(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,f,d,h,g=[];f=b1({inputs:{a:o,b:s},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(d=Vs({inputs:{a:f,b:i},backend:e}),g.push(f),f=d),c&&(h=qc(e,f,c,a,p),g.push(f),f=h);for(let y of g)e.disposeIntermediateTensorInfo(y);return f}var T4={kernelName:Yu,backendName:"cpu",kernelFunc:Rhe};var _he=Ie(ai,t=>Math.acos(t)),N4={kernelName:ai,backendName:"cpu",kernelFunc:_he};var Ohe=Ie(li,t=>Math.acosh(t)),E4={kernelName:li,backendName:"cpu",kernelFunc:Ohe};function Fhe(t){let{inputs:n,backend:e}=t,r=n;Z(n,"addN");let o=r.map(a=>e.data.get(a.dataId).values),s=he(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let l=o[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var D4={kernelName:La,backendName:"cpu",kernelFunc:Fhe};function Mhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;Z(o,"all");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Vt({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let T=g[x+w];v=v&&T}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=je({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var k4={kernelName:Up,backendName:"cpu",kernelFunc:Mhe};function $he(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;Z(o,"any");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Vt({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let T=g[x+w];v=v||T}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=je({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var A4={kernelName:Gp,backendName:"cpu",kernelFunc:$he};function Phe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r;Z(o,"argMax");let i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Vt({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,p]=N.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(c),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],v=0;for(let w=0;w<h;++w){let T=g[y+w];T>x&&(x=T,v=w)}d[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",d)}var R4={kernelName:Ba,backendName:"cpu",kernelFunc:Phe};function Lhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r;Z(o,"argMin");let i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Vt({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,p]=N.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(c),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],v=0;for(let w=0;w<h;++w){let T=g[y+w];T<x&&(x=T,v=w)}d[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",d)}var _4={kernelName:za,backendName:"cpu",kernelFunc:Lhe};var Bhe=Ie(ui,t=>Math.asin(t)),O4={kernelName:ui,backendName:"cpu",kernelFunc:Bhe};var zhe=Ie(ci,t=>Math.asinh(t)),F4={kernelName:ci,backendName:"cpu",kernelFunc:zhe};var Vhe=Ie(pi,t=>Math.atan(t)),M4={kernelName:pi,backendName:"cpu",kernelFunc:Vhe};var Uhe=We((t,n)=>Math.atan2(t,n)),Ghe=Ze(di,Uhe),$4={kernelName:di,backendName:"cpu",kernelFunc:Ghe};var Whe=Ie(fi,t=>Math.atanh(t)),P4={kernelName:fi,backendName:"cpu",kernelFunc:Whe};function wh(t,n,e,r,o,s){let i=o.strideHeight,a=o.strideWidth,l=o.dilationHeight,u=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,f=o.padInfo.top,d=o.padInfo.left,h=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=he(o.outShape,e),m=g.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],v=o.outShape[3];for(let w=0;w<o.batchSize;++w){let T=w*y,k=w*r[0];for(let A=0;A<o.inChannels;++A)for(let O=0;O<o.outHeight;++O){let M=O*i-f,L=Math.max(0,M),V=Math.min(o.inHeight,c+M),U=T+O*x;for(let G=0;G<o.outWidth;++G){let j=G*a-d,H=Math.max(0,j),Y=Math.min(o.inWidth,p+j),Q=h,X=0,J=0;for(let oe=L;oe<V;oe+=l){let le=k+oe*r[1];for(let ae=H;ae<Y;ae+=u){let fe=le+ae*r[2],ce=t[fe+A];s==="max"&&ce>Q?Q=ce:s==="avg"&&(X+=ce,J++)}if(isNaN(Q))break}let re=U+G*v+A;m[re]=s==="avg"?X/J:Q}}}return g}function C0(t,n,e,r,o=!1,s=!1){let i=he(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,h=r.padInfo.left,g=he(n,e,t);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let x=0;x<r.outHeight;++x){let v=x*a-d,w=v;for(;w<0;)w+=u;let T=Math.min(r.inHeight,p+v);for(let k=0;k<r.outWidth;++k){let A=k*l-h,O=A;for(;O<0;)O+=c;let M=Math.min(r.inWidth,f+A),L=Number.NEGATIVE_INFINITY,V=-1;for(let U=w;U<T;U+=u){let G=U-v;for(let j=O;j<M;j+=c){let H=j-A,Y=g.get(m,U,j,y);Y>L&&(L=Y,o?V=s?((m*r.inHeight+U)*r.inWidth+j)*r.inChannels+y:(U*r.inWidth+j)*r.inChannels+y:V=G*f+H)}}i.set(V,m,x,k,y)}}return i}function I0(t,n,e,r,o,s){let i=o.strideDepth,a=o.strideHeight,l=o.strideWidth,u=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,f=o.effectiveFilterDepth,d=o.effectiveFilterHeight,h=o.effectiveFilterWidth,g=o.padInfo.front,m=o.padInfo.top,y=o.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=he(o.outShape,e),w=v.values,T=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],k=o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[3]*o.outShape[4],O=o.outShape[4];for(let M=0;M<o.batchSize;++M){let L=M*T,V=M*r[0];for(let U=0;U<o.inChannels;++U)for(let G=0;G<o.outDepth;++G){let j=G*i-g,H=j;for(;H<0;)H+=u;let Y=Math.min(o.inDepth,f+j),Q=L+G*k;for(let X=0;X<o.outHeight;++X){let J=X*a-m,re=J;for(;re<0;)re+=c;let oe=Math.min(o.inHeight,d+J),le=Q+X*A;for(let ae=0;ae<o.outWidth;++ae){let fe=ae*l-y,ce=fe;for(;ce<0;)ce+=p;let me=Math.min(o.inWidth,h+fe),Te=le+ae*O,Ae=x,Ee=0,qe=0;for(let wt=H;wt<Y;wt+=u){let _t=V+wt*r[1];for(let tn=re;tn<oe;tn+=c){let Ot=_t+tn*r[2];for(let Nt=ce;Nt<me;Nt+=p){let Jt=Ot+Nt*r[3],qt=t[Jt+U];if(s==="max"&&qt>Ae?Ae=qt:s==="avg"&&(Ee+=qt,qe++),isNaN(Ae))break}if(isNaN(Ae))break}if(isNaN(Ae))break}let Ke=Te+U;w[Ke]=s==="avg"?Ee/Math.max(qe,1):Ae}}}}return v}function L4(t,n){let e=he(n.outShape,"int32"),r=n.strideDepth,o=n.strideHeight,s=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,p=n.effectiveFilterWidth,f=n.padInfo.front,d=n.padInfo.top,h=n.padInfo.left;for(let g=0;g<n.batchSize;++g)for(let m=0;m<n.inChannels;++m)for(let y=0;y<n.outDepth;++y){let x=y*r-f,v=x;for(;v<0;)v+=i;let w=Math.min(n.inDepth,u+x);for(let T=0;T<n.outHeight;++T){let k=T*o-d,A=k;for(;A<0;)A+=a;let O=Math.min(n.inHeight,c+k);for(let M=0;M<n.outWidth;++M){let L=M*s-h,V=L;for(;V<0;)V+=l;let U=Math.min(n.inWidth,p+L),G=Number.NEGATIVE_INFINITY,j=-1;for(let H=v;H<w;H+=i){let Y=H-x;for(let Q=A;Q<O;Q+=a){let X=Q-k;for(let J=V;J<U;J+=l){let re=J-L,oe=t.get(g,H,Q,J,m);oe>=G&&(G=oe,j=Y*c*p+X*c+re)}}}e.set(j,g,y,T,M,m)}}}return e}function jhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;Z(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=Hn({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=wh(f,o.shape,o.dtype,d,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var B4={kernelName:Va,backendName:"cpu",kernelFunc:jhe};function Hhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Z(o,"avgPool3d");let c=N.computePool3DInfo(o.shape,s,i,1,a,l,u),p=e.data.get(o.dataId).values,f=I0(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(f.shape,"float32",f.values)}var z4={kernelName:Ua,backendName:"cpu",kernelFunc:Hhe};function qhe(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Z([o,s],"avgPool3DGrad");let c=N.computePool3DInfo(s.shape,i,a,1,l,u),p=c.strideDepth,f=c.strideHeight,d=c.strideWidth,h=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,T=c.effectiveFilterHeight,k=c.effectiveFilterWidth,A=w-1-c.padInfo.front,O=k-1-c.padInfo.left,M=T-1-c.padInfo.top,L=he(s.shape,"float32"),V=1/(h*g*m),U=e.bufferSync(o);for(let G=0;G<c.batchSize;++G)for(let j=0;j<c.inChannels;++j)for(let H=0;H<c.inDepth;++H)for(let Y=0;Y<c.inHeight;++Y)for(let Q=0;Q<c.inWidth;++Q){let X=H-A,J=Y-M,re=Q-O,oe=0;for(let le=0;le<w;le+=y){let ae=(X+le)/p;if(!(ae<0||ae>=c.outDepth||Math.floor(ae)!==ae))for(let fe=0;fe<T;fe+=x){let ce=(J+fe)/f;if(!(ce<0||ce>=c.outHeight||Math.floor(ce)!==ce))for(let me=0;me<k;me+=v){let Te=(re+me)/d;if(Te<0||Te>=c.outWidth||Math.floor(Te)!==Te)continue;let Ae=U.get(G,ae,ce,Te,j);oe+=Ae}}}L.set(oe*V,G,H,Y,Q,j)}return e.makeTensorInfo(L.shape,L.dtype,L.values)}var V4={kernelName:jp,backendName:"cpu",kernelFunc:qhe};function Khe(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s;Z([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=r,c=N.computePool2DInfo(i.shape,a,l,1,u),p=c.strideHeight,f=c.strideWidth,d=c.filterHeight,h=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=x-1-c.padInfo.left,w=y-1-c.padInfo.top,T=he(i.shape,"float32"),k=1/(d*h),A=e.data.get(o.dataId).values,O=he(o.shape,"float32",A);for(let M=0;M<c.batchSize;++M)for(let L=0;L<c.inChannels;++L)for(let V=0;V<c.inHeight;++V)for(let U=0;U<c.inWidth;++U){let G=V-w,j=U-v,H=0;for(let Y=0;Y<y;Y+=g){let Q=(G+Y)/p;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let X=0;X<x;X+=m){let J=(j+X)/f;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;let re=O.get(M,Q,J,L);H+=re}}T.set(H*k,M,V,U,L)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}var U4={kernelName:Wp,backendName:"cpu",kernelFunc:Khe};function Xhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,scale:s,offset:i,mean:a,variance:l}=n;b.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Z([o,a,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,f=e.data.get(l.dataId).values,d=s?e.data.get(s.dataId).values:new Float32Array([1]),h=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=h.length,y=d.length,x=f.length,v=p.length,w=0,T=0,k=0,A=0;for(let O=0;O<c.length;++O)g[O]=h[w++]+(c[O]-p[T++])*d[k++]/Math.sqrt(f[A++]+u),w>=m&&(w=0),T>=v&&(T=0),k>=y&&(k=0),A>=x&&(A=0);return e.makeTensorInfo(o.shape,o.dtype,g)}var G4={kernelName:el,backendName:"cpu",kernelFunc:Xhe};function Yhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,crops:i}=r;Z([o],"batchToSpaceND");let a=s.reduce((y,x)=>y*x),l=N.getReshaped(o.shape,s,a),u=N.getPermuted(l.length,s.length),c=N.getReshapedPermuted(o.shape,s,a),p=N.getSliceBeginCoords(i,s.length),f=N.getSliceSize(c,i,s.length),d=je({inputs:{x:o},backend:e,attrs:{shape:l}}),h=Vt({inputs:{x:d},backend:e,attrs:{perm:u}}),g=je({inputs:{x:h},backend:e,attrs:{shape:c}}),m=ko({inputs:{x:g},backend:e,attrs:{begin:p,size:f}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var W4={kernelName:Wa,backendName:"cpu",kernelFunc:Yhe};function Zhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,u=Yd(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var j4={kernelName:Hp,backendName:"cpu",kernelFunc:Zhe};function Qhe(t){let{inputs:n,backend:e}=t,{s0:r,s1:o}=n,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var H4={kernelName:qp,backendName:"cpu",kernelFunc:Qhe};var Jhe=Ie(mi,(t,n)=>{let e=n;return t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t}),q4={kernelName:mi,backendName:"cpu",kernelFunc:Jhe};var eme=t=>{let{x:n}=t.inputs,e=t.backend,r=new Float32Array(b.sizeFromShape(n.shape)),o=e.data.get(n.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++){let c=a[u],p=l[u];r[u]=Math.hypot(c,p)}return e.makeOutput(r,n.shape,"float32")},K4={kernelName:ja,backendName:"cpu",kernelFunc:eme};function Hs(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var X4={kernelName:df,backendName:"cpu",kernelFunc:Hs};function fu(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r,s=b.parseAxisParam(o,n[0].shape)[0],i=n.map(g=>g.shape);N.assertParamsConsistent(i,s);let a=N.computeOutShape(n.map(g=>g.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,n[0].dtype,[]);let l=n.filter(g=>b.sizeFromShape(g.shape)>0);if(l.length===1)return Hn({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){let g=l.map(w=>No({inputs:{input:w},backend:e})),m=l.map(w=>Hs({inputs:{input:w},backend:e})),y=fu({inputs:g,backend:e,attrs:{axis:s}}),x=fu({inputs:m,backend:e,attrs:{axis:s}}),v=mn({inputs:{real:y,imag:x},backend:e});return g.forEach(w=>e.disposeIntermediateTensorInfo(w)),m.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),v}let u=l.map(g=>{let y=[-1,b.sizeFromShape(g.shape.slice(s))];return je({inputs:{x:g},backend:e,attrs:{shape:y}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=N.computeOutShape(u.map(g=>g.shape),1);let p=u[0].shape[0]===1,f=Bv(c,a,n[0].dtype,p),d=N.computeOutShape(l.map(g=>g.shape),s),h=e.makeTensorInfo(d,n[0].dtype,f);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var Y4={kernelName:Ha,backendName:"cpu",kernelFunc:fu};function v1(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Z([o,s],"conv2d");let p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),d=f.filterHeight,h=f.filterWidth,g=f.dilationHeight,m=f.dilationWidth,y=f.padInfo.left,x=f.padInfo.top,v=f.dataFormat==="channelsLast",w=new tt(f.outShape,o.dtype),T=b.computeStrides(o.shape),k=b.computeStrides(s.shape),A=T[0],O=v?T[1]:T[2],M=v?T[2]:1,L=v?1:T[1],V=w.strides[0],U=v?w.strides[1]:w.strides[2],G=v?w.strides[2]:1,j=v?1:w.strides[1],H=e.data.get(o.dataId).values,Y=e.data.get(s.dataId).values,Q=w.values;for(let X=0;X<f.batchSize;++X){let J=X*A,re=X*V;for(let oe=0;oe<f.outHeight;++oe){let le=re+oe*U,ae=oe*f.strideHeight-x;for(let fe=0;fe<d;++fe){let ce=ae+fe*g;if(ce<0||ce>=f.inHeight)continue;let me=fe*k[0],Te=J+ce*O;for(let Ae=0;Ae<f.outWidth;++Ae){let Ee=le+Ae*G,qe=Ae*f.strideWidth-y;for(let Ke=0;Ke<h;++Ke){let wt=qe+Ke*m;if(wt<0||wt>=f.inWidth)continue;let _t=me+Ke*k[1],tn=Te+wt*M,Ot=_t;for(let Nt=0;Nt<f.inChannels;++Nt){let Jt=H[tn+Nt*L];for(let qt=0;qt<f.outChannels;++qt)Q[Ee+qt*j]+=Jt*Y[Ot+qt];Ot+=f.outChannels}}}}}}return e.makeTensorInfo(w.shape,w.dtype,Q)}var Z4={kernelName:qa,backendName:"cpu",kernelFunc:v1};function tme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Z([o,s],"conv2dBackpropFilter");let p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),{strideHeight:d,strideWidth:h,filterHeight:g,filterWidth:m}=f,y=f.dataFormat==="channelsLast",x=new tt(f.filterShape,"float32"),v=f.padInfo.left,w=f.padInfo.top,T=e.data.get(o.dataId).values,k=e.data.get(s.dataId).values,A=new tt(o.shape,o.dtype,T),O=new tt(s.shape,s.dtype,k);for(let M=0;M<g;++M){let L=Math.max(0,Math.ceil((w-M)/d)),V=Math.min(f.outHeight,(f.inHeight+w-M)/d);for(let U=0;U<m;++U){let G=Math.max(0,Math.ceil((v-U)/h)),j=Math.min(f.outWidth,(f.inWidth+v-U)/h);for(let H=0;H<f.inChannels;++H)for(let Y=0;Y<f.outChannels;++Y){let Q=0;for(let X=0;X<f.batchSize;++X)for(let J=L;J<V;++J){let re=M+J*d-w;for(let oe=G;oe<j;++oe){let le=U+oe*h-v;y?Q+=A.get(X,re,le,H)*O.get(X,J,oe,Y):Q+=A.get(X,H,re,le)*O.get(X,Y,J,oe)}}x.set(Q,M,U,H,Y)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var Q4={kernelName:Xp,backendName:"cpu",kernelFunc:tme};function nme(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Z([o,s],"conv2dBackpropInput");let p=b.computeStrides(s.shape),f=b.computeStrides(o.shape),d=N.convertConv2DDataFormat(u),h=N.computeConv2DInfo(i,s.shape,a,1,l,c,!1,d),g=new tt(h.inShape,"float32"),m=g.values,y=e.data.get(o.dataId).values,x=e.data.get(s.dataId).values,[v,w,T]=p,{batchSize:k,filterHeight:A,filterWidth:O,inChannels:M,inHeight:L,inWidth:V,outChannels:U,outHeight:G,outWidth:j,strideHeight:H,strideWidth:Y}=h;d=h.dataFormat;let Q=A-1-h.padInfo.top,X=O-1-h.padInfo.left,J=d==="channelsLast",re=g.strides[0],oe=J?g.strides[1]:g.strides[2],le=J?g.strides[2]:1,ae=J?1:g.strides[1],fe=f[0],ce=J?f[1]:f[2],me=J?f[2]:1,Te=J?1:f[1];for(let Ae=0;Ae<k;++Ae)for(let Ee=0;Ee<M;++Ee)for(let qe=0;qe<L;++qe){let Ke=qe-Q,wt=Math.max(0,Math.ceil(Ke/H)),_t=Math.min(G,(A+Ke)/H);for(let tn=0;tn<V;++tn){let Ot=tn-X,Nt=Math.max(0,Math.ceil(Ot/Y)),Jt=Math.min(j,(O+Ot)/Y),qt=0;for(let Pn=wt;Pn<_t;++Pn){let wa=Pn*H-Ke;for(let Hr=Nt;Hr<Jt;++Hr){let du=Hr*Y-Ot,Lo=fe*Ae+ce*Pn+me*Hr,Ks=v*(A-1-wa)+w*(O-1-du)+T*Ee;for(let Ca=0;Ca<U;++Ca){let Ia=y[Lo+Te*Ca],Sa=x[Ks+Ca];qt+=Ia*Sa}}}let qs=re*Ae+oe*qe+le*tn+ae*Ee;m[qs]=qt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var J4={kernelName:Ka,backendName:"cpu",kernelFunc:nme};function rme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r;Z([o,s],"conv3d");let u=N.computeConv3DInfo(o.shape,s.shape,i,l,a),{filterDepth:c,filterHeight:p,filterWidth:f,dilationDepth:d,dilationHeight:h,dilationWidth:g,padInfo:m}=u,y=m.front,x=m.left,v=m.top,w=new tt(u.outShape,o.dtype),T=e.data.get(o.dataId).values,k=e.data.get(s.dataId).values,A=w.values,O=b.computeStrides(o.shape),M=b.computeStrides(s.shape);for(let L=0;L<u.batchSize;++L){let V=L*O[0],U=L*w.strides[0];for(let G=0;G<u.outDepth;++G){let j=U+G*w.strides[1],H=G*u.strideDepth-y;for(let Y=0;Y<c;++Y){let Q=H+Y*d;if(Q<0||Q>=u.inDepth)continue;let X=Y*M[0],J=V+Q*O[1];for(let re=0;re<u.outHeight;++re){let oe=j+re*w.strides[2],le=re*u.strideHeight-v;for(let ae=0;ae<p;++ae){let fe=le+ae*h;if(fe<0||fe>=u.inHeight)continue;let ce=X+ae*M[1],me=J+fe*O[2];for(let Te=0;Te<u.outWidth;++Te){let Ae=oe+Te*u.outChannels,Ee=Te*u.strideWidth-x;for(let qe=0;qe<f;++qe){let Ke=Ee+qe*g;if(Ke<0||Ke>=u.inWidth)continue;let wt=ce+qe*M[2],_t=me+Ke*u.inChannels,tn=wt;for(let Ot=0;Ot<u.inChannels;++Ot){let Nt=T[_t+Ot];for(let Jt=0;Jt<u.outChannels;++Jt)A[Ae+Jt]+=Nt*k[tn+Jt];tn+=u.outChannels}}}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}var eH={kernelName:Xa,backendName:"cpu",kernelFunc:rme};function ome(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:l}=r;Z([o,s],"conv3dBackpropFilterV2");let u=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=N.computeConv3DInfo(o.shape,l,i,1,a),f=p.strideDepth,d=p.strideHeight,h=p.strideWidth,g=p.filterDepth,m=p.filterHeight,y=p.filterWidth,x=new tt(p.filterShape,"float32"),v=x.values,[w,T,k,A]=x.strides,O=e.data.get(s.dataId).values,[M,L,V,U]=c,G=e.data.get(o.dataId).values,[j,H,Y,Q]=u,X=p.padInfo.front,J=p.padInfo.left,re=p.padInfo.top;for(let oe=0;oe<g;++oe){let le=Math.max(0,Math.ceil((X-oe)/f)),ae=Math.min(p.outDepth,(p.inDepth+X-oe)/f),fe=oe*w;for(let ce=0;ce<m;++ce){let me=Math.max(0,Math.ceil((re-ce)/d)),Te=Math.min(p.outHeight,(p.inHeight+re-ce)/d),Ae=ce*T+fe;for(let Ee=0;Ee<y;++Ee){let qe=Math.max(0,Math.ceil((J-Ee)/h)),Ke=Math.min(p.outWidth,(p.inWidth+J-Ee)/h),wt=Ee*k+Ae;for(let _t=0;_t<p.inChannels;++_t){let tn=_t*A+wt;for(let Ot=0;Ot<p.outChannels;++Ot){let Nt=0;for(let Jt=0;Jt<p.batchSize;++Jt){let qt=Jt*j,qs=Jt*M;for(let Pn=le;Pn<ae;++Pn){let Hr=(oe+Pn*f-X)*H+qt,du=Pn*L+qs;for(let Lo=me;Lo<Te;++Lo){let Ca=(ce+Lo*d-re)*Y+Hr,Ia=Lo*V+du;for(let Sa=qe;Sa<Ke;++Sa){let D0=(Ee+Sa*h-J)*Q+Ca,k0=Sa*U+Ia;Nt+=G[D0+_t]*O[k0+Ot]}}}}v[tn+Ot]=Nt}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var tH={kernelName:Yp,backendName:"cpu",kernelFunc:ome};function sme(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:l}=r;Z([o],"conv3dBackpropInputV2");let u=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=N.computeConv3DInfo(l,s.shape,a,1,i),f=new tt(p.inShape,"float32"),d=f.values,[h,g,m,y]=f.strides,x=e.data.get(o.dataId).values,[v,w,T,k]=u,A=e.data.get(s.dataId).values,[O,M,L,V]=c,{batchSize:U,filterDepth:G,filterHeight:j,filterWidth:H,inChannels:Y,inDepth:Q,inHeight:X,inWidth:J,outChannels:re,outDepth:oe,outHeight:le,outWidth:ae,strideDepth:fe,strideHeight:ce,strideWidth:me}=p,Te=G-1-p.padInfo.front,Ae=j-1-p.padInfo.top,Ee=H-1-p.padInfo.left;for(let qe=0;qe<U;++qe)for(let Ke=0;Ke<Y;++Ke)for(let wt=0;wt<Q;++wt){let _t=wt-Te,tn=Math.max(0,Math.ceil(_t/fe)),Ot=Math.min(oe,(G+_t)/fe);for(let Nt=0;Nt<X;++Nt){let Jt=Nt-Ae,qt=Math.max(0,Math.ceil(Jt/ce)),qs=Math.min(le,(j+Jt)/ce);for(let Pn=0;Pn<J;++Pn){let wa=Pn-Ee,Hr=Math.max(0,Math.ceil(wa/me)),du=Math.min(ae,(H+wa)/me),Lo=0;for(let Ks=tn;Ks<Ot;++Ks){let Ca=Ks*fe-_t;for(let Ia=qt;Ia<qs;++Ia){let Sa=Ia*ce-Jt;for(let Ih=Hr;Ih<du;++Ih){let D0=Ih*me-wa,k0=v*qe+w*Ks+T*Ia+k*Ih,tK=O*(G-1-Ca)+M*(j-1-Sa)+L*(H-1-D0)+V*Ke;for(let _g=0;_g<re;++_g){let nK=x[k0+_g],rK=A[tK+_g];Lo+=nK*rK}}}}d[h*qe+g*wt+m*Nt+y*Pn+Ke]=Lo}}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}var nH={kernelName:Zp,backendName:"cpu",kernelFunc:sme};var ime=Ie(gi,t=>Math.cos(t)),rH={kernelName:gi,backendName:"cpu",kernelFunc:ime};var ame=Ie(yi,t=>Math.cosh(t)),oH={kernelName:yi,backendName:"cpu",kernelFunc:ame};function lme(t){let{inputs:n,backend:e,attrs:r}=t,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,p,f,d]=o.shape,h=s.shape[0],[g,m]=a,y=he([h,g,m,d],"float32"),x=e.data.get(s.dataId).values,v=e.data.get(i.dataId).values,w=e.data.get(o.dataId).values,T=b.computeStrides(o.shape),k=b.computeStrides(y.shape);for(let A=0;A<h;A++){let O=A*4,M=x[O],L=x[O+1],V=x[O+2],U=x[O+3],G=v[A];if(G>=c)continue;let j=g>1?(V-M)*(p-1)/(g-1):0,H=m>1?(U-L)*(f-1)/(m-1):0;for(let Y=0;Y<g;Y++){let Q=g>1?M*(p-1)+Y*j:.5*(M+V)*(p-1);if(Q<0||Q>p-1){for(let X=0;X<m;X++)for(let J=0;J<d;J++){let re=J+X*k[2]+Y*k[1]+A*k[0];y.values[re]=u}continue}if(l==="bilinear"){let X=Math.floor(Q),J=Math.ceil(Q),re=Q-X;for(let oe=0;oe<m;oe++){let le=m>1?L*(f-1)+oe*H:.5*(L+U)*(f-1);if(le<0||le>f-1){for(let me=0;me<d;me++){let Te=me+oe*k[2]+Y*k[1]+A*k[0];y.values[Te]=u}continue}let ae=Math.floor(le),fe=Math.ceil(le),ce=le-ae;for(let me=0;me<d;me++){let Te=me+ae*T[2]+X*T[1]+G*T[0],Ae=w[Te];Te=me+fe*T[2]+X*T[1]+G*T[0];let Ee=w[Te];Te=me+ae*T[2]+J*T[1]+G*T[0];let qe=w[Te];Te=me+fe*T[2]+J*T[1]+G*T[0];let Ke=w[Te],wt=Ae+(Ee-Ae)*ce,_t=qe+(Ke-qe)*ce;Te=me+oe*k[2]+Y*k[1]+A*k[0],y.values[Te]=wt+(_t-wt)*re}}}else for(let X=0;X<m;++X){let J=m>1?L*(f-1)+X*H:.5*(L+U)*(f-1);if(J<0||J>f-1){for(let le=0;le<d;le++){let ae=le+X*k[2]+Y*k[1]+A*k[0];y.values[ae]=u}continue}let re=Math.round(J),oe=Math.round(Q);for(let le=0;le<d;le++){let ae=le+re*T[2]+oe*T[1]+G*T[0],fe=le+X*k[2]+Y*k[1]+A*k[0];y.values[fe]=w[ae]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var sH={kernelName:Jp,backendName:"cpu",kernelFunc:lme};function ume(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;Z(o,"cumprod");let l=N.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Vt({inputs:{x:o},backend:e,attrs:{perm:l}}));let c=N.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=nn(u.dtype,"int32"),f=b.makeOnesTypedArray(b.sizeFromShape(u.shape),p),d=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let v=g(y,x);if(x===0)f[v]=i?1:d[v];else{let w=g(y,x-1);f[v]=i?d[w]*f[w]:d[v]*f[w]}}let m=e.makeTensorInfo(u.shape,p,f);if(l!=null){let y=N.getUndoAxesPermutation(l),x=Vt({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}var iH={kernelName:Qp,backendName:"cpu",kernelFunc:ume};function cme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;Z(o,"cumsum");let l=N.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Vt({inputs:{x:o},backend:e,attrs:{perm:l}}));let c=N.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=nn(u.dtype,"int32"),f=b.makeZerosTypedArray(b.sizeFromShape(u.shape),p),d=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let v=g(y,x);if(x===0)f[v]=i?0:d[v];else{let w=g(y,x-1);f[v]=i?d[w]+f[w]:d[v]+f[w]}}let m=e.makeTensorInfo(u.shape,p,f);if(l!=null){let y=N.getUndoAxesPermutation(l),x=Vt({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}var aH={kernelName:Ya,backendName:"cpu",kernelFunc:cme};function pme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=Yd(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=e.bufferSync(o),u=e.bufferSync(s),c=Lv(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var lH={kernelName:ef,backendName:"cpu",kernelFunc:pme};function fme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockSize:s,dataFormat:i}=r;b.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],l=o.shape[1],u=o.shape[2],c=o.shape[3],p=l*s,f=u*s,d=c/(s*s),h=e.data.get(o.dataId).values,g=new Float32Array(a*p*f*d),m=0;for(let y=0;y<a;++y)for(let x=0;x<p;++x){let v=Math.floor(x/s),w=x%s;for(let T=0;T<f;++T){let k=Math.floor(T/s),A=T%s,O=(w*s+A)*d;for(let M=0;M<d;++M){let V=M+O+c*(k+u*(v+l*y));g[m++]=h[V]}}}return e.makeTensorInfo([a,p,f,d],o.dtype,g)}var uH={kernelName:tf,backendName:"cpu",kernelFunc:fme};function w1(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Z([o,s],"depthwiseConv2DNative");let c=b.computeStrides(o.shape),p=b.computeStrides(s.shape),f=l;f==null&&(f=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);let d=N.computeConv2DInfo(o.shape,s.shape,i,f,a,u,!0),{filterHeight:h,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:x}=d,v=x.left,w=x.top,T=d.outChannels/d.inChannels,k=new tt(d.outShape,o.dtype),A=e.data.get(o.dataId).values,O=e.data.get(s.dataId).values,M=k.values;for(let L=0;L<d.batchSize;++L){let V=L*c[0],U=L*k.strides[0];for(let G=0;G<d.outHeight;++G){let j=U+G*k.strides[1],H=G*d.strideHeight-w;for(let Y=0;Y<h;++Y){let Q=H+Y*m;if(Q<0||Q>=d.inHeight)continue;let X=Y*p[0],J=V+Q*c[1];for(let re=0;re<d.outWidth;++re){let oe=j+re*k.strides[2],le=re*d.strideWidth-v;for(let ae=0;ae<g;++ae){let fe=le+ae*y;if(fe<0||fe>=d.inWidth)continue;let ce=X+ae*p[1],me=J+fe*d.inChannels,Te=oe,Ae=ce;for(let Ee=0;Ee<d.inChannels;++Ee){let qe=A[me+Ee];for(let Ke=0;Ke<T;++Ke)M[Te+Ke]+=qe*O[Ae+Ke];Te+=T,Ae+=T}}}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var cH={kernelName:Za,backendName:"cpu",kernelFunc:w1};function dme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Z([o,s],"depthwiseConv2dNativeBackpropFilter");let p=N.computeConv2DInfo(o.shape,c,i,a,l,u,!0),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=p,m=new tt(p.filterShape,"float32"),y=p.padInfo.left,x=p.padInfo.top,v=p.outChannels/p.inChannels,w=e.data.get(o.dataId).values,T=new tt(o.shape,o.dtype,w),k=e.data.get(s.dataId).values,A=new tt(s.shape,s.dtype,k);for(let O=0;O<h;++O){let M=Math.max(0,Math.ceil((x-O)/f)),L=Math.min(p.outHeight,(p.inHeight+x-O)/f);for(let V=0;V<g;++V){let U=Math.max(0,Math.ceil((y-V)/d)),G=Math.min(p.outWidth,(p.inWidth+y-V)/d);for(let j=0;j<p.outChannels;++j){let H=Math.trunc(j/v),Y=j%v,Q=0;for(let X=0;X<p.batchSize;++X)for(let J=M;J<L;++J){let re=O+J*f-x;for(let oe=U;oe<G;++oe){let le=V+oe*d-y;Q+=T.get(X,re,le,H)*A.get(X,J,oe,j)}}m.set(Q,O,V,H,Y)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var pH={kernelName:nf,backendName:"cpu",kernelFunc:dme};function hme(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Z([o,s],"depthwiseConv2DNativeBackpropInput");let p=b.computeStrides(o.shape),f=b.computeStrides(s.shape),d=N.computeConv2DInfo(c,s.shape,i,a,l,u,!0),h=new tt(d.inShape,"float32"),g=h.values,[m,y,x]=h.strides,v=e.data.get(o.dataId).values,[w,T,k]=p,A=e.data.get(s.dataId).values,[O,M,L]=f,{batchSize:V,filterHeight:U,filterWidth:G,inChannels:j,inHeight:H,inWidth:Y,outChannels:Q,outHeight:X,outWidth:J,strideHeight:re,strideWidth:oe}=d,le=U-1-d.padInfo.top,ae=G-1-d.padInfo.left,fe=Q/j;for(let ce=0;ce<V;++ce)for(let me=0;me<j;++me)for(let Te=0;Te<H;++Te){let Ae=Te-le,Ee=Math.max(0,Math.ceil(Ae/re)),qe=Math.min(X,(U+Ae)/re);for(let Ke=0;Ke<Y;++Ke){let wt=Ke-ae,_t=Math.max(0,Math.ceil(wt/oe)),tn=Math.min(J,(G+wt)/oe),Ot=0;for(let Nt=Ee;Nt<qe;++Nt){let Jt=Nt*re-Ae;for(let qt=_t;qt<tn;++qt){let qs=qt*oe-wt,Pn=w*ce+T*Nt+k*qt,wa=O*(U-1-Jt)+M*(G-1-qs)+L*me;for(let Hr=0;Hr<fe;++Hr){let du=me*fe+Hr,Lo=v[Pn+du],Ks=A[wa+Hr];Ot+=Lo*Ks}}}g[m*ce+y*Te+x*Ke+me]=Ot}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var fH={kernelName:rf,backendName:"cpu",kernelFunc:hme};function mme(t){let{inputs:n,backend:e}=t,{x:r}=n,o=b.sizeFromShape(r.shape),s=e.data.get(r.dataId).values,i=he([o,o],r.dtype),a=i.values;for(let u=0;u<s.length;u++)a[u*o+u]=s[u];let l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}var dH={kernelName:of,backendName:"cpu",kernelFunc:mme};var hH={kernelName:Qa,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o}=t,{strides:s,pad:i,dilations:a}=e,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,p=l.data.get(o.dataId).values,f=o.shape.length,{batchSize:d,inHeight:h,inWidth:g,inChannels:m,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:T,filterHeight:k,filterWidth:A,dilationHeight:O,dilationWidth:M,outShape:L}=N.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),V=b.sizeFromShape(L),U=L.length,G=b.getArrayFromDType(r.dtype,V);for(let H=0;H<d;++H)for(let Y=0;Y<y;++Y){let Q=Y*w-v.top;for(let X=0;X<x;++X){let J=X*T-v.left;for(let re=0;re<m;++re){let oe=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<k;++ae){let fe=Q+ae*O;if(fe>=0&&fe<h)for(let ce=0;ce<A;++ce){let me=J+ce*M;if(me>=0&&me<g){let Te=b.locToIndex([H,fe,me,re],c,b.computeStrides(r.shape)),Ae=b.locToIndex([ae,ce,re],f,b.computeStrides(o.shape)),Ee=u[Te]+p[Ae];Ee>oe&&(oe=Ee)}}}let le=b.locToIndex([H,Y,X,re],U,b.computeStrides(L));G[le]=oe}}}return{dataId:l.write(b.toTypedArray(G,r.dtype),L,r.dtype),shape:L,dtype:r.dtype}}};var mH={kernelName:Cm,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o,dy:s}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=b.toNestedArray(r.shape,u.data.get(r.dataId).values),p=b.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:T,filterWidth:k,dilationHeight:A,dilationWidth:O,outShape:M}=N.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===M.length,()=>`Error in ${Cm}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let L=b.toNestedArray(M,u.data.get(s.dataId).values),V=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let G=0;G<f;++G)for(let j=0;j<m;++j){let H=j*v-x.top;for(let Y=0;Y<y;++Y){let Q=Y*w-x.left;for(let X=0;X<g;++X){let J=Number.MIN_SAFE_INTEGER,re=0,oe=0;for(let le=0;le<T;++le){let ae=H+le*A;if(ae>=0&&ae<d)for(let fe=0;fe<k;++fe){let ce=Q+fe*O;if(ce>=0&&ce<h){let me=c[G][ae][ce][X]+p[le][fe][X];me>J&&(J=me,re=le,oe=fe)}}}V[re][oe][X]+=L[G][j][Y][X]}}}return{dataId:u.write(b.toTypedArray(V,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var gH={kernelName:wm,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o,dy:s}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=b.toNestedArray(r.shape,u.data.get(r.dataId).values),p=b.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:T,filterWidth:k,dilationHeight:A,dilationWidth:O,outShape:M}=N.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===M.length,()=>`Error in ${wm}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let L=b.toNestedArray(M,u.data.get(s.dataId).values),V=b.makeZerosNestedTypedArray(r.shape,r.dtype);for(let G=0;G<f;++G)for(let j=0;j<m;++j){let H=j*v-x.top;for(let Y=0;Y<y;++Y){let Q=Y*w-x.left;for(let X=0;X<g;++X){let J=Number.MIN_SAFE_INTEGER,re=H<0?0:H,oe=Q<0?0:Q;for(let le=0;le<T;++le){let ae=H+le*A;if(ae>=0&&ae<d)for(let fe=0;fe<k;++fe){let ce=Q+fe*O;if(ce>=0&&ce<h){let me=c[G][ae][ce][X]+p[le][fe][X];me>J&&(J=me,re=ae,oe=ce)}}}V[G][re][oe][X]+=L[G][j][Y][X]}}}return{dataId:u.write(b.toTypedArray(V,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function gme(t){let{inputs:n,backend:e,attrs:r}=t,{image:o}=n,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:l}=i||{},u=l?.alpha||1,c=a?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(c,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${c} type.`);let[f,d]=o.shape.slice(0,2),h=o.shape.length===2?1:o.shape[2],g=e.data.get(o.dataId).values,m=o.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let v=0;v<f*d;++v){let w=[0,0,0,255*u];for(let k=0;k<h;k++){let A=g[v*h+k];if(o.dtype==="float32"){if(A<0||A>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${A}.`)}else if(o.dtype==="int32"&&(A<0||A>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${A}.`);h===1?(w[0]=A*m,w[1]=A*m,w[2]=A*m):w[k]=A*m}let T=v*4;y[T+0]=Math.round(w[0]),y[T+1]=Math.round(w[1]),y[T+2]=Math.round(w[2]),y[T+3]=Math.round(w[3])}s.width=d,s.height=f;let x=new ImageData(y,d,f);return p.putImageData(x,0,0),o}var yH={kernelName:Im,backendName:"cpu",kernelFunc:gme};function va(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;Z(o,"sum");let a;o.dtype==="bool"?a=Eo({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=Hn({inputs:{x:o},backend:e});let l=a.shape.length,u=b.parseAxisParam(s,a.shape),c=N.getAxesPermutation(u,l),p=u,f=a;c!=null&&(f=Vt({inputs:{x:a},backend:e,attrs:{perm:c}}),p=N.getInnerMostAxes(p.length,l)),N.assertAxesAreInnerMostDims("sum",p,f.shape.length);let[d,h]=N.computeOutAndReduceShapes(f.shape,p),g=N.upcastType(f.dtype,"int32"),m=Kd(e,d,g),y=b.sizeFromShape(h),x=e.data.get(m.dataId).values,v=e.data.get(f.dataId).values;for(let w=0;w<x.length;++w){let T=w*y,k=0;for(let A=0;A<y;++A)k+=v[T+A];x[w]=k}if(i){let w=N.expandShapeToKeepDim(m.shape,u),T=m;m=je({inputs:{x:m},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(T)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(f),m}var xH={kernelName:Il,backendName:"cpu",kernelFunc:va};function yme(t){let{inputs:n,backend:e,attrs:r}=t,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:l}=N.decodeEinsumEquation(o,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=N.getEinsumComputePath(a,l),p=c.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of c[g]){let{permutationIndices:y,expandDims:x}=N.getEinsumPermutation(d,l[m]),v;N.isIdentityPermutation(y)?v=s[m]:(v=Vt({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(v));let w=v.shape.slice();for(let T=0;T<x.length;++T)w.splice(x[T],0,1);b.arraysEqual(v.shape,w)||(v=je({inputs:{x:v},backend:e,attrs:{shape:w}}),h.push(v)),f===null?f=v:(f=Fc({inputs:{a:v,b:f},backend:e}),h.push(f))}g<p-1&&(u[g]>=0&&(f=va({inputs:{x:f},backend:e,attrs:{axis:u[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var bH={kernelName:sf,backendName:"cpu",kernelFunc:yme};function xme(t){let{inputs:n,backend:e}=t,{dy:r,y:o}=n;Z([r,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=a[l]:s[l]=a[l]*(u+1)}return e.makeTensorInfo(o.shape,"float32",s)}var vH={kernelName:af,backendName:"cpu",kernelFunc:xme};var bme=N.ERF_P,vme=N.ERF_A1,wme=N.ERF_A2,Cme=N.ERF_A3,Ime=N.ERF_A4,Sme=N.ERF_A5,Tme=Ie(vi,t=>{let n=Math.sign(t),e=Math.abs(t),r=1/(1+bme*e);return n*(1-((((Sme*r+Ime)*r+Cme)*r+wme)*r+vme)*r*Math.exp(-e*e))}),wH={kernelName:vi,backendName:"cpu",kernelFunc:Tme};function Ch(t){let{inputs:n,backend:e,attrs:r}=t,{input:o}=n,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),l=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),je({inputs:{x:o},backend:e,attrs:{shape:a}})}var CH={kernelName:Ja,backendName:"cpu",kernelFunc:Ch};var Nme=We((t,n)=>t/n),Eg=Ze(xi,Nme),Dg={kernelName:xi,backendName:"cpu",kernelFunc:Eg};function S0(t,n,e){let r=t.shape,o=r[0],s=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[o,s],c=b.sizeFromShape(u),p=b.getTypedArrayFromDType("float32",c),f=b.getTypedArrayFromDType("float32",c);for(let m=0;m<o;m++){let y=ko({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,s]}}),x=ko({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,s]}}),v=mn({inputs:{real:y,imag:x},backend:e}),{real:w,imag:T}=Eme(v,n,e),k=N.mergeRealAndImagArrays(w,T);for(let A=0;A<s;A++){let O=N.getComplexWithIndex(k,A);p[m*s+A]=O.real,f[m*s+A]=O.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(v)}let d=e.makeTensorInfo(u,"float32",p),h=e.makeTensorInfo(u,"float32",f),g=mn({inputs:{real:d,imag:h},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}function Eme(t,n,e){let r=b.sizeFromShape(t.shape),o=e.data.get(t.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(Dme(r)){let a=C1(s,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){let u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),p=e.makeTensorInfo([],"float32",b.createScalarValue(r,"float32")),f=Hn({inputs:{x:p},backend:e}),d=Dg.kernelFunc({inputs:{a:u,b:p},backend:e}),h=Dg.kernelFunc({inputs:{a:c,b:f},backend:e}),g=e.data.get(d.dataId).values,m=e.data.get(h.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),{real:g,imag:m}}return a}else{let a=N.mergeRealAndImagArrays(s,i),l=kme(a,r,n);return N.splitRealAndImagArrays(l)}}function Dme(t){return(t&t-1)===0}function C1(t,n,e,r,o){if(e===1)return{real:t,imag:n};let s=N.mergeRealAndImagArrays(t,n),i=e/2,a=N.complexWithEvenIndex(s),l=a.real,u=a.imag,c=[l.length],p=o.makeTensorInfo(c,"float32",l),f=o.makeTensorInfo(c,"float32",u),d=mn({inputs:{real:p,imag:f},backend:o}),h=N.complexWithOddIndex(s),g=h.real,m=h.imag,y=[g.length],x=o.makeTensorInfo(y,"float32",g),v=o.makeTensorInfo(y,"float32",m),w=mn({inputs:{real:x,imag:v},backend:o}),T=C1(l,u,i,r,o),k=T.real,A=T.imag,O=[k.length],M=o.makeTensorInfo(O,"float32",k),L=o.makeTensorInfo(O,"float32",A),V=mn({inputs:{real:M,imag:L},backend:o}),U=C1(g,m,i,r,o),G=U.real,j=U.imag,H=[G.length],Y=o.makeTensorInfo(H,"float32",G),Q=o.makeTensorInfo(H,"float32",j),X=mn({inputs:{real:Y,imag:Q},backend:o}),J=N.exponents(e,r),re=[J.real.length],oe=o.makeTensorInfo(re,"float32",J.real),le=o.makeTensorInfo(re,"float32",J.imag),ae=mn({inputs:{real:oe,imag:le},backend:o}),fe=Fc({inputs:{a:ae,b:X},backend:o}),ce=Vs({inputs:{a:V,b:fe},backend:o}),me=ng({inputs:{a:V,b:fe},backend:o}),Te=No({inputs:{input:ce},backend:o}),Ae=No({inputs:{input:me},backend:o}),Ee=Hs({inputs:{input:ce},backend:o}),qe=Hs({inputs:{input:me},backend:o}),Ke=fu({inputs:[Te,Ae],backend:o,attrs:{axis:0}}),wt=fu({inputs:[Ee,qe],backend:o,attrs:{axis:0}}),_t=o.data.get(Ke.dataId).values,tn=o.data.get(wt.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(le),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(ce),o.disposeIntermediateTensorInfo(me),o.disposeIntermediateTensorInfo(Te),o.disposeIntermediateTensorInfo(Ee),o.disposeIntermediateTensorInfo(Ae),o.disposeIntermediateTensorInfo(qe),o.disposeIntermediateTensorInfo(Ke),o.disposeIntermediateTensorInfo(wt),{real:_t,imag:tn}}function kme(t,n,e){let r=new Float32Array(n*2);for(let o=0;o<n;o++){let s=0,i=0;for(let a=0;a<n;a++){let l=N.exponent(o*a,n,e),u=N.getComplexWithIndex(t,a);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(s/=n,i/=n),N.assignToTypedArray(r,s,i,o)}return r}function Ame(t){let{inputs:n,backend:e}=t,{input:r}=n,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=je({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=S0(a,!1,e),u=je({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var IH={kernelName:lf,backendName:"cpu",kernelFunc:Ame};function kg(t){let{backend:n,attrs:e}=t,{shape:r,value:o,dtype:s}=e,i=s||b.inferDtype(o),a=b.getArrayFromDType(i,b.sizeFromShape(r));return Rme(a,o,i),n.makeTensorInfo(r,i,a)}var SH={kernelName:uf,backendName:"cpu",kernelFunc:kg};function Rme(t,n,e){t.fill(n)}var TH={kernelName:cf,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,o=e,s=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[i,a,l,u]=r.shape,c=o.data.get(r.dataId).values;for(let f=0;f<i;f++){let d=f*l*a*u;for(let h=0;h<a;h++){let g=h*(l*u);for(let m=0;m<l;m++){let y=m*u;for(let x=0;x<u;x++){let v=Math.round(l-m-1),w=d+g+y+x,T=c[w];if(v>=0&&v<l){let k=v*u,A=d+g+k+x;T=c[A]}s[w]=T}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function _me(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=v1({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let m=g;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=je({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=Vs({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Vs({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(d){let m=g;if(c==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let y=je({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=qc(e,g,d,y,h),e.disposeIntermediateTensorInfo(y)}else g=qc(e,g,d,a,h);e.disposeIntermediateTensorInfo(m)}return g}var NH={kernelName:Zu,backendName:"cpu",kernelFunc:_me};function Ome(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=w1({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let m=g;g=Vs({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(d){let m=g;g=qc(e,g,d,a,h),e.disposeIntermediateTensorInfo(m)}return g}var EH={kernelName:Qu,backendName:"cpu",kernelFunc:Ome};function Fme(t){let{inputs:n,backend:e}=t,{params:r,indices:o}=n,s=b.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[l,u,c,p]=N.prepareAndValidate(r,o);if(u===0)return e.makeTensorInfo(l,r.dtype,[]);let f=e.data.get(o.dataId).values,d=e.bufferSync(r),h=zv(f,d,r.dtype,u,a,c,p,r.shape,s);return e.makeTensorInfo(l,r.dtype,h.values)}var DH={kernelName:pf,backendName:"cpu",kernelFunc:Fme};function Mme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,indices:s}=n,{axis:i,batchDims:a}=r;Z([o,s],"gatherV2");let l=b.parseAxisParam(i,o.shape)[0],u=e.data.get(s.dataId).values,c=o.shape[l];for(let w=0;w<u.length;++w){let T=u[w];b.assert(T<=c-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let f=b.sizeFromShape(s.shape),d=N.segment_util.collectGatherOpShapeInfo(o,s,l,p),h=je({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=je({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,f/d.batchSize]}}),m=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=e.bufferSync(g),x=e.bufferSync(h),v=Vv(x,y,m);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(d.outputShape,v.dtype,v.values)}var kH={kernelName:tl,backendName:"cpu",kernelFunc:Mme};function $me(t){let{inputs:n,backend:e}=t,{input:r}=n,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=je({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=S0(a,!0,e),u=je({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var AH={kernelName:ff,backendName:"cpu",kernelFunc:$me};var Pme=Ie(Ni,t=>Number.isFinite(t)?1:0,"bool"),RH={kernelName:Ni,backendName:"cpu",kernelFunc:Pme};var Lme=Ie(Ei,t=>Math.abs(t)===1/0?1:0,"bool"),_H={kernelName:Ei,backendName:"cpu",kernelFunc:Lme};var Bme=Ie(Di,t=>Number.isNaN(t)?1:0,"bool"),OH={kernelName:Di,backendName:"cpu",kernelFunc:Bme};function zme(t){let{backend:n,attrs:e}=t,{start:r,stop:o,num:s}=e,i=Uv(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var FH={kernelName:hf,backendName:"cpu",kernelFunc:zme};var Vme=Ie(Ai,t=>Math.log1p(t)),MH={kernelName:Ai,backendName:"cpu",kernelFunc:Vme};var Ume=We((t,n)=>t&&n),Gme=Ze(ju,Ume,null,"bool"),$H={kernelName:ju,backendName:"cpu",kernelFunc:Gme};var Wme=Ie(Hu,t=>t?0:1,"bool"),PH={kernelName:Hu,backendName:"cpu",kernelFunc:Wme};var jme=We((t,n)=>t||n),Hme=Ze(qu,jme,null,"bool"),LH={kernelName:qu,backendName:"cpu",kernelFunc:Hme};function qme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:l}=r;Z(o,"LRN");let u=o.shape[3],c=u-1,p=e.data.get(o.dataId).values,f=b.sizeFromShape(o.shape),d=new Float32Array(f);function h(g){let m=g%u,y=g-m+Math.max(0,m-s),x=g-m+Math.min(m+s,c),v=0;for(;y<=x;y++){let w=p[y];v+=w*w}return v}for(let g=0;g<f;g++){let m=h(g),y=p[g]*Math.pow(i+a*m,-l);d[g]=y}return e.makeTensorInfo(o.shape,o.dtype,d)}var BH={kernelName:rl,backendName:"cpu",kernelFunc:qme};function Kme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Z(i,"LRNGrad");let p=b.sizeFromShape(i.shape),f=i.shape[3],d=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,g=e.data.get(s.dataId).values,m=new Float32Array(p),y=p;for(let x=0;x<y;x++){let v=x%f,w=x-v+Math.max(0,v-a),T=x-v+Math.min(f,v+a+1),k=0;for(let A=w;A<T;A++)k+=Math.pow(h[A],2);k=u*k+l;for(let A=w;A<T;A++){let O=-2*u*c*h[A]*g[x]/k;x===A&&(O+=Math.pow(k,-c)),O*=d[x],m[A]+=O}}return e.makeTensorInfo(i.shape,o.dtype,m)}var zH={kernelName:mf,backendName:"cpu",kernelFunc:Kme};function I1(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=e,l=o.shape,u=l.length,c=b.parseAxisParam(s,l),p=c,f=N.getAxesPermutation(p,u),d=a.data.get(o.dataId).values;if(f!=null){let w=new Array(u);for(let T=0;T<w.length;T++)w[T]=l[f[T]];d=Zd(d,l,o.dtype,f,w),p=N.getInnerMostAxes(p.length,u),l=w}Z(o,"max"),N.assertAxesAreInnerMostDims("max",p,u);let[h,g]=N.computeOutAndReduceShapes(l,p),m=b.sizeFromShape(g),y=Gv(d,m,h,o.dtype),x=a.write(y,h,o.dtype),v=h;return i&&(v=N.expandShapeToKeepDim(h,c)),{dataId:x,shape:v,dtype:o.dtype}}var VH={kernelName:ol,backendName:"cpu",kernelFunc:I1};function Xme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;Z(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=Hn({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=wh(f,o.shape,o.dtype,d,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var UH={kernelName:sl,backendName:"cpu",kernelFunc:Xme};function Yme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Z(o,"maxPool3d");let c=N.computePool3DInfo(o.shape,s,i,1,a,l,u),p=e.data.get(o.dataId).values,f=I0(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"max");return e.makeTensorInfo(f.shape,"float32",f.values)}var GH={kernelName:il,backendName:"cpu",kernelFunc:Yme};function Zme(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Z([o,s],"maxPool3DGrad");let c=N.computePool3DInfo(s.shape,i,a,1,l,u),p=e.bufferSync(s),f=L4(p,c),d=c.strideDepth,h=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,T=c.effectiveFilterWidth,k=v-1-c.padInfo.front,A=T-1-c.padInfo.left,O=w-1-c.padInfo.top,M=he(s.shape,"float32"),L=e.bufferSync(o);for(let V=0;V<c.batchSize;++V)for(let U=0;U<c.inChannels;++U)for(let G=0;G<c.inDepth;++G)for(let j=0;j<c.inHeight;++j)for(let H=0;H<c.inWidth;++H){let Y=G-k,Q=j-O,X=H-A,J=0;for(let re=0;re<v;re+=m){let oe=(Y+re)/d;if(!(oe<0||oe>=c.outDepth||Math.floor(oe)!==oe))for(let le=0;le<w;le+=y){let ae=(Q+le)/h;if(!(ae<0||ae>=c.outHeight||Math.floor(ae)!==ae))for(let fe=0;fe<T;fe+=x){let ce=(X+fe)/g;if(ce<0||ce>=c.outWidth||Math.floor(ce)!==ce)continue;let me=v*w*T-1-f.get(V,oe,ae,ce,U),Te=re*w*T+le*T+fe,Ae=me===Te?1:0;if(Ae===0)continue;let Ee=L.get(V,oe,ae,ce,U);J+=Ee*Ae}}}M.set(J,V,G,j,H,U)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}var WH={kernelName:yf,backendName:"cpu",kernelFunc:Zme};function Qme(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s,output:i}=n,a=s;Z([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,f=N.computePool2DInfo(a.shape,l,u,1,c,p),d=e.data.get(a.dataId).values,h=he(f.outShape,a.dtype,C0(d,a.shape,a.dtype,f).values),g=f.strideHeight,m=f.strideWidth,y=f.dilationHeight,x=f.dilationWidth,v=f.effectiveFilterHeight,w=f.effectiveFilterWidth,T=w-1-f.padInfo.left,k=v-1-f.padInfo.top,A=he(a.shape,"float32"),O=e.data.get(o.dataId).values,M=he(o.shape,"float32",O);for(let L=0;L<f.batchSize;++L)for(let V=0;V<f.inChannels;++V)for(let U=0;U<f.inHeight;++U)for(let G=0;G<f.inWidth;++G){let j=U-k,H=G-T,Y=0;for(let Q=0;Q<v;Q+=y){let X=(j+Q)/g;if(!(X<0||X>=f.outHeight||Math.floor(X)!==X))for(let J=0;J<w;J+=x){let re=(H+J)/m;if(re<0||re>=f.outWidth||Math.floor(re)!==re)continue;let oe=v*w-1-h.get(L,X,re,V),le=Q*w+J,ae=oe===le?1:0;if(ae===0)continue;let fe=M.get(L,X,re,V);Y+=fe*ae}}A.set(Y,L,U,G,V)}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var jH={kernelName:gf,backendName:"cpu",kernelFunc:Qme};function HH(t,n,e,r,o){let s=b.computeStrides(n),i=wh(t,n,e,s,o,"max"),a=C0(t,n,e,o,!0,r);return[i.values,a.values]}var qH={kernelName:xf,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,l=e;Z(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=N.computePool2DInfo(r.shape,o,s,[1,1],i),[p,f]=HH(u,r.shape,r.dtype,a,c),d=l.write(p,c.outShape,r.dtype),h=l.write(f,c.outShape,r.dtype);return[{dataId:d,shape:c.outShape,dtype:r.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function Jme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=b.parseAxisParam(s,o.shape),u=N.computeOutAndReduceShapes(o.shape,a)[1],c=b.sizeFromShape(u),p=[],f=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(f);let d=Eo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(d);let h=Eg({inputs:{a:d,b:f},backend:e});p.push(h);let g=va({inputs:{x:h},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}var KH={kernelName:al,backendName:"cpu",kernelFunc:Jme};function ege(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;Z(o,"min");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Vt({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let T=g[x+w];(Number.isNaN(T)||T<v)&&(v=T)}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=je({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var XH={kernelName:ll,backendName:"cpu",kernelFunc:ege};function tge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,mode:i}=r;Z(o,"mirrorPad");let a=s.map((v,w)=>v[0]+o.shape[w]+v[1]),l=s.map(v=>v[0]),u=s.map((v,w)=>v[0]+o.shape[w]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,f=o.shape.length,d=b.computeStrides(o.shape),h=b.sizeFromShape(a),g=a.length,m=b.computeStrides(a),y=b.getTypedArrayFromDType(o.dtype,h);for(let v=0;v<h;v++){let w=b.indexToLoc(v,g,m);for(let k=0;k<g;k++)w[k]<l[k]?w[k]=l[k]*2-w[k]-c:w[k]>=u[k]&&(w[k]=(u[k]-1)*2-w[k]+c);w=w.map((k,A)=>k-l[A]);let T=b.locToIndex(w,f,d);y[v]=p[T]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var YH={kernelName:ul,backendName:"cpu",kernelFunc:tge};var nge=We((t,n)=>{let e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),rge=Ze(Oi,nge),ZH={kernelName:Oi,backendName:"cpu",kernelFunc:rge};var JH=Sh(Pm());function S1(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let l=b.parseAxisParam([a],o.shape),u=I1({inputs:{x:o},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=N.expandShapeToKeepDim(u.shape,l),p=je({inputs:{x:u},backend:e,attrs:{shape:c}}),f=ng({inputs:{a:o,b:p},backend:e}),d=ME({inputs:{x:f},backend:e}),h=va({inputs:{x:d},backend:e,attrs:{axis:l,keepDims:!1}}),g=je({inputs:{x:h},backend:e,attrs:{shape:c}}),m=Eg({inputs:{a:d,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var QH={kernelName:Nl,backendName:"cpu",kernelFunc:S1};function oge(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r;Z(o,"multinomial");let l=a?o:S1({inputs:{logits:o},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=e.data.get(l.dataId).values,f=[u,s],d=b.makeZerosTypedArray(b.sizeFromShape(f),"int32");for(let h=0;h<u;++h){let g=h*c,m=new Float32Array(c-1);m[0]=p[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+p[g+v];let y=JH.alea(i.toString()),x=h*s;for(let v=0;v<s;++v){let w=y();d[x+v]=m.length;for(let T=0;T<m.length;T++)if(w<m[T]){d[x+v]=T;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(f,"int32",d)}var eq={kernelName:bf,backendName:"cpu",kernelFunc:oge};var sge=Wn.nonMaxSuppressionV3Impl;function ige(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Z(o,"NonMaxSuppression");let u=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=sge(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var tq={kernelName:vf,backendName:"cpu",kernelFunc:ige};var age=Wn.nonMaxSuppressionV4Impl;function lge(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Z(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:f,validOutputs:d}=age(c,p,i,a,l,u);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var nq={kernelName:wf,backendName:"cpu",kernelFunc:lge};var uge=Wn.nonMaxSuppressionV5Impl;function cge(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Z(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,f=i,d=a,h=l,g=u,{selectedIndices:m,selectedScores:y}=uge(c,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var rq={kernelName:Cf,backendName:"cpu",kernelFunc:cge};function pge(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:l}=r;Z(o,"oneHot");let u=b.sizeFromShape(o.shape),c=new Float32Array(u*i);c.fill(l);let p=e.data.get(o.dataId).values;for(let f=0;f<u;++f)p[f]>=0&&p[f]<i&&(c[f*i+p[f]]=a);return e.makeTensorInfo([...o.shape,i],s,c)}var oq={kernelName:fl,backendName:"cpu",kernelFunc:pge};function Ag(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=No({inputs:{input:r},backend:e}),s=Ag({inputs:{x:o},backend:e}),i=Hs({inputs:{input:r},backend:e}),a=Ag({inputs:{x:i},backend:e}),l=mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return kg({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var sq={kernelName:kl,backendName:"cpu",kernelFunc:Ag};function iq(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=No({inputs:{input:r},backend:e}),s=iq({inputs:{x:o},backend:e}),i=Hs({inputs:{input:r},backend:e}),a=Ag({inputs:{x:i},backend:e}),l=mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return kg({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var aq={kernelName:pl,backendName:"cpu",kernelFunc:iq};function T1(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r;if(n.length===1)return Ch({inputs:{input:n[0]},backend:e,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=n.map(c=>{let p=Ch({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),u=fu({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var lq={kernelName:dl,backendName:"cpu",kernelFunc:T1};function fge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,constantValue:i}=r;Z(o,"pad");let a=s.map((x,v)=>x[0]+o.shape[v]+x[1]),l=s.map(x=>x[0]),u=e.data.get(o.dataId).values,c=b.sizeFromShape(o.shape),p=o.shape.length,f=b.computeStrides(o.shape),d=b.sizeFromShape(a),h=a.length,g=b.computeStrides(a),m=b.getTypedArrayFromDType(o.dtype,d);i!==0&&m.fill(i);for(let x=0;x<c;x++){let w=b.indexToLoc(x,p,f).map((k,A)=>k+l[A]),T=b.locToIndex(w,h,g);m[T]=u[x]}return{dataId:e.write(m,a,o.dtype),shape:a,dtype:o.dtype}}var T0={kernelName:hl,backendName:"cpu",kernelFunc:fge};var dge=We((t,n)=>Math.pow(t,n)),hge=Ze(Mi,dge),uq={kernelName:Mi,backendName:"cpu",kernelFunc:hge};function mge(t){let{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,l=o.map(y=>e.data.get(y.dataId).values),u=o.map(y=>y.shape),c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,[f,d,h]=Wv(l,u,c,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var cq={kernelName:If,backendName:"cpu",kernelFunc:mge};function gge(t){let{inputs:n,backend:e}=t,{starts:r,limits:o,deltas:s}=n,i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=jv(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),f=e.makeTensorInfo([c.length],r.dtype,c);return[p,f]}var pq={kernelName:Sf,backendName:"cpu",kernelFunc:gge};function yge(t){let{inputs:n,backend:e,attrs:r}=t,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,f=a.map(m=>e.data.get(m.dataId).values),d=a.map(m=>m.shape),[h,g]=Hv(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var fq={kernelName:Tf,backendName:"cpu",kernelFunc:yge};function xge(t){let{backend:n,attrs:e}=t,{start:r,stop:o,dtype:s,step:i}=e,a=qv(r,o,i,s);return n.makeTensorInfo([a.length],s,a)}var dq={kernelName:Nf,backendName:"cpu",kernelFunc:xge};var bge=Ie($i,t=>1/t),hq={kernelName:$i,backendName:"cpu",kernelFunc:bge};function vge(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;Z(o,"resizeBilinear");let l=b.computeStrides(o.shape),[u,c]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(b.sizeFromShape([p,u,c,h])),y=[s&&u>1?f-1:f,s&&c>1?d-1:d],x=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=0,w=y[0]/x[0],T=y[1]/x[1];for(let k=0;k<p;k++)for(let A=0;A<u;A++){let O;i?O=w*(A+.5)-.5:O=w*A;let M=Math.max(0,Math.floor(O)),L=O-M,V=Math.min(f-1,Math.ceil(O)),U=k*l[0]+M*l[1],G=k*l[0]+V*l[1];for(let j=0;j<c;j++){let H;i?H=T*(j+.5)-.5:H=T*j;let Y=Math.max(0,Math.floor(H)),Q=H-Y,X=Math.min(d-1,Math.ceil(H)),J=U+Y*l[2],re=G+Y*l[2],oe=U+X*l[2],le=G+X*l[2];for(let ae=0;ae<h;ae++){let fe=g[J+ae],ce=g[re+ae],me=g[oe+ae],Te=g[le+ae],Ae=fe+(me-fe)*Q,Ee=ce+(Te-ce)*Q,qe=Ae+(Ee-Ae)*L;m[v++]=qe}}}return e.makeTensorInfo([p,u,c,h],"float32",m)}var mq={kernelName:bl,backendName:"cpu",kernelFunc:vge};function wge(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r;Z([s,o],"resizeBilinearGrad");let a=b.computeStrides(o.shape),[l,u,c,p]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*u*c*p),g=[i&&f>1?u-1:u,i&&d>1?c-1:c],m=[i&&f>1?f-1:f,i&&d>1?d-1:d],y=g[0]/m[0],x=g[1]/m[1],v=e.data.get(s.dataId).values,w=0;for(let T=0;T<l;T++){let k=T*a[0];for(let A=0;A<f;A++){let O=A*y,M=Math.floor(O),L=Math.min(Math.ceil(O),u-1),V=k+M*a[1],U=k+L*a[1],G=O-M,j=1-G;for(let H=0;H<d;H++){let Y=H*x,Q=Math.floor(Y),X=Math.min(Math.ceil(Y),c-1),J=Y-Q,re=1-J,oe=V+Q*a[2],le=V+X*a[2],ae=U+Q*a[2],fe=U+X*a[2],ce=j*re,me=j*J,Te=G*re,Ae=G*J;for(let Ee=0;Ee<p;Ee++){let qe=v[w++];h[oe+Ee]+=qe*ce,h[le+Ee]+=qe*me,h[ae+Ee]+=qe*Te,h[fe+Ee]+=qe*Ae}}}}return e.makeTensorInfo([l,c,u,p],"float32",h)}var gq={kernelName:kf,backendName:"cpu",kernelFunc:wge};function Cge(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;Z(o,"resizeNearestNeighbor");let l=b.computeStrides(o.shape),[u,c]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(p*u*c*h),y=[s&&u>1?f-1:f,s&&c>1?d-1:d],x=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/x[0],w=y[1]/x[1],T=0;for(let k=0;k<p;k++){let A=k*l[0];for(let O=0;O<u;O++){let M=i?v*(O+.5):v*O,L=Math.min(f-1,s?Math.round(M):Math.floor(M));i&&(L=Math.max(0,L));let V=A+L*l[1];for(let U=0;U<c;U++){let G=i?w*(U+.5):w*U,j=Math.min(d-1,s?Math.round(G):Math.floor(G));i&&(j=Math.max(0,j));let H=V+j*l[2];for(let Y=0;Y<h;Y++){let Q=g[H+Y];m[T++]=Q}}}}return e.makeTensorInfo([p,u,c,h],o.dtype,m)}var yq={kernelName:xl,backendName:"cpu",kernelFunc:Cge};function Ige(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r;Z([s,o],"resizeNearestNeighborGrad");let a=b.computeStrides(o.shape),l=b.computeStrides(s.shape),[u,c,p,f]=o.shape,[,d,h]=s.shape,g=new Float32Array(u*c*p*f),m=e.data.get(s.dataId).values,y=[i&&d>1?c-1:c,i&&h>1?p-1:p],x=[i&&d>1?d-1:d,i&&h>1?h-1:h],v=y[0]/x[0],w=y[1]/x[1],T=1/v,k=1/w,A=Math.ceil(T)*2+2,O=Math.ceil(k)*2+2;for(let M=0;M<u;M++){let L=M*a[0];for(let V=0;V<c;V++){let U=L+V*a[1],G=Math.floor(V*T),j=Math.floor(G-A/2);for(let H=0;H<p;H++){let Y=U+H*a[2],Q=Math.floor(H*k),X=Math.floor(Q-O/2);for(let J=0;J<f;J++){let re=0;for(let oe=0;oe<A;oe++){let le=oe+j;if(le<0||le>=d)continue;let ae=L+le*l[1],fe=le*v,ce=Math.min(c-1,i?Math.round(fe):Math.floor(fe));if(V===ce)for(let me=0;me<O;me++){let Te=me+X;if(Te<0||Te>=h)continue;let Ae=ae+Te*l[2],Ee=Te*w,qe=Math.min(p-1,i?Math.round(Ee):Math.floor(Ee));H===qe&&(re+=m[Ae+J])}}g[Y+J]=re}}}}return e.makeTensorInfo(o.shape,o.dtype,g)}var xq={kernelName:Df,backendName:"cpu",kernelFunc:Ige};function Sge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dims:s}=r;Z(o,"reverse");let i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Hn({inputs:{x:o},backend:e});let l=new tt(o.shape,o.dtype),u=e.bufferSync(o);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),f=p.slice();a.forEach(d=>f[d]=o.shape[d]-1-f[d]),l.set(u.get(...f),...p)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}var bq={kernelName:vl,backendName:"cpu",kernelFunc:Sge};var vq={kernelName:Hf,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,{radians:o,fillValue:s,center:i}=n,a=e,l=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[u,c,p,f]=r.shape,[d,h]=N.getImageCenter(i,c,p),g=255,m=Math.sin(o),y=Math.cos(o),x=a.data.get(r.dataId).values;for(let w=0;w<u;w++){let T=w*p*c*f;for(let k=0;k<c;k++){let A=k*(p*f);for(let O=0;O<p;O++){let M=O*f;for(let L=0;L<f;L++){let V=[u,k,O,L],U=V[2],G=V[1],j=(U-d)*y-(G-h)*m,H=(U-d)*m+(G-h)*y;j=Math.round(j+d),H=Math.round(H+h);let Y=s;if(typeof s!="number"&&(L===3?Y=g:Y=s[L]),j>=0&&j<p&&H>=0&&H<c){let X=H*(p*f),J=j*f,re=T+X+J+L;Y=x[re]}let Q=T+A+M+L;l[Q]=Y}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var Tge=Ie(Bi,t=>{let n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2===0?n:n+1}),wq={kernelName:Bi,backendName:"cpu",kernelFunc:Tge};function Nge(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(s,o,i),f=!0,d=e.bufferSync(o),h=e.bufferSync(s),g=rs(d,h,i,p,u,l,a,c,0,f);return e.makeTensorInfo(i,g.dtype,g.values)}var Cq={kernelName:Af,backendName:"cpu",kernelFunc:Nge};function Ege(t,n){let e=0,r=t.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),t[o]<n?e=o+1:r=o;return r}function Dge(t,n){let e=0,r=t.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),t[o]<=n?e=o+1:r=o;return r}function Iq(t,n,e,r,o,s){let i=b.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let l=t.slice(a*r,(a+1)*r),u=a*o;for(let c=0;c<o;++c)i[u+c]=s==="left"?Ege(l,n[c+u]):Dge(l,n[c+u])}return i}function kge(t){let{inputs:n,backend:e,attrs:r}=t,{sortedSequence:o,values:s}=n,{side:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,u=Iq(a,l,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",u)}var Sq={kernelName:_f,backendName:"cpu",kernelFunc:kge};function Age(t){let{inputs:n,backend:e}=t,{condition:r,t:o,e:s}=n;Z([r,o,s],"select");let i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=nn(o.dtype,s.dtype),p=b.makeZerosTypedArray(b.sizeFromShape(o.shape),c),f=0,d=i===0||i>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let h=0;h<a.length;h++)for(let g=0;g<d;g++)a[h]===1?p[f++]=l[h]:p[f++]=u[h];return e.makeTensorInfo(o.shape,c,p)}var Tq={kernelName:wl,backendName:"cpu",kernelFunc:Age};var Rge=N.SELU_SCALEALPHA,_ge=N.SELU_SCALE,Oge=Ie(Vi,t=>t>=0?_ge*t:Rge*(Math.exp(t)-1)),Nq={kernelName:Vi,backendName:"cpu",kernelFunc:Oge};var Fge=Ie(Wi,t=>t<0?-1:t>0?1:0),Eq={kernelName:Wi,backendName:"cpu",kernelFunc:Fge};var Mge=Ie(Ui,t=>Math.sin(t)),Dq={kernelName:Ui,backendName:"cpu",kernelFunc:Mge};var $ge=Ie(Gi,t=>Math.sinh(t)),kq={kernelName:Gi,backendName:"cpu",kernelFunc:$ge};var Pge=11920928955078125e-23,Aq=Math.log(Pge)+2,Lge=Ie(Hi,t=>{let n=t>-Aq,e=t<Aq,r=Math.exp(t),o;return e?o=r:n?o=t:o=Math.log(1+r),o}),Rq={kernelName:Hi,backendName:"cpu",kernelFunc:Lge};function Bge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,paddings:i}=r;Z([o],"spaceToBatchND");let a=b.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let k=1+s.length;k<o.shape.length;++k)l.push([0,0]);let u=T0.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),c=N.getReshaped(u.shape,s,a,!1),p=N.getPermuted(c.length,s.length,!1),f=N.getReshapedPermuted(u.shape,s,a,!1),g=je({inputs:{x:u},backend:e,attrs:{shape:c}}),x=Vt({inputs:{x:g},backend:e,attrs:{perm:p}}),T=je({inputs:{x},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),T}var _q={kernelName:Sl,backendName:"cpu",kernelFunc:Bge};function zge(t){let{inputs:n,backend:e}=t,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,f,d,h,g]=Kv(a,r.shape,r.dtype,l,o.dtype,u,c);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var Oq={kernelName:Of,backendName:"cpu",kernelFunc:zge};function Vge(t){let{inputs:n,backend:e}=t,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(s.dataId).values),[u,c,p]=Xv(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Fq={kernelName:Ff,backendName:"cpu",kernelFunc:Vge};function Uge(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=Qd(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}var Mq={kernelName:Mf,backendName:"cpu",kernelFunc:Uge};function Gge(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=Qd(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}var $q={kernelName:$f,backendName:"cpu",kernelFunc:Gge};function Wge(t){let{inputs:n,backend:e,attrs:r}=t,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=N.calculateShapes(s,o,a),d=!1,h=e.bufferSync(o),g;switch(s.dtype){case"bool":{let m=e.bufferSync(s),y=!!e.data.get(i.dataId).values[0];g=rs(h,m,a,f,c,u,l,p,y,d);break}case"float32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=rs(h,m,a,f,c,u,l,p,y,d);break}case"int32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=rs(h,m,a,f,c,u,l,p,y,d);break}case"string":{let m=e.bufferSync(s),y=b.decodeString(e.data.get(i.dataId).values[0]);g=rs(h,m,a,f,c,u,l,p,y,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}var Pq={kernelName:Pf,backendName:"cpu",kernelFunc:Wge};function jge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=N.prepareSplitSize(o,s,a),u=new Array(o.shape.length).fill(0),c=o.shape.slice();return l.map(p=>{let f=[...c];f[a]=p;let d=ko({inputs:{x:o},backend:e,attrs:{begin:u,size:f}});return u[a]+=p,d})}var Lq={kernelName:Tl,backendName:"cpu",kernelFunc:jge};var Bq={kernelName:Lf,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{let{x:e}=t,r=n;Z(e,"square");let o=r.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let l=o[a];s[a]=l*l}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var Hge=Ie(Qi,(t,n)=>{let e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),zq={kernelName:Qi,backendName:"cpu",kernelFunc:Hge};function qge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=r;Z(o,"stridedSlice");let{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:v,strides:w}=Sn.sliceInfo(o.shape,s,i,a,l,u,c,p,f),T;if(g)T=je({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let k=Sn.computeOutShape(x,v,w),A=ko({inputs:{x:o},backend:e,attrs:{begin:x,size:k}});T=je({inputs:{x:A},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(A)}else{let k=e.bufferSync(o),A=Yv(d,k,w,x);T=e.makeTensorInfo(h,A.dtype,A.values)}return T}var Vq={kernelName:Bf,backendName:"cpu",kernelFunc:qge};function Kge(t){let{inputs:n,backend:e,attrs:r}=t,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=n,f=e.data.get(c.dataId).values,d=e.data.get(p.dataId).values,[h,g]=Zv(f,d,o,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var Uq={kernelName:zf,backendName:"cpu",kernelFunc:Kge};function Xge(t){let{inputs:n,backend:e,attrs:r}=t,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,p]=Qv(a,l,o),f=c.length;return[e.makeTensorInfo([f,2],"int32",u),e.makeTensorInfo([f],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var Gq={kernelName:Vf,backendName:"cpu",kernelFunc:Xge};function Yge(t){let{inputs:n,backend:e,attrs:r}=t,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=Jv(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var Wq={kernelName:Uf,backendName:"cpu",kernelFunc:Yge};var Zge=Ie(Yi,t=>Math.tan(t)),jq={kernelName:Yi,backendName:"cpu",kernelFunc:Zge};var Qge=Ie(Zi,t=>Math.tanh(t)),Hq={kernelName:Zi,backendName:"cpu",kernelFunc:Qge};function Jge(t){let{inputs:n,backend:e}=t,{tensor:r,indices:o,updates:s}=n,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=N.calculateShapes(s,o,r.shape),p=!1,f=e.bufferSync(o),d=e.bufferSync(s),h=e.bufferSync(r),g=rs(f,d,r.shape,c,l,a,i,u,h,p);return e.makeTensorInfo(r.shape,g.dtype,g.values)}var qq={kernelName:Rf,backendName:"cpu",kernelFunc:Jge};function eye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reps:s}=r;Z(o,"tile");let i=ew(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var Kq={kernelName:Ns,backendName:"cpu",kernelFunc:eye};function tye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{k:s,sorted:i}=r;Z(o,"topk");let a=e.data.get(o.dataId).values,[l,u]=tw(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}var Xq={kernelName:Gf,backendName:"cpu",kernelFunc:tye};function nye(t){let{inputs:n,attrs:e,backend:r}=t,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,p,f,d]=o.shape,[h,g]=u??[p,f],m=[c,h,g,d],y=b.computeStrides(o.shape),x=y[0],v=y[1],w=y[2],T=b.computeStrides(m),k=T[0],A=T[1],O=T[2],M=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(m));M.fill(l);let L=r.data.get(o.dataId).values,V=r.data.get(s.dataId).values;for(let G=0;G<c;++G){let j=s.shape[0]===1?V:V.subarray(G*8,G*8+8);for(let H=0;H<h;++H)for(let Y=0;Y<g;++Y)for(let Q=0;Q<d;++Q){let X,J=j[6]*Y+j[7]*H+1;if(J===0)continue;let re=(j[0]*Y+j[1]*H+j[2])/J,oe=(j[3]*Y+j[4]*H+j[5])/J,le=Yq(re,f,a),ae=Yq(oe,p,a);switch(i){case"nearest":X=aye(L,p,f,x,v,w,G,ae,le,Q,l);break;case"bilinear":X=lye(L,p,f,x,v,w,G,ae,le,Q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let fe=G*k+H*A+Y*O+Q;M[fe]=X}return r.makeTensorInfo(m,o.dtype,M)}return{dataId:r.write(M,m,o.dtype),shape:o.shape,dtype:o.dtype}}var Zq={kernelName:Wf,backendName:"cpu",kernelFunc:nye};function Yq(t,n,e){switch(e){case"reflect":return rye(t,n);case"wrap":return oye(t,n);case"nearest":return iye(t,n);case"constant":default:return sye(t,n)}}function rye(t,n){let e=t;if(e<0)if(n<=1)e=0;else{let r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{let r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return b.clamp(0,e,n-1)}function oye(t,n){let e=t;if(e<0)if(n<=1)e=0;else{let r=n-1;e+=n*(Math.trunc(-e/r)+1)}else if(e>n-1)if(n<=1)e=0;else{let r=n-1;e-=n*Math.trunc(e/r)}return b.clamp(0,e,n-1)}function sye(t,n){return t}function iye(t,n){return b.clamp(0,t,n-1)}function Rg(t,n,e,r,o,s,i,a,l,u,c){let p=i*r+a*o+l*s+u;return 0<=a&&a<n&&0<=l&&l<e?t[p]:c}function aye(t,n,e,r,o,s,i,a,l,u,c){let p=Math.round(a),f=Math.round(l);return Rg(t,n,e,r,o,s,i,p,f,u,c)}function lye(t,n,e,r,o,s,i,a,l,u,c){let p=Math.floor(a),f=Math.floor(l),d=p+1,h=f+1,g=(h-l)*Rg(t,n,e,r,o,s,i,p,f,u,c)+(l-f)*Rg(t,n,e,r,o,s,i,p,h,u,c),m=(h-l)*Rg(t,n,e,r,o,s,i,d,f,u,c)+(l-f)*Rg(t,n,e,r,o,s,i,d,h,u,c);return(d-a)*g+(a-p)*m}function uye(t){let{inputs:n,attrs:e,backend:r}=t,{axis:o}=e,{x:s}=n;Z(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:u}=nw(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var Qq={kernelName:jf,backendName:"cpu",kernelFunc:uye};function cye(t){let{inputs:n,backend:e,attrs:r}=t,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],l=new Array(i-1),u=0;for(let d=0;d<i;d++)d!==s&&(l[u++]=o.shape[d]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let f=new Array(a);for(let d=0;d<f.length;d++){c[s]=d;let h=ko({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});f[d]=je({inputs:{x:h},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(h)}return f}var Jq={kernelName:El,backendName:"cpu",kernelFunc:cye};function pye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,segmentIds:s}=n,{numSegments:i}=r;Z(o,"unsortedSegmentSum");let a=o.shape.length,l=s.shape.length,u=[],c=[],p=a-l,f=s;for(let h=0;h<p;++h){let g=Ch({inputs:{input:f},backend:e,attrs:{dim:h+1}});f=g,c.push(g)}for(let h=0;h<i;++h){let g=b.createScalarValue(h,"int32"),m=e.makeTensorInfo([],"int32",g),y=OE({inputs:{a:m,b:f},backend:e}),x=Eo({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=Fc({inputs:{a:x,b:o},backend:e}),w=va({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(m),c.push(y),c.push(x),c.push(v),c.push(w)}let d=T1({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var eK={kernelName:Dl,backendName:"cpu",kernelFunc:pye};var fye=[T4,LP,N4,E4,GP,D4,k4,A4,R4,_4,O4,F4,M4,$4,P4,B4,z4,V4,U4,S4,G4,W4,j4,WP,H4,UP,jP,q4,BP,K4,Y4,Z4,Q4,J4,eH,tH,nH,rH,oH,sH,iH,aH,lH,uH,cH,pH,fH,dH,hH,mH,gH,yH,bH,x4,vH,HP,wH,qP,CH,KP,IH,SH,TH,XP,YP,NH,EH,DH,kH,ZP,QP,zP,AH,X4,RH,_H,OH,b4,JP,eL,FH,tL,MH,$H,PH,LH,BH,zH,VH,nL,UH,GH,WH,jH,qH,KH,XH,rL,YH,ZH,eq,oL,sL,tq,nq,rq,iL,oq,aq,lq,T0,uq,v4,lL,cq,pq,fq,dq,VP,Dg,hq,w4,C4,I4,mq,gq,yq,xq,bq,vq,wq,dL,Cq,Sq,Tq,Nq,mL,Eq,Dq,kq,gL,QH,Rq,_q,Oq,Fq,Mq,$q,Pq,Lq,xL,Bq,bL,vL,zq,Vq,Uq,Gq,Wq,wL,xH,jq,Hq,qq,Kq,Xq,Zq,aL,Qq,Jq,eK,sq];for(let t of fye)Dx(t);var mye=["video"],gye=["canvas"],N0=class t{videoElement;canvasElement;model;ngOnInit(){this.startVideo(),this.loadHandposeModel()}loadHandposeModel(){return z(this,null,function*(){this.model=yield G$(),console.log("Handpose Model loaded."),this.checkVideoAndStartDetection()})}startVideo(){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){console.error("La API getUserMedia no es compatible con este navegador."),alert("Tu navegador no soporta la API getUserMedia necesaria para acceder a la c\xE1mara.");return}navigator.mediaDevices.getUserMedia({video:!0}).then(n=>{let e=this.videoElement.nativeElement;e.srcObject=n,e.onloadedmetadata=()=>{e.play(),this.checkVideoAndStartDetection()}}).catch(n=>{console.error("Error al acceder a la c\xE1mara",n),n.name==="NotAllowedError"&&alert("Se requiere permiso para acceder a la c\xE1mara. Por favor, permite el acceso en la configuraci\xF3n del navegador.")})}checkVideoAndStartDetection(){this.model&&this.videoElement.nativeElement.readyState>=3?this.detectHands():(console.log("Waiting model and video..."),setTimeout(()=>this.checkVideoAndStartDetection(),500))}detectHands(){return z(this,null,function*(){let n=this.videoElement.nativeElement,e=this.canvasElement.nativeElement,r=e.getContext("2d");if(r)for(e.width=n.videoWidth,e.height=n.videoHeight;;){let o=yield this.model.estimateHands(n);r.clearRect(0,0,e.width,e.height),o.length>0&&o.forEach(s=>{let i=s.landmarks;this.drawHand(r,i),this.detectGesture(i)}),yield Nc()}})}drawHand(n,e){n.fillStyle="red",e.forEach(([r,o])=>{n.beginPath(),n.arc(r,o,5,0,2*Math.PI),n.fill()})}detectGesture(n){let e=n[4],r=n[8];e[1]<r[1]&&console.log("\u{1F44D} Finger tip detected")}static \u0275fac=function(e){return new(e||t)};static \u0275cmp=xp({type:t,selectors:[["app-hand-detection"]],viewQuery:function(e,r){if(e&1&&(OS(mye,5),OS(gye,5)),e&2){let o;Zy(o=Qy())&&(r.videoElement=o.first),Zy(o=Qy())&&(r.canvasElement=o.first)}},standalone:!0,features:[Ip],decls:5,vars:0,consts:[["video",""],["canvas",""],[1,"camera-container"],["autoplay","","playsinline",""]],template:function(e,r){e&1&&(Xy(0,"div",2),Au(1,"video",3,0)(3,"canvas",null,1),Yy())},styles:[".camera-container[_ngcontent-%COMP%]{position:relative;width:100%;height:100%}video[_ngcontent-%COMP%], canvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:auto;max-width:100%}"]})};var E0=class t{title="hand-gesture-app";static \u0275fac=function(e){return new(e||t)};static \u0275cmp=xp({type:t,selectors:[["app-root"]],standalone:!0,features:[Ip],decls:1,vars:0,template:function(e,r){e&1&&Au(0,"app-hand-detection")},dependencies:[N0]})};z_(E0,EO).catch(t=>console.error(t));
